<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[D.W's Notes - Machine Learning]]></title>
  <subtitle><![CDATA[——悄悄是别离的笙箫，沉默是今晚的康桥.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://csuldw.github.io//"/>
  <updated>2016-03-18T01:33:31.271Z</updated>
  <id>http://csuldw.github.io//</id>
  
  <author>
    <name><![CDATA[刘帝伟]]></name>
    <email><![CDATA[csu.ldw@csu.edu.cn]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[分类之性能评估指标]]></title>
    <link href="http://csuldw.github.io/2016/03/12/2016-03-12-performance-evaluation/"/>
    <id>http://csuldw.github.io/2016/03/12/2016-03-12-performance-evaluation/</id>
    <published>2016-03-12T12:03:00.000Z</published>
    <updated>2016-03-18T01:33:31.271Z</updated>
    <content type="html"><![CDATA[<p>出处：<a href="http://www.csuldw.com/2016/03/12/2016-03-12-performance-evaluation/" target="_blank" rel="external">http://www.csuldw.com/2016/03/12/2016-03-12-performance-evaluation/</a>  </p>
<p>本文主要介绍几种常用的分类评估指标，同时介绍如何绘制ROC曲线以及AUC值的便捷的计算方法。最后再附上一个绘制ROC曲线和计算AUC的源码实现。</p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="Precision和Recall">Precision和Recall</h2><p>首先我们来看看下面这个混淆矩阵：</p>
<table>
<thead>
<tr>
<th>pred_label/true_label</th>
<th>Positive</th>
<th>Negative</th>
</tr>
</thead>
<tbody>
<tr>
<td>Positive</td>
<td>TP</td>
<td>FP</td>
</tr>
<tr>
<td>Negtive</td>
<td>FN</td>
<td>TN</td>
</tr>
</tbody>
</table>
<p>如上表所示，行表示预测的label值，列表示真实label值。TP，FP，FN，TN分别表示如下意思：</p>
<ul>
<li>TP（true positive）：表示样本的真实类别为正，最后预测得到的结果也为正；</li>
<li>FP（false positive）：表示样本的真实类别为负，最后预测得到的结果却为正；</li>
<li>FN（false negative）：表示样本的真实类别为正，最后预测得到的结果却为负；</li>
<li>TN（true negative）：表示样本的真实类别为负，最后预测得到的结果也为负.</li>
</ul>
<p>根据以上几个指标，可以分别计算出Accuracy、Precision、Recall（Sensitivity，SN），Specificity（SP）。</p>
<p>$$Accuracy = \frac{TP+TN}{TP+FP+TN+FN}$$</p>
<p>$$Precision = \frac{TP}{TP+FP}$$</p>
<p>$$Recall = \frac{TP}{TP+FN}$$</p>
<p>$$SP = \frac{TN}{TN + FP}$$</p>
<ul>
<li>Accuracy：表示预测结果的精确度，预测正确的样本数除以总样本数。</li>
<li>precision，准确率，表示预测结果中，预测为正样本的样本中，正确预测为正样本的概率；</li>
<li>recall，召回率，表示在原始样本的正样本中，最后被正确预测为正样本的概率；</li>
<li>specificity，常常称作特异性，它研究的样本集是原始样本中的负样本，表示的是在这些负样本中最后被正确预测为负样本的概率。</li>
</ul>
<p>在实际当中，我们往往希望得到的precision和recall都比较高，比如当FN和FP等于0的时候，他们的值都等于1。但是，它们往往在某种情况下是互斥的，比如这种情况，50个正样本，50个负样本，结果全部预测为正，那么它的precision为1而recall却为0.5.所以需要一种折衷的方式，因此就有了F1-score。</p>
<p>$$ F1-score = \frac{ 2 \times recall \times precision}{ recall + precision}$$</p>
<p>F1-score表示的是precision和recall的调和平均评估指标。</p>
<p>此外还有MCC：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24MCC%20%3D%20%5Cfrac%7BTP%20%5Ctimes%20TN%20-%20FP%20%5Ctimes%20FN%7D%7B%20%5Csqrt%20%7B%28TP%20&plus;%20FP%29%28TP%20&plus;%20FN%29%28%20TN%20&plus;%20FP%29%28TN&plus;FN%29%7D%7D%24%24" alt="$$MCC = \frac{TP \times TN - FP \times FN}{ \sqrt {(TP + FP)(TP + FN)( TN + FP)(TN+FN)}}$$"></p>
<h2 id="ROC曲线">ROC曲线</h2><p>ROC（receiver operating characteristic），平面的横坐标是false positive rate(FPR)假阳率，纵坐标是true positive rate(TPR)真阳率。ROC计算过程如下：</p>
<ul>
<li>首先每个样本都需要有一个label值，并且还需要一个预测的score值（取值0到1）;</li>
<li>然后按这个score对样本由大到小进行排序，假设这些数据位于表格中的一列，从上到下依次降序;</li>
<li>现在从上到下按照样本点的取值进行划分，位于分界点上面的我们把它归为预测为正样本，位于分界点下面的归为负样本;</li>
<li>分别计算出此时的TPR（Recall）=TP/P和FPR（1-SP）=FP/N，然后在图中绘制（FPR, TPR）点。</li>
</ul>
<p>从上往下逐个样本计算，最后会得到一条光滑的曲线 。</p>
<p>然而，千言万语不如下面的这幅图懂得快：</p>
<p><img src="http://www.csuldw.com/assets/articleImg/roc_plot.gif" alt=""></p>
<div class="caption">『roc曲线绘制动画—图片来自<a href="http://stats.stackexchange.com/questions/105501/understanding-roc-curve/105577" target="_blank" rel="external">参考文献5</a>.』</div>


<h2 id="AUC计算">AUC计算</h2><p>AUC（area under the curve）就是ROC曲线下方的面积，取值在0.5到1之间，因为随机猜测得到额AUC就是0.5。面积如下图所示，阴影部分即为AUC面积：</p>
<p><img src="http://www.csuldw.com/assets/articleImg/area_under_curve.png" alt=""></p>
<div class="caption">『AUC面积图解—图片来自<a href="http://stats.stackexchange.com/questions/105501/understanding-roc-curve/105577" target="_blank" rel="external">参考文献5</a>.』</div>

<p>AUC的几种解释（来自<a href="http://stats.stackexchange.com/questions/132777/what-does-auc-stand-for-and-what-is-it?" target="_blank" rel="external">【Interpreting the AUROC】</a>）:</p>
<ul>
<li>The expectation that a uniformly drawn random positive is ranked before a uniformly drawn random negative.</li>
<li>The expected proportion of positives ranked before a uniformly drawn random negative.</li>
<li>The expected true positive rate if the ranking is split just before a uniformly drawn random negative.</li>
<li>The expected proportion of negatives ranked after a uniformly drawn random positive.</li>
<li>The expected false positive rate if the ranking is split just after a uniformly drawn random positive.</li>
</ul>
<p>下面来介绍下它的计算方法，AUC的计算主要有以下三种。</p>
<p>第一种：积分思维。这也是在早期机器学习文献中常用的AUC计算方法。从积分的思想中演化而来的。假如我们的测试样本有限，那么我们得到的AUC曲线必然是呈现阶梯形状。因此，计算的AUC也就是这些阶梯下面的面积之和（有没有想起以前学高数时的积分面积哈）。我们可以这样来计算，首先把score值进行排序，假设score越大，此样本属于正类的概率就越大。然后一边扫描一边计算就可以得到我们想要的AUC。但是，这样做会有个缺点，当多个测试样本的score值相等时，我们调整一下阈值，得到的不是往上或者往右的延展，而是斜着向上形成一个梯形。此时，就需要计算这个梯形的面积，这样是比较麻烦。 简单的用代码描述下</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">auc = <span class="number">0.0</span></span><br><span class="line"><span class="variable">height</span> = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> each training example x_i, y_i：</span><br><span class="line">  <span class="keyword">if</span> y_i = <span class="number">1.0</span>:</span><br><span class="line">    <span class="variable">height</span> = <span class="variable">height</span> + tpr</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    auc +=  <span class="variable">height</span> * fpr</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> auc</span><br></pre></td></tr></table></figure>
<p>第二种：<a href="https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test" target="_blank" rel="external">Mann–Whitney U test（MWW）</a>。关于AUC还有一个很有趣的性质，它和Wilcoxon-Mann-Witney Test类似（可以去google搜一下），而Wilcoxon-Mann-Witney Test就是<font color="#007FFF"><strong>测试任意给一个正类样本和一个负类样本，正类样本的score有多大的概率大于负类样本的score</strong></font>。有了这个定义，就可以得到了另外一中计算AUC的方法：计算出这个概率值。我们知道，在有限样本中我们常用的得到概率的办法就是通过频率来估计之。这种估计随着样本规模的扩大而逐渐逼近真实值。样本数越多，计算的AUC越准确类似，也和计算积分的时候，小区间划分的越细，计算的越准确是同样的道理。具体来说就是：<font color="red"> 统计一下所有的 M×N(M为正类样本的数目，N为负类样本的数目)个正负样本对中，有多少个组中的正样本的score大于负样本的score。当二元组中正负样本的 score相等的时候，按照0.5计算。然后除以MN。实现这个方法的复杂度为O(n^2  )。n为样本数(即n=M+N)</font>,公式表示如下：</p>
<p><img src="http://latex.codecogs.com/gif.latex?AUC%20%3D%20%5Cfrac%7B%5Csum_i%5En%20%28%20%5C%20pos%5C_score%20%3E%20neg%5C_score%20%5C%20%29%20&plus;%200.5%20*%20%5Csum_i%5En%7B%28%5C%20pos%5C_score%3Dneg%5C_score%5C%20%29%7D%7D%7BM%20*%20N%7D" alt="$$**AUC = \frac{\sum_i^n ( \ pos\_score  &gt; neg\_score \ )}{M * N}**$$"></p>
<p>第三种：该方法和上述第二种方法原理一样，但复杂度降低了。首先对score从大到小排序，然后令最大score对应的sample的rank值为n，第二大score对应sample的rank值为n-1，以此类推从n到1。然后把所有的正类样本的rank相加，再减去正类样本的score为最小的那M个值的情况。得到的结果就是有多少对正类样本的score值大于负类样本的score值，最后再除以M×N即可。值得注意的是，当存在score相等的时候，对于score相等的样本，需要赋予相同的rank值(无论这个相等的score是出现在同类样本还是不同类的样本之间，都需要这样处理)。具体操作就是再把所有这些score相等的样本 的rank取平均。然后再使用上述公式。此公式描述如下： </p>
<p><img src="http://latex.codecogs.com/gif.latex?AUC%20%3D%20%5Cfrac%7B%5Csum_%7Bins_i%20%5Cepsilon%20pos%7Drank_%7Bins_i%7D%20-%20%5Cfrac%7BM%20*%20%28M&plus;1%29%7D%7B2%7D%7D%7BM%20*%20N%7D" alt="$$AUC = \frac{\sum_{ins_i \epsilon pos}rank_{ins_i} - \frac{M * (M+1)}{2}}{M * N}$$"></p>
<p>这三种方法，第一种比较好理解，后面两种确实不太好理解，先记下，慢慢理解。</p>
<h2 id="源码">源码</h2><p>最后，附上ROC曲线绘制代码。下面使用的思想类似积分，但是求得是AUC的近似值，忽略了梯形部分，Code如下：</p>
<p>依赖库：</p>
<ul>
<li>numpy</li>
<li>matplotlib</li>
</ul>
<pre><code><span class="comment"># -*- coding: utf-8 -*-</span>
<span class="string">"""
Created on Sat Mar 12 17:43:48 2016

@author: liudiwei
"""</span>
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

<span class="function"><span class="keyword">def</span> <span class="title">plotROC</span><span class="params">(predScore, labels)</span>:</span>
    point = (<span class="number">1.0</span>, <span class="number">1.0</span>) <span class="comment">#由于下面排序的索引是从小到大，所以这里从(1,1)开始绘制</span>
    ySum = <span class="number">0.0</span> 
    numPos = np.sum(np.array(labels)==<span class="number">1.0</span>)
    numNeg = len(labels)-numPos
    yStep = <span class="number">1</span>/np.float(numPos)
    xStep = <span class="number">1</span>/np.float(numNeg)
    sortedIndex = predScore.argsort() <span class="comment">#对predScore进行排序，的到排序索引值</span>
    fig = plt.figure()
    fig.clf()
    ax = plt.subplot(<span class="number">111</span>)
    <span class="keyword">for</span> index <span class="keyword">in</span> sortedIndex.tolist()[<span class="number">0</span>]:
        <span class="keyword">if</span> labels[index] == <span class="number">1.0</span>: <span class="comment">#如果正样本各入加1，则x不走动，y往下走动一步</span>
            delX = <span class="number">0</span>
            delY = yStep;
        <span class="keyword">else</span>:                   <span class="comment">#否则，x往左走动一步，y不走动</span>
            delX = xStep
            delY = <span class="number">0</span>
            ySum += point[<span class="number">1</span>]     <span class="comment">#统计y走动的所有步数的和</span>
        ax.plot([point[<span class="number">0</span>], point[<span class="number">0</span>] - delX], [point[<span class="number">1</span>], point[<span class="number">1</span>] - delY],c=<span class="string">'b'</span>)
        point = (point[<span class="number">0</span>] - delX, point[<span class="number">1</span>] - delY)
    ax.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'b--'</span>)
    plt.xlabel(<span class="string">'False positive rate'</span>); plt.ylabel(<span class="string">'True positive rate'</span>)
    plt.title(<span class="string">'ROC Curve'</span>)
    ax.axis([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])
    plt.show() 
    <span class="comment">#最后，所有将所有矩形的高度进行累加，最后乘以xStep得到的总面积，即为AUC值</span>
    <span class="keyword">print</span> <span class="string">"the Area Under the Curve is: "</span>, ySum * xStep
</code></pre><p>对于ROC曲线绘制中的参数，输入的第二个参数是类别标签（如，+1，-1形成的文件，每行表示一个样本的真实类别）；第一个参数则是由模型训练出来的预测强度，如Adaboost对样本i预测的结果为0.67，对i+1个样本预测的结果是0.3，等等，每行一个，格式和classLabels一样。最后绘制ROC曲线的同时，也在输出ROC曲线下方的AUC面积。</p>
<h2 id="参考文献">参考文献</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" target="_blank" rel="external">https://en.wikipedia.org/wiki/Receiver_operating_characteristic</a><br>[2] <a href="http://blog.csdn.net/chjjunking/article/details/5933105" target="_blank" rel="external">http://blog.csdn.net/chjjunking/article/details/5933105</a><br>[3]《Machine Learning in Action》<br>[4] <a href="https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test" target="_blank" rel="external">https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test</a><br>[5] <a href="http://stats.stackexchange.com/questions/105501/understanding-roc-curve/105577" target="_blank" rel="external">Understanding ROC curve</a><br>[6] <a href="http://stats.stackexchange.com/questions/145566/how-to-calculate-area-under-the-curve-auc-or-the-c-statistic-by-hand" target="_blank" rel="external">http://stats.stackexchange.com/questions/145566/how-to-calculate-area-under-the-curve-auc-or-the-c-statistic-by-hand</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>出处：<a href="http://www.csuldw.com/2016/03/12/2016-03-12-performance-evaluation/">http://www.csuldw.com/2016/03/12/2016-03-12-performance-evaluation/</a>  </p>
<p>本文主要介绍几种常用的分类评估指标，同时介绍如何绘制ROC曲线以及AUC值的便捷的计算方法。最后再附上一个绘制ROC曲线和计算AUC的源码实现。</p>]]>
    
    </summary>
    
      <category term="AUC" scheme="http://csuldw.github.io/tags/AUC/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="ROC" scheme="http://csuldw.github.io/tags/ROC/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PCA主成分分析Python实现]]></title>
    <link href="http://csuldw.github.io/2016/02/28/2016-02-28-pca/"/>
    <id>http://csuldw.github.io/2016/02/28/2016-02-28-pca/</id>
    <published>2016-02-28T07:24:00.000Z</published>
    <updated>2016-03-18T01:31:09.514Z</updated>
    <content type="html"><![CDATA[<p>出处：<a href="http://www.csuldw.com/2016/02/28/2016-02-28-pca/" target="_blank" rel="external">http://www.csuldw.com/2016/02/28/2016-02-28-pca/</a><br>Github源码：<a href="https://github.com/csuldw/MachineLearning/tree/master/PCA" target="_blank" rel="external">https://github.com/csuldw/MachineLearning/tree/master/PCA</a></p>
<p>PCA（principle component analysis） ，主成分分析，主要是用来降低数据集的维度，然后挑选出主要的特征。原理简单，实现也简单。关于原理公式的推导，本文不会涉及，你可以参考下面的参考文献，也可以去Wikipedia，这里主要关注实现，算是锻炼一下自己，对PCA在理论的基础上画个圆满的句号。</p>
<a id="more"></a>
<p>本来是在复习LDA的，然后就看到了PCA，就跟着下面这篇文章的步骤，把PCA用python实现了一遍，具体的思想可以参考这篇文章，讲的通俗易懂，主要是有个实例参考，值得拥有！</p>
<ul>
<li><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/18/2020209.html" target="_blank" rel="external">JerryLead之PCA主成分分析</a></li>
</ul>
<p>下面自己来简单的清理下思路！</p>
<h2 id="PCA思想">PCA思想</h2><p>思想：<font color="#007FFF"><strong>移动坐标轴，将n维特征映射到k维上（k&lt;n），这k维是全新的正交特征。</strong></font>这k维特征称为主元，是重新构造出来的k维特征，而不是简单地从n维特征中去除其余n-k维特征。</p>
<p>说到PCA难免会提到LDA（linear discriminate analysis，线性判别分析），以及FA（factor analysis，因子分析）。关于LDA，打算有时间也用代码实现一遍，下面给出它的主要思想。</p>
<p>LDA思想：<font color="#007FFF"><strong>最大类间距离，最小类内距离</strong></font>。简而言之，第一，为了实现投影后的两个类别的距离较远，用映射后两个类别的均值差的绝对值来度量。第二，为了实现投影后，每个类内部数据点比较聚集，用投影后每个类别的方差来度量。</p>
<p>三者的描述如下</p>
<p> 以下内容引自 <a href="https://en.wikipedia.org/wiki/Linear_discriminant_analysis" target="_blank" rel="external">Wikipedia- Linear discriminant analysis</a></p>
<blockquote>
<p>LDA is also closely related to principal component analysis (PCA) and factor         analysis in that they both look for linear combinations of variables which best explain the data.[4] LDA explicitly attempts to model the difference between the classes of data. PCA on the other hand does not take into account any difference in class, and factor analysis builds the feature combinations based on differences rather than similarities. Discriminant analysis is also different from factor analysis in that it is not an interdependence technique: a distinction between independent variables and dependent variables (also called criterion variables) must be made.</p>
</blockquote>
<p>区别：PCA选择样本点投影具有最大方差的方向，LDA选择分类性能最好的方向。</p>
<p>好了，下面来看下实现源码！</p>
<h2 id="基本步骤">基本步骤</h2><p>基本步骤：</p>
<ul>
<li>对数据进行归一化处理（代码中并非这么做的，而是直接减去均值）</li>
<li>计算归一化后的数据集的协方差矩阵                   </li>
<li>计算协方差矩阵的特征值和特征向量</li>
<li>保留最重要的k个特征（通常k&lt;n），可以自己制定，也可以选择个阈值，让后通过前k个特征值之和减去后面n-k个特征值之和大于这个阈值，找到这个k</li>
<li>找出k个特征值对应的特征向量</li>
<li>将m $*$ n的数据集乘以k个n维的特征向量的特征向量（n $*$ k）,得到最后降维的数据。</li>
</ul>
<p>其实PCA的本质就是对角化协方差矩阵。有必要解释下为什么将特征值按从大到小排序后再选。首先，要明白特征值表示的是什么？在线性代数里面我们求过无数次了，那么它具体有什么意义呢？对一个$n*n$的对称矩阵进行分解，我们可以求出它的特征值和特征向量，就会产生n个n维的正交基，每个正交基会对应一个特征值。然后把矩阵投影到这n个基上，此时特征值的模就表示矩阵在该基的投影长度。<font color="#007FFF"><strong>特征值越大，说明矩阵（样本）在对应的特征向量上投影后的方差越大，样本点越离散，越容易区分，信息量也就越多</strong></font>。因此，特征值最大的对应的特征向量方向上所包含的信息量就越多，如果某几个特征值很小，那么就说明在该方向的信息量非常少，我们就可以删除小特征值对应方向的数据，只保留大特征值方向对应的数据，这样做以后数据量减小，但有用的信息量都保留下来了。PCA就是这个原理。</p>
<h2 id="源码实现">源码实现</h2><p>1.首先引入numpy，由于测试中用到了pandas和matplotlib，所以这里一并加载</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<p>2.定义一个均值函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算均值,要求输入数据为numpy的矩阵格式，行表示样本数，列表示特征    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">meanX</span><span class="params">(dataX)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(dataX,axis=<span class="number">0</span>)<span class="comment">#axis=0表示按照列来求均值，如果输入list,则axis=1</span></span><br></pre></td></tr></table></figure>
<p>3.编写pca方法，具体解释参考注释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">参数：</span><br><span class="line">	- XMat：传入的是一个numpy的矩阵格式，行表示样本数，列表示特征    </span><br><span class="line">	- k：表示取前k个特征值对应的特征向量</span><br><span class="line">返回值：</span><br><span class="line">	- finalData：参数一指的是返回的低维矩阵，对应于输入参数二</span><br><span class="line">	- reconData：参数二对应的是移动坐标轴后的矩阵</span><br><span class="line">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(XMat, k)</span>:</span></span><br><span class="line">    average = meanX(XMat) </span><br><span class="line">    m, n = np.shape(XMat)</span><br><span class="line">    data_adjust = []</span><br><span class="line">    avgs = np.tile(average, (m, <span class="number">1</span>))</span><br><span class="line">    data_adjust = XMat - avgs</span><br><span class="line">    covX = np.cov(data_adjust.T)   <span class="comment">#计算协方差矩阵</span></span><br><span class="line">    featValue, featVec=  np.linalg.eig(covX)  <span class="comment">#求解协方差矩阵的特征值和特征向量</span></span><br><span class="line">    index = np.argsort(-featValue) <span class="comment">#按照featValue进行从大到小排序</span></span><br><span class="line">    finalData = []</span><br><span class="line">    <span class="keyword">if</span> k &gt; n:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"k must lower than feature number"</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#注意特征向量时列向量，而numpy的二维矩阵(数组)a[m][n]中，a[1]表示第1行值</span></span><br><span class="line">        selectVec = np.matrix(featVec.T[index[:k]]) <span class="comment">#所以这里需要进行转置</span></span><br><span class="line">        finalData = data_adjust * selectVec.T </span><br><span class="line">        reconData = (finalData * selectVec) + average  </span><br><span class="line">    <span class="keyword">return</span> finalData, reconData</span><br></pre></td></tr></table></figure>
<p>4.编写一个加载数据集的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入文件的每行数据都以\t隔开</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loaddata</span><span class="params">(datafile)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.array(pd.read_csv(datafile,sep=<span class="string">"\t"</span>,header=-<span class="number">1</span>)).astype(np.float)</span><br></pre></td></tr></table></figure>
<p>5.可视化结果</p>
<p>因为我将维数k指定为2，所以可以使用下面的函数将其绘制出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(data1, data2)</span>:</span>	  </span><br><span class="line">    dataArr1 = np.array(data1)</span><br><span class="line">    dataArr2 = np.array(data2)</span><br><span class="line">    </span><br><span class="line">    m = np.shape(dataArr1)[<span class="number">0</span>]</span><br><span class="line">    axis_x1 = []</span><br><span class="line">    axis_y1 = []</span><br><span class="line">    axis_x2 = []</span><br><span class="line">    axis_y2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        axis_x1.append(dataArr1[i,<span class="number">0</span>])</span><br><span class="line">        axis_y1.append(dataArr1[i,<span class="number">1</span>])</span><br><span class="line">        axis_x2.append(dataArr2[i,<span class="number">0</span>]) </span><br><span class="line">        axis_y2.append(dataArr2[i,<span class="number">1</span>])				  </span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(axis_x1, axis_y1, s=<span class="number">50</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(axis_x2, axis_y2, s=<span class="number">50</span>, c=<span class="string">'blue'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'x1'</span>); plt.ylabel(<span class="string">'x2'</span>);</span><br><span class="line">    plt.savefig(<span class="string">"outfile.png"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>6.测试方法</p>
<p>测试方法写入main函数中，然后直接执行main方法即可：</p>
<p>data.txt可到github中下载：<a href="https://github.com/csuldw/MachineLearning/tree/master/PCA/data.txt" target="_blank" rel="external">data.txt</a></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#根据数据集data<span class="class">.txt</span></span><br><span class="line">def <span class="function"><span class="title">main</span><span class="params">()</span></span>:    </span><br><span class="line">    datafile = <span class="string">"data.txt"</span></span><br><span class="line">    XMat = <span class="function"><span class="title">loaddata</span><span class="params">(datafile)</span></span></span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    return <span class="function"><span class="title">pca</span><span class="params">(XMat, k)</span></span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    finalData, reconMat = <span class="function"><span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="title">plotBestFit</span><span class="params">(finalData, reconMat)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="结果展示">结果展示</h2><p>最后的结果图如下：</p>
<p><img src="/assets/images/pca.png" alt=""></p>
<p>蓝色部分为重构后的原始数据，红色则是提取后的二维特征！</p>
<h2 id="参考文献">参考文献</h2><p>[1] <a href="http://www.cnblogs.com/jerrylead/archive/2011/04/18/2020209.html" target="_blank" rel="external">http://www.cnblogs.com/jerrylead/archive/2011/04/18/2020209.html</a><br>[2] <a href="https://en.wikipedia.org/wiki/Linear_discriminant_analysis" target="_blank" rel="external">Wikipedia- Linear discriminant analysis</a><br>[3] <a href="https://en.wikipedia.org/wiki/Principal_component_analysis" target="_blank" rel="external">Wikipedia- Principal_component_analysis</a><br>[4]<a href="https://www.zhihu.com/question/21874816" target="_blank" rel="external">知乎-如何理解矩阵特征值</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>出处：<a href="http://www.csuldw.com/2016/02/28/2016-02-28-pca/">http://www.csuldw.com/2016/02/28/2016-02-28-pca/</a><br>Github源码：<a href="https://github.com/csuldw/MachineLearning/tree/master/PCA">https://github.com/csuldw/MachineLearning/tree/master/PCA</a></p>
<p>PCA（principle component analysis） ，主成分分析，主要是用来降低数据集的维度，然后挑选出主要的特征。原理简单，实现也简单。关于原理公式的推导，本文不会涉及，你可以参考下面的参考文献，也可以去Wikipedia，这里主要关注实现，算是锻炼一下自己，对PCA在理论的基础上画个圆满的句号。</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="PCA" scheme="http://csuldw.github.io/tags/PCA/"/>
    
      <category term="主成分分析" scheme="http://csuldw.github.io/tags/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法比较]]></title>
    <link href="http://csuldw.github.io/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/"/>
    <id>http://csuldw.github.io/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/</id>
    <published>2016-02-26T12:24:00.000Z</published>
    <updated>2016-03-18T01:31:15.982Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/" target="_blank" rel="external">http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/</a></p>
<p>本文主要回顾下几个常用算法的适应场景及其优缺点！（提示：部分内容摘自网络）。</p>
<a id="more"></a>
<p>机器学习算法太多了，分类、回归、聚类、推荐、图像识别领域等等，要想找到一个合适算法真的不容易，所以在实际应用中，我们一般都是采用启发式学习方式来实验。通常最开始我们都会选择大家普遍认同的算法，诸如SVM，GBDT，Adaboost，现在深度学习很火热，神经网络也是一个不错的选择。假如你在乎精度（accuracy）的话，最好的方法就是通过交叉验证（cross-validation）对各个算法一个个地进行测试，进行比较，然后调整参数确保每个算法达到最优解，最后选择最好的一个。但是如果你只是在寻找一个“足够好”的算法来解决你的问题，或者这里有些技巧可以参考，下面来分析下各个算法的优缺点，基于算法的优缺点，更易于我们去选择它。</p>
<h2 id="偏差&amp;方差">偏差&amp;方差</h2><p>在统计学中，一个模型好坏，是根据偏差和方差来衡量的，所以我们先来普及一下偏差和方差：</p>
<ul>
<li>偏差：描述的是预测值（估计值）的期望E’与真实值Y之间的差距。偏差越大，越偏离真实数据。</li>
</ul>
<p><img src="https://upload.wikimedia.org/math/d/5/0/d50ed92100881594dd3e3e5fe524d1d9.png" alt=""></p>
<ul>
<li>方差：描述的是预测值P的变化范围，离散程度，是预测值的方差，也就是离其期望值E的距离。方差越大，数据的分布越分散。</li>
</ul>
<p><img src="https://upload.wikimedia.org/math/6/4/9/6491e89f257cf71eea37182592f4cd3c.png" alt=""></p>
<p>模型的真实误差是两者之和，如下图：</p>
<p><img src="https://upload.wikimedia.org/math/c/b/c/cbc65310d09a6efa630d8c1f33cdfa88.png" alt=""></p>
<p>如果是小训练集，高偏差/低方差的分类器（例如，朴素贝叶斯NB）要比低偏差/高方差大分类的优势大（例如，KNN），因为后者会过拟合。但是，随着你训练集的增长，模型对于原数据的预测能力就越好，偏差就会降低，此时低偏差/高方差分类器就会渐渐的表现其优势（因为它们有较低的渐近误差），此时高偏差分类器此时已经不足以提供准确的模型了。</p>
<p>当然，你也可以认为这是生成模型（NB）与判别模型（KNN）的一个区别。</p>
<font color="red">为什么说朴素贝叶斯是高偏差低方差?</font>

<p>以下内容引自知乎：</p>
<blockquote>
<p>首先，假设你知道训练集和测试集的关系。简单来讲是我们要在训练集上学习一个模型，然后拿到测试集去用，效果好不好要根据测试集的错误率来衡量。但很多时候，我们只能假设测试集和训练集的是符合同一个数据分布的，但却拿不到真正的测试数据。这时候怎么在只看到训练错误率的情况下，去衡量测试错误率呢？</p>
<p>由于训练样本很少（至少不足够多），所以通过训练集得到的模型，总不是真正正确的。（就算在训练集上正确率100%，也不能说明它刻画了真实的数据分布，要知道刻画真实的数据分布才是我们的目的，而不是只刻画训练集的有限的数据点）。而且，实际中，训练样本往往还有一定的噪音误差，所以如果太追求在训练集上的完美而采用一个很复杂的模型，会使得模型把训练集里面的误差都当成了真实的数据分布特征，从而得到错误的数据分布估计。这样的话，到了真正的测试集上就错的一塌糊涂了（这种现象叫过拟合）。但是也不能用太简单的模型，否则在数据分布比较复杂的时候，模型就不足以刻画数据分布了（体现为连在训练集上的错误率都很高，这种现象较欠拟合）。过拟合表明采用的模型比真实的数据分布更复杂，而欠拟合表示采用的模型比真实的数据分布要简单。</p>
<p>在统计学习框架下，大家刻画模型复杂度的时候，有这么个观点，认为Error = Bias + Variance。这里的Error大概可以理解为模型的预测错误率，是有两部分组成的，一部分是由于模型太简单而带来的估计不准确的部分（Bias），另一部分是由于模型太复杂而带来的更大的变化空间和不确定性（Variance）。</p>
<p>所以，这样就容易分析朴素贝叶斯了。它简单的假设了各个数据之间是无关的，是一个被<font color="blue"><strong>严重简化了的模型</strong></font>。所以，对于这样一个简单模型，大部分场合都会Bias部分大于Variance部分，也就是说高偏差而低方差。</p>
<p>在实际中，为了让Error尽量小，我们在选择模型的时候需要平衡Bias和Variance所占的比例，也就是平衡over-fitting和under-fitting。</p>
</blockquote>
<p>偏差和方差与模型复杂度的关系使用下图更加明了：</p>
<p><img src="/assets/articleImg/bias_variance.png" alt=""></p>
<p>当模型复杂度上升的时候，偏差会逐渐变小，而方差会逐渐变大。</p>
<h2 id="常见算法优缺点">常见算法优缺点</h2><h3 id="1-朴素贝叶斯">1.<strong>朴素贝叶斯</strong></h3><p>朴素贝叶斯属于生成式模型（关于生成模型和判别式模型，主要还是在于是否是要求联合分布），非常简单，你只是做了一堆计数。如果注有条件独立性假设（一个比较严格的条件），朴素贝叶斯分类器的收敛速度将快于判别模型，如逻辑回归，所以你只需要较少的训练数据即可。即使NB条件独立假设不成立，NB分类器在实践中仍然表现的很出色。它的主要缺点是它不能学习特征间的相互作用，用mRMR中R来讲，就是特征冗余。引用一个比较经典的例子，比如，虽然你喜欢Brad Pitt和Tom Cruise的电影，但是它不能学习出你不喜欢他们在一起演的电影。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。</li>
<li>对小规模的数据表现很好，能个处理多分类任务，适合增量式训练；</li>
<li>对缺失数据不太敏感，算法也比较简单，常用于文本分类。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要计算先验概率；</li>
<li>分类决策存在错误率；</li>
<li>对输入数据的表达形式很敏感。</li>
</ul>
<hr>
<h3 id="2-Logistic_Regression（逻辑回归）">2.<strong>Logistic Regression（逻辑回归）</strong></h3><p>属于判别式模型，有很多正则化模型的方法（L0， L1，L2，etc），而且你不必像在用朴素贝叶斯那样担心你的特征是否相关。与决策树与SVM机相比，你还会得到一个不错的概率解释，你甚至可以轻松地利用新数据来更新模型（使用在线梯度下降算法，online gradient descent）。如果你需要一个概率架构（比如，简单地调节分类阈值，指明不确定性，或者是要获得置信区间），或者你希望以后将更多的训练数据快速整合到模型中去，那么使用它吧。</p>
<p><strong>Sigmoid函数</strong>：  </p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24f%28x%29%20%3D%20%5Cfrac%7B1%7D%7B1&plus;e%5E%7B-x%7D%7D%24%24" alt="$$f(x) = \frac{1}{1+e^{-x}}$$"></p>
<p><strong>优点：</strong>  </p>
<ul>
<li>实现简单，广泛的应用于工业问题上；</li>
<li>分类时计算量非常小，速度很快，存储资源低；</li>
<li>便利的观测样本概率分数；</li>
<li>对逻辑回归而言，多重共线性并不是问题，它可以结合L2正则化来解决该问题；</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>当特征空间很大时，逻辑回归的性能不是很好；</li>
<li>容易<strong>欠拟合</strong>，一般准确度不太高</li>
<li>不能很好地处理大量多类特征或变量；</li>
<li>只能处理两分类问题（在此基础上衍生出来的softmax可以用于多分类），且必须<strong>线性可分</strong>；</li>
<li>对于非线性特征，需要进行转换；</li>
</ul>
<hr>
<h3 id="3-线性回归"><strong>3.线性回归</strong></h3><p> 线性回归是用于回归的，而不像Logistic回归是用于分类，其基本思想是用<strong>梯度下降法</strong>对最小二乘法形式的误差函数进行优化，当然也可以用normal equation直接求得参数的解，结果为：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%20%5Chat%7Bw%7D%3D%28X%5E%7BT%7DX%29%5E%7B-1%7DX%5ETy%24%24" alt="$$ \hat{w}=(X^{T}X)^{-1}X^Ty$$"></p>
<p>而在LWLR（局部加权线性回归）中，参数的计算表达式为:</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%20%5Chat%7Bw%7D%3D%28X%5E%7BT%7DWX%29%5E%7B-1%7DX%5ETWy%24%24" alt="$$ \hat{w}=(X^{T}WX)^{-1}X^TWy$$"></p>
<p>由此可见LWLR与LR不同，LWLR是一个非参数模型，因为每次进行回归计算都要遍历训练样本至少一次。</p>
<p><strong>优点</strong>： 实现简单，计算简单；<br><strong>缺点</strong>： 不能拟合非线性数据.</p>
<hr>
<h3 id="4-最近领算法——KNN">4.最近领算法——KNN</h3><p>KNN即最近邻算法，其主要过程为：</p>
<pre><code><span class="bullet">1. </span>计算训练样本和测试样本中每个样本点的距离（常见的距离度量有欧式距离，马氏距离等）；
<span class="bullet">2. </span>对上面所有的距离值进行排序；
<span class="bullet">3. </span>选前k个最小距离的样本；
<span class="bullet">4. </span>根据这k个样本的标签进行投票，得到最后的分类类别；
</code></pre><p>如何选择一个最佳的K值，这取决于数据。一般情况下，在分类时较大的K值能够减小噪声的影响。但会使类别之间的界限变得模糊。一个较好的K值可通过各种启发式技术来获取，比如，交叉验证。另外噪声和非相关性特征向量的存在会使K近邻算法的准确性减小。</p>
<p>近邻算法具有较强的一致性结果。随着数据趋于无限，算法保证错误率不会超过贝叶斯算法错误率的两倍。对于一些好的K值，K近邻保证错误率不会超过贝叶斯理论误差率。</p>
<p><strong>KNN算法的优点</strong></p>
<ul>
<li>理论成熟，思想简单，既可以用来做分类也可以用来做回归；</li>
<li>可用于非线性分类；</li>
<li>训练时间复杂度为O(n)；</li>
<li>对数据没有假设，准确度高，对outlier不敏感；</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>计算量大；</li>
<li>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；</li>
<li>需要大量的内存；</li>
</ul>
<hr>
<h3 id="5-决策树">5.决策树</h3><p>易于解释。它可以毫无压力地处理特征间的交互关系并且是非参数化的，因此你不必担心异常值或者数据是否线性可分（举个例子，决策树能轻松处理好类别A在某个特征维度x的末端，类别B在中间，然后类别A又出现在特征维度x前端的情况）。它的缺点之一就是不支持在线学习，于是在新样本到来后，决策树需要全部重建。另一个缺点就是容易出现过拟合，但这也就是诸如随机森林RF（或提升树boosted tree）之类的集成方法的切入点。另外，随机森林经常是很多分类问题的赢家（通常比支持向量机好上那么一丁点），它训练快速并且可调，同时你无须担心要像支持向量机那样调一大堆参数，所以在以前都一直很受欢迎。</p>
<p>决策树中很重要的一点就是选择一个属性进行分枝，因此要注意一下信息增益的计算公式，并深入理解它。</p>
<p>信息熵的计算公式如下:</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24H%3D-%5Csum%5E%7Bn%7D_%7Bi%3D1%7Dp%28x_i%29log_2p%28x_i%29%24%24" alt="$$H=-\sum^{n}_{i=1}p(x_i)log_2p(x_i)$$"></p>
<p>其中的n代表有n个分类类别（比如假设是2类问题，那么n=2）。分别计算这2类样本在总样本中出现的概率p1和p2，这样就可以计算出未选中属性分枝前的信息熵。</p>
<p>现在选中一个属性$x_i$用来进行分枝，此时分枝规则是：如果$x_i=v$的话，将样本分到树的一个分支；如果不相等则进入另一个分支。很显然，分支中的样本很有可能包括2个类别，分别计算这2个分支的熵H1和H2,计算出分枝后的总信息熵H’ =p1 <em> H1+p2 </em> H2,则此时的信息增益ΔH = H - H’。以信息增益为原则，把所有的属性都测试一边，选择一个使增益最大的属性作为本次分枝属性。</p>
<p><strong>决策树自身的优点</strong></p>
<ul>
<li>计算简单，易于理解，可解释性强；</li>
<li>比较适合处理有缺失属性的样本；</li>
<li>能够处理不相关的特征；</li>
<li>在相对短的时间内能够对大型数据源做出可行且效果良好的结果。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>容易发生过拟合（随机森林可以很大程度上减少过拟合）；</li>
<li>忽略了数据之间的相关性；</li>
<li>对于那些各类别样本数量不一致的数据，在决策树当中,信息增益的结果偏向于那些具有更多数值的特征（只要是使用了信息增益，都有这个缺点，如RF）。</li>
</ul>
<h4 id="5-1_Adaboosting">5.1 Adaboosting</h4><p>Adaboost是一种加和模型，每个模型都是基于上一次模型的错误率来建立的，过分关注分错的样本，而对正确分类的样本减少关注度，逐次迭代之后，可以得到一个相对较好的模型。是一种典型的boosting算法。下面是总结下它的优缺点。</p>
<p><strong>优点</strong></p>
<ul>
<li>adaboost是一种有很高精度的分类器。</li>
<li>可以使用各种方法构建子分类器，Adaboost算法提供的是框架。</li>
<li>当使用简单分类器时，计算出的结果是可以理解的，并且弱分类器的构造极其简单。</li>
<li>简单，不用做特征筛选。</li>
<li>不容易发生overfitting。</li>
</ul>
<p>关于随机森林和GBDT等组合算法，参考这篇文章：<a href="http://www.csuldw.com/2015/07/22/2015-07-22%20%20ensemble/" target="_blank" rel="external">机器学习-组合算法总结</a></p>
<p><strong>缺点：</strong>对outlier比较敏感</p>
<hr>
<h3 id="6-SVM支持向量机">6.SVM支持向量机</h3><p>高准确率，为避免过拟合提供了很好的理论保证，而且就算数据在原特征空间线性不可分，只要给个合适的核函数，它就能运行得很好。在动辄超高维的文本分类问题中特别受欢迎。可惜内存消耗大，难以解释，运行和调参也有些烦人，而随机森林却刚好避开了这些缺点，比较实用。</p>
<p><strong>优点</strong></p>
<ul>
<li>可以解决高维问题，即大型特征空间；</li>
<li>能够处理非线性特征的相互作用；</li>
<li>无需依赖整个数据；</li>
<li>可以提高泛化能力；</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>当观测样本很多时，效率并不是很高；</li>
<li>对非线性问题没有通用解决方案，有时候很难找到一个合适的核函数；</li>
<li>对缺失数据敏感；</li>
</ul>
<p>对于核的选择也是有技巧的（libsvm中自带了四种核函数：线性核、多项式核、RBF以及sigmoid核）：</p>
<ul>
<li>第一，如果样本数量小于特征数，那么就没必要选择非线性核，简单的使用线性核就可以了；</li>
<li>第二，如果样本数量大于特征数目，这时可以使用非线性核，将样本映射到更高维度，一般可以得到更好的结果；</li>
<li>第三，如果样本数目和特征数目相等，该情况可以使用非线性核，原理和第二种一样。</li>
</ul>
<p>对于第一种情况，也可以先对数据进行降维，然后使用非线性核，这也是一种方法。</p>
<hr>
<h3 id="7-_人工神经网络的优缺点">7. 人工神经网络的优缺点</h3><p><strong>人工神经网络的优点：</strong></p>
<ul>
<li>分类的准确度高；</li>
<li>并行分布处理能力强,分布存储及学习能力强，</li>
<li>对噪声神经有较强的鲁棒性和容错能力，能充分逼近复杂的非线性关系；</li>
<li>具备联想记忆的功能。</li>
</ul>
<p><strong>人工神经网络的缺点：</strong></p>
<ul>
<li>神经网络需要大量的参数，如网络拓扑结构、权值和阈值的初始值；</li>
<li>不能观察之间的学习过程，输出结果难以解释，会影响到结果的可信度和可接受程度；</li>
<li>学习时间过长,甚至可能达不到学习的目的。</li>
</ul>
<hr>
<h3 id="8、K-Means聚类">　8、K-Means聚类</h3><p>之前写过一篇关于K-Means聚类的文章，博文链接：<a href="http://www.csuldw.com/2015/06/03/2015-06-03-ml-algorithm-K-means/" target="_blank" rel="external">机器学习算法-K-means聚类</a>。关于K-Means的推导，里面有着很强大的EM思想。</p>
<p><strong>优点</strong></p>
<ul>
<li>算法简单，容易实现 ；</li>
<li>对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是O(nkt)，其中n是所有对象的数目，k是簇的数目,t是迭代的次数。通常k&lt;&lt;n。这个算法通常局部收敛。</li>
<li>算法尝试找出使平方误差函数值最小的k个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>对数据类型要求较高，适合数值型数据；</li>
<li>可能收敛到局部最小值，在大规模数据上收敛较慢  </li>
<li>K值比较难以选取；</li>
<li>对初值的簇心值敏感，对于不同的初始值，可能会导致不同的聚类结果；</li>
<li>不适合于发现非凸面形状的簇，或者大小差别很大的簇。</li>
<li>对于”噪声”和孤立点数据敏感，少量的该类数据能够对平均值产生极大影响。</li>
</ul>
<h2 id="算法选择参考">算法选择参考</h2><p>之前翻译过一些国外的文章，有一篇文章中给出了一个简单的算法选择技巧：</p>
<ol>
<li>首当其冲应该选择的就是逻辑回归，如果它的效果不怎么样，那么可以将它的结果作为基准来参考，在基础上与其他算法进行比较；</li>
<li>然后试试决策树（随机森林）看看是否可以大幅度提升你的模型性能。即便最后你并没有把它当做为最终模型，你也可以使用随机森林来移除噪声变量，做特征选择；</li>
<li>如果特征的数量和观测样本特别多，那么当资源和时间充足时（这个前提很重要），使用SVM不失为一种选择。</li>
</ol>
<p>通常情况下：【GBDT&gt;=SVM&gt;=RF&gt;=Adaboost&gt;=Other…】，现在深度学习很热门，很多领域都用到，它是以神经网络为基础的，目前我自己也在学习，只是理论知识不是很厚实，理解的不够深，这里就不做介绍了。</p>
<p>算法固然重要，<strong>但好的数据却要优于好的算法</strong>，设计优良特征是大有裨益的。假如你有一个超大数据集，那么无论你使用哪种算法可能对分类性能都没太大影响（此时就可以根据速度和易用性来进行抉择）。</p>
<h2 id="参考文献">参考文献</h2><p>[1] <a href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff" target="_blank" rel="external">https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff</a><br>[2] <a href="http://blog.echen.me/2011/04/27/choosing-a-machine-learning-classifier/" target="_blank" rel="external">http://blog.echen.me/2011/04/27/choosing-a-machine-learning-classifier/</a><br>[3] <a href="http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/" target="_blank" rel="external">http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/">http://www.csuldw.com/2016/02/26/2016-02-26-choosing-a-machine-learning-classifier/</a></p>
<p>本文主要回顾下几个常用算法的适应场景及其优缺点！（提示：部分内容摘自网络）。</p>]]>
    
    </summary>
    
      <category term="LR" scheme="http://csuldw.github.io/tags/LR/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="偏差" scheme="http://csuldw.github.io/tags/%E5%81%8F%E5%B7%AE/"/>
    
      <category term="方差" scheme="http://csuldw.github.io/tags/%E6%96%B9%E5%B7%AE/"/>
    
      <category term="算法选择" scheme="http://csuldw.github.io/tags/%E7%AE%97%E6%B3%95%E9%80%89%E6%8B%A9/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习数据集-MNIST]]></title>
    <link href="http://csuldw.github.io/2016/02/25/2016-02-25-machine-learning-MNIST-dataset/"/>
    <id>http://csuldw.github.io/2016/02/25/2016-02-25-machine-learning-MNIST-dataset/</id>
    <published>2016-02-25T09:24:00.000Z</published>
    <updated>2016-03-08T09:03:30.616Z</updated>
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>在学习机器学习的时候，首当其冲的就是准备一份通用的数据集，方便与其他的算法进行比较。在这里，我写了一个用于加载MNIST数据集的方法，并将其进行封装，主要用于将MNIST数据集转换成numpy.array()格式的训练数据。直接下面看下面的代码吧(主要还是如何用python去读取binnary file)！</p>
<a id="more"></a>
<p>MNIST数据集原网址：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="external">http://yann.lecun.com/exdb/mnist/</a></p>
<p>Github源码下载：<a href="https://github.com/csuldw/MachineLearning/tree/master/dataset/MNIST" target="_blank" rel="external">数据集（源文件+解压文件+字体图像jpg格式）</a>， <a href="https://github.com/csuldw/MachineLearning/tree/master/utils/" target="_blank" rel="external">py源码文件</a></p>
<h2 id="文件目录">文件目录</h2><ul>
<li><a href="https://github.com/csuldw/MachineLearning/tree/master/utils/data_util.py" target="_blank" rel="external">/utils/data_util.py</a> 用于加载MNIST数据集方法文件</li>
<li><a href="https://github.com/csuldw/MachineLearning/tree/master/utils/test.py" target="_blank" rel="external">/utils/test.py</a> 用于测试的文件，一个简单的KNN测试MNIST数据集</li>
<li><a href="https://github.com/csuldw/MachineLearning/tree/master/dataset/MNIST" target="_blank" rel="external">/data/train-images.idx3-ubyte</a> 训练集X</li>
<li><a href="https://github.com/csuldw/MachineLearning/tree/master/dataset/MNIST" target="_blank" rel="external">/dataset/train-labels.idx1-ubyte</a> 训练集y</li>
<li><a href="https://github.com/csuldw/MachineLearning/tree/master/dataset/MNIST" target="_blank" rel="external">/dataset/data/t10k-images.idx3-ubyte</a> 测试集X</li>
<li><a href="https://github.com/csuldw/MachineLearning/tree/master/dataset/MNIST" target="_blank" rel="external">/dataset/data/t10k-labels.idx1-ubyte</a> 测试集y</li>
</ul>
<h2 id="MNIST数据集解释">MNIST数据集解释</h2><p>将MNIST文件解压后，发现这些文件并不是标准的图像格式。这些图像数据都保存在二进制文件中。每个样本图像的宽高为28*28。</p>
<p>mnist的结构如下，选取train-images</p>
<pre><code>TRAINING <span class="operator"><span class="keyword">SET</span> IMAGE FILE (train-images-idx3-ubyte):

[offset] [type]          [<span class="keyword">value</span>]          [description] 
<span class="number">0000</span>     <span class="number">32</span> <span class="built_in">bit</span> <span class="built_in">integer</span>  <span class="number">0x00000803</span>(<span class="number">2051</span>) magic <span class="built_in">number</span> 
<span class="number">0004</span>     <span class="number">32</span> <span class="built_in">bit</span> <span class="built_in">integer</span>  <span class="number">60000</span>            <span class="built_in">number</span> <span class="keyword">of</span> images 
<span class="number">0008</span>     <span class="number">32</span> <span class="built_in">bit</span> <span class="built_in">integer</span>  <span class="number">28</span>               <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">rows</span> 
<span class="number">0012</span>     <span class="number">32</span> <span class="built_in">bit</span> <span class="built_in">integer</span>  <span class="number">28</span>               <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">columns</span> 
<span class="number">0016</span>     unsigned byte   ??               pixel 
<span class="number">0017</span>     unsigned byte   ??               pixel 
........ 
xxxx     unsigned byte   ??               pixel</span>
</code></pre><p>首先该数据是以二进制存储的，我们读取的时候要以’rb’方式读取；其次，真正的数据只有[value]这一项，其他的[type]等只是来描述的，并不真正在数据文件里面。也就是说，在读取真实数据之前，我们要读取4个<code>32 bit integer</code>.由[offset]我们可以看出真正的pixel是从0016开始的，一个int 32位，所以在读取pixel之前我们要读取4个 32 bit integer，也就是magic number, number of images, number of rows, number of columns. 当然，在这里使用struct.unpack_from()会比较方便.</p>
<h2 id="源码">源码</h2><p>说明：</p>
<ul>
<li>‘&gt;IIII’指的是使用大端法读取4个unsinged int 32 bit integer</li>
<li>‘&gt;784B’指的是使用大端法读取784个unsigned byte</li>
</ul>
<p>data_util.py文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Thu Feb 25 14:40:06 2016</span><br><span class="line">load MNIST dataset</span><br><span class="line">@author: liudiwei</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataUtils</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""MNIST数据集加载</span><br><span class="line">    输出格式为：numpy.array()    </span><br><span class="line">    </span><br><span class="line">    使用方法如下</span><br><span class="line">    from data_util import DataUtils</span><br><span class="line">    def main():</span><br><span class="line">        trainfile_X = '../dataset/MNIST/train-images.idx3-ubyte'</span><br><span class="line">        trainfile_y = '../dataset/MNIST/train-labels.idx1-ubyte'</span><br><span class="line">        testfile_X = '../dataset/MNIST/t10k-images.idx3-ubyte'</span><br><span class="line">        testfile_y = '../dataset/MNIST/t10k-labels.idx1-ubyte'</span><br><span class="line">        </span><br><span class="line">        train_X = DataUtils(filename=trainfile_X).getImage()</span><br><span class="line">        train_y = DataUtils(filename=trainfile_y).getLabel()</span><br><span class="line">        test_X = DataUtils(testfile_X).getImage()</span><br><span class="line">        test_y = DataUtils(testfile_y).getLabel()</span><br><span class="line">        </span><br><span class="line">        #以下内容是将图像保存到本地文件中</span><br><span class="line">        #path_trainset = "../dataset/MNIST/imgs_train"</span><br><span class="line">        #path_testset = "../dataset/MNIST/imgs_test"</span><br><span class="line">        #if not os.path.exists(path_trainset):</span><br><span class="line">        #    os.mkdir(path_trainset)</span><br><span class="line">        #if not os.path.exists(path_testset):</span><br><span class="line">        #    os.mkdir(path_testset)</span><br><span class="line">        #DataUtils(outpath=path_trainset).outImg(train_X, train_y)</span><br><span class="line">        #DataUtils(outpath=path_testset).outImg(test_X, test_y)</span><br><span class="line">    </span><br><span class="line">        return train_X, train_y, test_X, test_y </span><br><span class="line">    """</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename=None, outpath=None)</span>:</span></span><br><span class="line">        self._filename = filename</span><br><span class="line">        self._outpath = outpath</span><br><span class="line">        </span><br><span class="line">        self._tag = <span class="string">'&gt;'</span></span><br><span class="line">        self._twoBytes = <span class="string">'II'</span></span><br><span class="line">        self._fourBytes = <span class="string">'IIII'</span>    </span><br><span class="line">        self._pictureBytes = <span class="string">'784B'</span></span><br><span class="line">        self._labelByte = <span class="string">'1B'</span></span><br><span class="line">        self._twoBytes2 = self._tag + self._twoBytes</span><br><span class="line">        self._fourBytes2 = self._tag + self._fourBytes</span><br><span class="line">        self._pictureBytes2 = self._tag + self._pictureBytes</span><br><span class="line">        self._labelByte2 = self._tag + self._labelByte</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getImage</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        将MNIST的二进制文件转换成像素特征数据</span><br><span class="line">        """</span></span><br><span class="line">        binfile = open(self._filename, <span class="string">'rb'</span>) <span class="comment">#以二进制方式打开文件</span></span><br><span class="line">        buf = binfile.read() </span><br><span class="line">        binfile.close()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        numMagic,numImgs,numRows,numCols=struct.unpack_from(self._fourBytes2,\</span><br><span class="line">                                                                    buf,\</span><br><span class="line">                                                                    index)</span><br><span class="line">        index += struct.calcsize(self._fourBytes)</span><br><span class="line">        images = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numImgs):</span><br><span class="line">            imgVal = struct.unpack_from(self._pictureBytes2, buf, index)</span><br><span class="line">            index += struct.calcsize(self._pictureBytes2)</span><br><span class="line">            imgVal = list(imgVal)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(imgVal)):</span><br><span class="line">                <span class="keyword">if</span> imgVal[j] &gt; <span class="number">1</span>:</span><br><span class="line">                    imgVal[j] = <span class="number">1</span></span><br><span class="line">            images.append(imgVal)</span><br><span class="line">        <span class="keyword">return</span> np.array(images)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLabel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        将MNIST中label二进制文件转换成对应的label数字特征</span><br><span class="line">        """</span></span><br><span class="line">        binFile = open(self._filename,<span class="string">'rb'</span>)</span><br><span class="line">        buf = binFile.read()</span><br><span class="line">        binFile.close()</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        magic, numItems= struct.unpack_from(self._twoBytes2, buf,index)</span><br><span class="line">        index += struct.calcsize(self._twoBytes2)</span><br><span class="line">        labels = [];</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(numItems):</span><br><span class="line">            im = struct.unpack_from(self._labelByte2,buf,index)</span><br><span class="line">            index += struct.calcsize(self._labelByte2)</span><br><span class="line">            labels.append(im[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> np.array(labels)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outImg</span><span class="params">(self, arrX, arrY)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        根据生成的特征和数字标号，输出png的图像</span><br><span class="line">        """</span></span><br><span class="line">        m, n = np.shape(arrX)</span><br><span class="line">        <span class="comment">#每张图是28*28=784Byte</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>):</span><br><span class="line">            img = np.array(arrX[i])</span><br><span class="line">            img = img.reshape(<span class="number">28</span>,<span class="number">28</span>)</span><br><span class="line">            outfile = str(i) + <span class="string">"_"</span> +  str(arrY[i]) + <span class="string">".png"</span></span><br><span class="line">            plt.figure()</span><br><span class="line">            plt.imshow(img, cmap = <span class="string">'binary'</span>) <span class="comment">#将图像黑白显示</span></span><br><span class="line">            plt.savefig(self._outpath + <span class="string">"/"</span> + outfile)</span><br></pre></td></tr></table></figure>
<p>test.py文件:简单地测试了一下KNN算法，代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Thu Feb 25 16:09:58 2016</span><br><span class="line">Test MNIST dataset </span><br><span class="line">@author: liudiwei</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors  </span><br><span class="line"><span class="keyword">from</span> data_util <span class="keyword">import</span> DataUtils</span><br><span class="line"><span class="keyword">import</span> datetime  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    trainfile_X = <span class="string">'../dataset/MNIST/train-images.idx3-ubyte'</span></span><br><span class="line">    trainfile_y = <span class="string">'../dataset/MNIST/train-labels.idx1-ubyte'</span></span><br><span class="line">    testfile_X = <span class="string">'../dataset/MNIST/t10k-images.idx3-ubyte'</span></span><br><span class="line">    testfile_y = <span class="string">'../dataset/MNIST/t10k-labels.idx1-ubyte'</span></span><br><span class="line">    train_X = DataUtils(filename=trainfile_X).getImage()</span><br><span class="line">    train_y = DataUtils(filename=trainfile_y).getLabel()</span><br><span class="line">    test_X = DataUtils(testfile_X).getImage()</span><br><span class="line">    test_y = DataUtils(testfile_y).getLabel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> train_X, train_y, test_X, test_y </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testKNN</span><span class="params">()</span>:</span></span><br><span class="line">    train_X, train_y, test_X, test_y = main()</span><br><span class="line">    startTime = datetime.datetime.now()</span><br><span class="line">    knn = neighbors.KNeighborsClassifier(n_neighbors=<span class="number">3</span>)  </span><br><span class="line">    knn.fit(train_X, train_y)  </span><br><span class="line">    match = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(test_y)):  </span><br><span class="line">        predictLabel = knn.predict(test_X[i])[<span class="number">0</span>]  </span><br><span class="line">        <span class="keyword">if</span>(predictLabel==test_y[i]):  </span><br><span class="line">            match += <span class="number">1</span>  </span><br><span class="line">      </span><br><span class="line">    endTime = datetime.datetime.now()  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'use time: '</span>+str(endTime-startTime)  </span><br><span class="line">    <span class="keyword">print</span> <span class="string">'error rate: '</span>+ str(<span class="number">1</span>-(match*<span class="number">1.0</span>/len(test_y)))  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    testKNN()</span><br></pre></td></tr></table></figure>
<p>通过main方法，最后直接返回numpy.array()格式的数据：train_X, train_y, test_X, test_y。如果你需要，直接条用main方法即可！</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="介绍">介绍</h2><p>在学习机器学习的时候，首当其冲的就是准备一份通用的数据集，方便与其他的算法进行比较。在这里，我写了一个用于加载MNIST数据集的方法，并将其进行封装，主要用于将MNIST数据集转换成numpy.array()格式的训练数据。直接下面看下面的代码吧(主要还是如何用python去读取binnary file)！</p>]]>
    
    </summary>
    
      <category term="MNIST" scheme="http://csuldw.github.io/tags/MNIST/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="dataset" scheme="http://csuldw.github.io/tags/dataset/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python编码规范]]></title>
    <link href="http://csuldw.github.io/2016/02/23/2016-02-23-Python-coding-standards/"/>
    <id>http://csuldw.github.io/2016/02/23/2016-02-23-Python-coding-standards/</id>
    <published>2016-02-23T12:37:00.000Z</published>
    <updated>2016-03-08T09:05:20.130Z</updated>
    <content type="html"><![CDATA[<p>此文是我们自己编写Python代码时使用的编码规范，方便整合！</p>
<h2 id="常量">常量</h2><p>常量名所有字母大写，由下划线连接各个单词，如：</p>
<a id="more"></a>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER_CO<span class="built_in">NSTANT</span></span><br></pre></td></tr></table></figure>
<h2 id="变量">变量</h2><p>变量名全部小写，由下划线连接各个单词，如：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">color = WHITE</span><br><span class="line"><span class="keyword">this</span><span class="number">_</span><span class="keyword">is</span><span class="number">_</span>a<span class="number">_</span><span class="annotation">variable</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="函数和方法">函数和方法</h2><ul>
<li>私有方法：小写和一个前导下划线</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_secrete</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"don't test me."</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数参数：小写和下划线，缺省值等号两边无空格</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, user=None)</span>:</span></span><br><span class="line">    self._user = user</span><br></pre></td></tr></table></figure>
<h2 id="类">类</h2><ul>
<li>类总是使用驼峰格式命名，不使用下划线连接单词，也不加入 C、T 等前缀，即所有单词首字母大写其余字母小写。类名应该简明，精确，并足以从中理解类所完成的工作。常见的一个方法是使用表示其类型或者特性的后缀，例如:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLEngine</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于基类而言，可以使用一个 Base 或者 Abstract 前缀</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseCookie</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractGroup</span><span class="params">(object)</span>:</span></span><br><span class="line">    psss</span><br></pre></td></tr></table></figure>
<h2 id="特定命名方式">特定命名方式</h2><p>主要是指 __xxx__ 形式的系统保留字命名法。项目中也可以使用这种命名，它的意义在于这种形式的变量是只读的，这种形式的类成员函数尽量不要重载。如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, parent = None)</span>:</span></span><br><span class="line">        self.__id__ = id</span><br><span class="line">        self.__parent__ = parent</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__message__</span><span class="params">(self, msgid)</span>:</span></span><br><span class="line">        <span class="comment"># ...略</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>_id</code>、<code>parent_</code> 和 <code>_message_</code>都采用了系统保留字命名法。</p>
<h2 id="空格">空格</h2><ol>
<li>在二元算术、逻辑运算符前后加空格：如 <code>a = b + c</code>；</li>
</ol>
<ul>
<li>在一元前缀运算符后不加空格，如 <code>if !flg: pass</code>；</li>
<li>“:”用在行尾时前后皆不加空格，如分支、循环、函数和类定义语言；用在非行尾时后端加空格，如 <code>dict</code> 对象的定义 <code>d = {&#39;key&#39;: &#39;value&#39;}</code>;</li>
<li>括号（含圆括号、方括号和花括号）前后不加空格，如 <code>do_something(arg1, arg2)</code>, 而不是 <code>do_something( arg1, arg2 )</code>；</li>
<li>逗号后面加一个空格，前面不加空格。</li>
</ul>
<h2 id="空行">空行</h2><ol>
<li>在类、函数的定义间加空行；</li>
</ol>
<ul>
<li>在import不同种类的模块间加空行；</li>
<li>在函数中的逻辑段落间加空行，即把相关的代码紧凑写在一起，作为一个逻辑段落，段落间以空行分隔。</li>
</ul>
<h2 id="断行">断行</h2><p>（1）行的最大长度不得超过 80 个字符的标准。折叠长行的方法有以下几种方法：<br>1）为长变量名换一个短名，如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this<span class="class">.is</span><span class="class">.a</span><span class="class">.very</span><span class="class">.long</span><span class="class">.variable_name</span> = this<span class="class">.is</span><span class="class">.another</span><span class="class">.long</span><span class="class">.variable_name</span></span><br></pre></td></tr></table></figure>
<p>应改为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable_name1 = this.<span class="keyword">is</span>.a.very.long.variable_name</span><br><span class="line">variable_name2 = this.<span class="keyword">is</span>.another.variable_name</span><br><span class="line">variable_name1 = variable_name2</span><br></pre></td></tr></table></figure>
<p>（2）在括号（包括圆括号、方括号和花括号）内换行，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edit</span><span class="params">(CBase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent, width,</span><br><span class="line">                font = FONT, color = BLACK, pos = POS, style = <span class="number">0</span>)</span>:</span></span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">very_very_very_long_variable_name = Edit(parent, \</span><br><span class="line">                                         width, \</span><br><span class="line">                                         font, \</span><br><span class="line">                                         color, \</span><br><span class="line">                                         pos)</span><br></pre></td></tr></table></figure>
<p>（3）在长行加入续行符强行断行，断行的位置应在操作符前，且换行后多一个缩进，以使维护人员看代码的时候看到代码行首即可判定这里存在换行，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> color == WHITE <span class="keyword">or</span> color == BLACK \</span><br><span class="line">              <span class="keyword">or</span> color == BLUE:</span><br><span class="line">    do_something(color);</span><br></pre></td></tr></table></figure>
<h2 id="语句">语句</h2><ul>
<li>import</li>
</ul>
<p>import 语句有以下几个原则需要遵守：</p>
<p>（1）import 的次序，先<code>import Python</code>内置模块，再import第三方模块，最后import自己开发的项目中的其它模块；这几种模块中用空行分隔开来。</p>
<p>（2）一条import语句import一个模块。</p>
<p>（3）当从模块中 import 多个对象且超过一行时，使用如下断行法（此语法 py2.5 以上版本才支持）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module <span class="keyword">import</span> (obj1, obj2, obj3, obj4,</span><br><span class="line">obj5, obj6)</span><br></pre></td></tr></table></figure>
<p>4）不要使用 <code>from module import *</code>，除非是 <code>import</code>常量定义模块或其它你确保不会出现命名空间冲突的模块。</p>
<h2 id="赋值">赋值</h2><p>对于赋值语言，等号前后空一格，格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">variable = <span class="number">2</span></span><br><span class="line">fn = callback_function</span><br></pre></td></tr></table></figure>
<h2 id="分支和循环">分支和循环</h2><p>不要写成一行，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !flg: <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>): <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<p>应该写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !flg:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2><ul>
<li>使用 has 或 is 前缀命名布尔元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_connect = <span class="keyword">True</span></span><br><span class="line">has_member = <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用复数形式命名序列</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">members = [<span class="string">'user_1'</span>, <span class="string">'user_2'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>用显式名称命名字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person_address = &#123;<span class="string">'user_1'</span>:<span class="string">'10 road WD'</span>, <span class="string">'user_2'</span> : <span class="string">'20 street huafu'</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免通用名称</li>
</ul>
<p>诸如 list, dict, sequence 或者 element 这样的名称应该避免。</p>
<ul>
<li>一些数字</li>
</ul>
<p>一行列数 : PEP 8 规定为 79 列，这有些苛刻了。根据自己的情况，比如不要超过满屏时编辑器的显示列数。这样就可以在不动水平游标的情况下，方便的查看代码。</p>
<p>一个函数 : 不要超过 30 行代码, 即可显示在一个屏幕类，可以不使用垂直游标即可看到整个函数。</p>
<p>一个类 : 不要超过 200 行代码，不要有超过 10 个方法。</p>
<p>一个模块 不要超过 500 行。</p>
<h2 id="Contributor">Contributor</h2><ul>
<li>Liu Diwei: <a href="https://github.com/csuldw" target="_blank" rel="external">https://github.com/csuldw</a></li>
<li>Gao Yong: <a href="https://github.com/gaoyongcn" target="_blank" rel="external">https://github.com/gaoyongcn</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>此文是我们自己编写Python代码时使用的编码规范，方便整合！</p>
<h2 id="常量">常量</h2><p>常量名所有字母大写，由下划线连接各个单词，如：</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="编码规范" scheme="http://csuldw.github.io/tags/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python笔记小记]]></title>
    <link href="http://csuldw.github.io/2016/01/22/2016-01-21-Python-notes/"/>
    <id>http://csuldw.github.io/2016/01/22/2016-01-21-Python-notes/</id>
    <published>2016-01-22T02:24:00.000Z</published>
    <updated>2016-03-23T07:12:23.869Z</updated>
    <content type="html"><![CDATA[<p>本文主要记录在学习过程中碰到的易混淆的Python语法。</p>
<h3 id="shape函数">shape函数</h3><p>python中的shape有两个，一个是numpy中的shape，一个是array的shape，本质上是一样的。</p>
<a id="more"></a>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line"><span class="variable">y=</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]  <span class="comment"># list</span></span><br><span class="line"><span class="variable">y_arr =</span> array(y)         <span class="comment">#array</span></span><br><span class="line"><span class="variable">y_mat =</span> np.mat(y_arr)  <span class="comment">#matrix</span></span><br><span class="line">y_arr.shape[<span class="number">0</span>]   <span class="comment">#output:10L</span></span><br><span class="line">y_mat.shape[<span class="number">0</span>]   <span class="comment">#output:1L</span></span><br><span class="line">y_mat.shape[<span class="number">1</span>]   <span class="comment">#output:10L</span></span><br><span class="line">np.shape(y_arr)  <span class="comment">#output :(1L, 10L)</span></span><br></pre></td></tr></table></figure>
<h3 id="extend和append">extend和append</h3><p>对于python中的list，假设有a=[1,2,3], b=[4,5,4]，如果使用a.append(b),结果为：</p>
<pre><code>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]]
</code></pre><p>如果使用a.extend(b),结果为：</p>
<pre><code>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>]
</code></pre><h3 id="numpy中的tile函数">numpy中的tile函数</h3><p>看下面几个列子就懂了</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line">x = np.array<span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span><br><span class="line">x1 = np.tile<span class="params">(x,<span class="number">1</span>)</span>   <span class="built_in">#</span> array<span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span><br><span class="line">x2 = np.tile<span class="params">(x,<span class="number">2</span>)</span>   <span class="built_in">#</span> array<span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span><br><span class="line">x3 = np.tile<span class="params">(x,<span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span>)</span>   <span class="built_in">#</span> array<span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span><br><span class="line">x4 = np.tile<span class="params">(x,<span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span>)</span>   <span class="built_in">#</span> array<span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span><br><span class="line">x5 = np.tile<span class="params">(x,<span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span>)</span>   <span class="built_in">#</span> array<span class="params">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span><br></pre></td></tr></table></figure>
<p>其实就相当于在tile的第二个参数中指定维数，将第一个变量的值整块填写到里面即可。</p>
<h3 id="numpy中的sum函数axis=1">numpy中的sum函数axis=1</h3><p>对于sum看起来挺简单的样子，但是在给sum函数中加入参数。<code>sum(a, axis=0)</code>或者是<code>.sum(axis=1)</code>就有点不解了。在我实验以后发现,我们平时用的<code>sum</code>应该是默认的<code>axis=0</code>就是普通的相加。当加入<code>axis=1</code>以后就是将一个矩阵的每一行向量相加：</p>
<p>例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">x = np.<span class="function"><span class="title">array</span><span class="params">([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]])</span></span></span><br><span class="line">np.<span class="function"><span class="title">sum</span><span class="params">(x, axis=<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>返回的结果就是：array（[3,6]）</p>
<p><code>np.sum(x, axis=1)</code>等价于<code>x.sum(axis=1)</code>，注意：python中list没有sum属性【’list’ object has no attribute ‘sum’】。</p>
<p>如果使用的是<code>x.sum(axis=0)</code>，则返回的结果是：array([2, 2, 5])</p>
<p>它是对x的每一进行列求和运算。</p>
<h3 id="dict中的get()方法">dict中的get()方法</h3><p>get()方法返回给定键的值。如果键不可用，则返回默认值None。</p>
<p>语法<br>以下是get()方法的语法：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="built_in">get</span>(<span class="variable">key</span>, <span class="keyword">default</span>=None)</span><br></pre></td></tr></table></figure>
<p>参数:</p>
<ul>
<li>key: 这是要搜索在字典中的键。</li>
<li>default: 这是要返回键不存在的的情况下默认值。</li>
<li>返回值: 该方法返回一个给定键的值。如果键不可用，则返回默认值为None。</li>
</ul>
<h3 id="operator的itemgetter()">operator的itemgetter()</h3><p>operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号（即需要获取的数据在对象中的序号）.</p>
<p>例如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">b=operator.<span class="function"><span class="title">itemgetter</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">b</span><span class="params">(a)</span></span>   #输出<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>要注意，operator.itemgetter函数获取的不是值，而是定义了一个函数，通过该函数作用到对象上才能获取值。</p>
<p>Python内置的排序函数sorted可以对list或者iterator进行排序</p>
<p>sorted(iterable[, cmp[, key[, reverse]]])</p>
<p>第一个参数是一个iterable，返回值是一个对iterable中元素进行排序后的列表(list)。</p>
<p>可选的参数有三个，cmp、key和reverse。<br>1)cmp指定一个定制的比较函数，这个函数接收两个参数（iterable的元素），如果第一个参数小于第二个参数，返回一个负数；如果第一个参数等于第二个参数，返回零；如果第一个参数大于第二个参数，返回一个正数。默认值为None。<br>2)key指定一个接收一个参数的函数，这个函数用于从每个元素中提取一个用于比较的关键字。默认值为None。<br>3)reverse是一个布尔值。如果设置为True，列表元素将被倒序排列。<br>通常来说，key和reverse比一个等价的cmp函数处理速度要快。这是因为对于每个列表元素，cmp都会被调用多次，而key和reverse只被调用一次。</p>
<p>比如下面一个例子：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">b </span>= &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">5</span>&#125;</span><br><span class="line"><span class="label">sorted</span>(<span class="keyword">b.iteritems(), </span>key<span class="label">=operator</span>.<span class="keyword">itemgetter(1), </span><span class="keyword">reverse=True) </span>  #表示按照第二维进行降序</span><br></pre></td></tr></table></figure>
<p>输出：[(1, 5), (0, 1)]</p>
<h3 id="步进切片">步进切片</h3><p>使用步进切片可以轻松实现sequence（list, tuple, string）反转</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt;name = <span class="string">'AlphaGO'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;name[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>]</span><br><span class="line"><span class="constant">Out</span>[<span class="number">121</span>]<span class="symbol">:</span> <span class="string">'OGahplA'</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;name = [<span class="string">"A"</span>, <span class="string">"is"</span>,  <span class="string">"C"</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;name[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>]</span><br><span class="line"><span class="constant">Out</span>[<span class="number">125</span>]<span class="symbol">:</span> [<span class="string">'C'</span>, <span class="string">'is'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要记录在学习过程中碰到的易混淆的Python语法。</p>
<h3 id="shape函数">shape函数</h3><p>python中的shape有两个，一个是numpy中的shape，一个是array的shape，本质上是一样的。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习-牛顿方法&指数分布族&GLM]]></title>
    <link href="http://csuldw.github.io/2016/01/12/2016-01-12-Newton-Method/"/>
    <id>http://csuldw.github.io/2016/01/12/2016-01-12-Newton-Method/</id>
    <published>2016-01-12T02:24:00.000Z</published>
    <updated>2016-03-14T13:43:20.336Z</updated>
    <content type="html"><![CDATA[<font color="green">回头再温习一下Andrew Ng的机器学习视频课，顺便把没写完的笔记写完。</font>

<p>本节内容</p>
<ul>
<li>牛顿方法</li>
<li>指数分布族</li>
<li>广义线性模型</li>
</ul>
<a id="more"></a>
<p>之前学习了梯度下降方法，关于梯度下降（gradient descent），这里简单的回顾下【参考感知机学习部分提到的梯度下降(<a href="http://blog.csdn.net/dream_angel_z/article/details/48915561" target="_blank" rel="external">gradient descent</a>)】。在最小化损失函数时，采用的就是梯度下降的方法逐步逼近最优解，规则为$\theta := \theta - \eta \nabla_{\theta} \ell(\theta)$。其实梯度下降属于一种优化方法，但梯度下降找到的是局部最优解。如下图：</p>
<center><br><img src="http://img.blog.csdn.net/20151006094200515" alt="这里写图片描述"><br></center>


<p>本节首先讲解的是牛顿方法（NewTon’s Method）。牛顿方法也是一种优化方法，它考虑的是<strong>全局最优</strong>。接着还会讲到指数分布族和广义线性模型。下面来详细介绍。</p>
<h2 id="1-牛顿方法"><strong>1.牛顿方法</strong></h2><p>现在介绍另一种最小化损失函数$\ell(\theta)$的方法——牛顿方法,参考<a href="http://www.phengkimving.com/calc_of_one_real_var/08_app_of_the_der_part_2/08_05_approx_of_roots_of_func_newtons_meth.htm" target="_blank" rel="external">Approximations Of Roots Of Functions – Newton’s Method</a><br>。它与梯度下降不同，其基本思想如下：</p>
<p>假设一个函数$f(x) = 0$,我们需要求解此时的$x$值。如下图所示：</p>
<center><br><img src="http://img.blog.csdn.net/20151006095845371" alt="这里写图片描述"><br>图1 $f(x0) = 0, a1, a2, a3, … 逐步接近 x0$.<br></center>

<p>在<br>$a_1$点的时候，$f(x)$切线的目标函数$y = f(a_1) + f ‘(a_1)(x – a_1)$. 由于$(a_2,0)$在这条线上，所以我们有$ 0 = f(a_1) + f ‘(a_1)(a_2 – a_1)$,so:</p>
<p>$$a_2 = a_1-\frac{f(a_1)}{f’(a_1)}$$</p>
<p>同理，在$a_2$点的时候，切线的目标函数$y = f(a_2) + f ‘(a_2)(x – a_2)$. 由于$(a_3,0)$在这条线上，所以我们有$ 0 = f(a_2) + f ‘(a_2)(a_3– a_2)$,so:</p>
<p>$$a_3 = a_2-\frac{f(a_2)}{f’(a_2)}$$</p>
<p>假设在第$n$次迭代，有$f(a_n)=0$,那么此时有下面这个递推公式：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24a_n%20%3D%20a_%7Bn-1%7D-%5Cfrac%7Bf%28a_%7Bn-1%7D%29%7D%7Bf%27%28a_%7Bn-1%7D%29%7D%24%24" alt=""></p>
<p>其中$n&gt;=2$.</p>
<p>最后得到的公式也就是牛顿方法的学习规则，为了和梯度下降对比，我们来替换一下变量，公式如下：</p>
<p>$$\theta := \theta - \frac{f(\theta)}{f’(\theta)}$$</p>
<font color="green"><strong>那么问题来了，怎么将牛顿方法应用到我们的问题上，最小化损失函数$\ell(\theta)$(或者是求极大似然估计的极大值)呢？</strong><br></font>

<p>  对于机器学习问题，现在我们优化的目标函数为极大似然估计$\ell$，当极大似然估计函数取值最大时，其导数为 0，这样就和上面函数f取 0 的问题一致了，令$f(\theta) = \ell’(\theta)$。极大似然函数的求解更新规则是：</p>
<p>$$\theta := \theta - \frac{\ell’(\theta)}{\ell’’(\theta)}$$</p>
<p>对于$\ell$，当一阶导数为零时，有极值；此时，如果二阶导数大于零，则$\ell$有极小值，如果二阶导数小于零，则有极大值。</p>
<p>上面的式子是当参数$\theta$为实数时的情况，下面我们要求出一般式。当参数为向量时，更新规则变为如下公式：</p>
<p>$$\theta := \theta - H^{-1} \nabla_{\theta}\ell(\theta)$$</p>
<p>其中$\nabla$后半部分$和之前梯度下降中提到的一样，是梯度，$H$是一个$n*n$的矩阵，$H $是函数的二次导数矩阵，被成为$Hessian$矩阵。其某个元素$ H_{ij}$ 计算公式如下：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24H_%7Bij%7D%3D%5Cdfrac%7B%5Cpartial%5E%7B2%7D%5Cell%28%5Ctheta%29%7D%7B%5Cpartial%5Ctheta_%7Bi%7D%5Ctheta_%7Bj%7D%7D%24%24" alt="$$H_{ij}=\dfrac{\partial^{2}\ell(\theta)}{\partial\theta_{i}\theta_{j}}$$"></p>
<font color="red"><strong>和梯度下降相比，牛顿方法的收敛速度更快，通常只要十几次或者更少就可以收敛，牛顿方法也被称为二次收敛（quadratic convergence），因为当迭代到距离收敛值比较近的时候，每次迭代都能使误差变为原来的平方。缺点是当参数向量较大的时候，每次迭代都需要计算一次 Hessian 矩阵的逆，比较耗时。</strong><br></font>

<h2 id="2-指数分布族（The_exponential_family）"><strong>2.指数分布族（The exponential family）</strong></h2><p>指数分布族是指可以表示为指数形式的概率分布。指数分布的形式如下：</p>
<p>$$P(y;\eta)=b(y)exp(\eta^{T}T(y)-a(\eta))$$</p>
<p>其中，η成为分布的<strong>自然参数</strong>（nature parameter）；T(y)是<strong>充分统计量</strong>（sufficient statistic），通常 <strong>T(y)=y</strong>。当参数 a、b、T 都固定的时候，就定义了一个以η为参数的函数族。</p>
<p>下面介绍两种分布，伯努利分布和高斯分布，分别把它们表示成指数分布族的形式。</p>
<h3 id="伯努利分布"><strong>伯努利分布</strong></h3><p>伯努利分布是对0，1问题进行建模的，对于Bernoulli（$\varphi$）,$y\epsilon{0, 1}$.有$p(y=1; \varphi ) = \varphi; p(y=0; \varphi ) = 1- \varphi$，下面将其推导成指数分布族形式：</p>
<center><br><img src="http://img.blog.csdn.net/20151006105233062" alt="这里写图片描述"><br></center>

<p>将其与指数族分布形式对比，可以看出：</p>
<center><br><img src="http://img.blog.csdn.net/20151006105357353" alt="这里写图片描述"><br></center>

<p>表明伯努利分布也是指数分布族的一种。从上述式子可以看到，$\eta$的形式与logistic函数（sigmoid）一致，这是因为 logistic模型对问题的前置概率估计其实就是伯努利分布。</p>
<h3 id="高斯分布"><strong>高斯分布</strong></h3><p>下面对高斯分布进行推导，推导公式如下（为了方便计算，我们将方差 $\sigma$设置为1）：</p>
<center><br><img src="http://img.blog.csdn.net/20151006105614842" alt="这里写图片描述"><br></center>

<p>将上式与指数族分布形式比对，可知：</p>
<p>$$b(y) = \frac{1}{\sqrt{2\pi}}exp(-\frac{1}{2}y^{2})$$</p>
<p>$$T(y) = y$$</p>
<p>$$\eta = \mu$$</p>
<p>$$a(\eta)=\frac{1}{2}\mu^{2}$$</p>
<p>两个典型的指数分布族，伯努利和高斯分布。其实大多数概率分布都可以表示成指数分布族形式，如下所示：</p>
<ul>
<li>伯努利分布（Bernoulli）：对 0、1 问题进行建模；</li>
<li>多项式分布（Multinomial）：多有 K 个离散结果的事件建模；</li>
<li>泊松分布（Poisson）：对计数过程进行建模，比如网站访问量的计数问题，放射性衰变的数目，商店顾客数量等问题；</li>
<li>伽马分布（gamma）与指数分布（exponential）：对有间隔的正数进行建模，比如公交车的到站时间问题；</li>
<li>β 分布：对小数建模；</li>
<li>Dirichlet 分布：对概率分布进建模；</li>
<li>Wishart 分布：协方差矩阵的分布；</li>
<li>高斯分布（Gaussian）；</li>
</ul>
<p>下面来介绍下广义线性模型（Generalized Linear Model, GLM）。</p>
<h2 id="3-广义线性模型（Generalized_Linear_Model,_GLM）"><strong>3.广义线性模型（Generalized Linear Model, GLM）</strong></h2><p>你可能会问，指数分布族究竟有何用？其实我们的目的是要引出GLM，通过指数分布族引出广义线性模型。</p>
<p>仔细观察伯努利分布和高斯分布的指数分布族形式中的$\eta$变量。可以发现，在伯努利的指数分布族形式中，$\eta$与伯努利分布的参数$\varphi$是一个logistic函数（下面会介绍logistic回归的推导）。此外，在高斯分布的指数分布族表示形式中，$\eta$与正态分布的参数$\mu$相等，下面会根据它推导出普通最小二乘法（Ordinary Least Squares）。通过这两个例子，我们大致可以得到一个结论，<font color="red"><strong>$η$以不同的映射函数与其它概率分布函数中的参数发生联系，从而得到不同的模型，广义线性模型正是将指数分布族中的所有成员（每个成员正好有一个这样的联系）都作为线性模型的扩展，通过各种非线性的连接函数将线性函数映射到其他空间，从而大大扩大了线性模型可解决的问题。</strong></font></p>
<p>下面我们看 GLM 的形式化定义，GLM 有三个假设：</p>
<ul>
<li>(1) $y|x; \theta~ExponentialFamily（\eta）$；给定样本$ x $与参数$θ$，样本分类$ y$ 服从指数分布族中的某个分布；</li>
<li>(2) 给定一个 $x$，我们需要的目标函数为$h_{\theta}(x)=E[T(y)|x]$;</li>
<li>(3)$\eta=\theta^{T}x$。</li>
</ul>
<p>依据这三个假设，我们可以推导出logistic模型与普通最小二乘模型。首先根据伯努利分布推导Logistic模型，推导过程如下:</p>
<p>$$h_{\theta}(x) = E[T(y)|x]=E[y|x]=p(y=1|x;\theta)$$</p>
<p>$$=\varphi$$</p>
<p>$$=\frac{1}{1+e^{-\eta}}$$</p>
<p>$$=\frac{1}{1+e^{-\theta^{T}x}}$$</p>
<p>公式第一行来自假设(2)，公式第二行通过伯努利分布计算得出，第三行通过伯努利的指数分布族表示形式得出，然后在公式第四行，根据假设三替换变量得到。</p>
<p>同样，可以根据高斯分布推导出普通最小二乘，如下：</p>
<p>$$h_{\theta}(x) = E(T(y)|x)=E[y|x]$$</p>
<p>$$=\mu$$</p>
<p>$$=\eta$$</p>
<p>$$=\theta^{T}x$$</p>
<p>公式第一行来自假设（2），第二行是通过高斯分布$y|x;\theta$~$ N(\mu,\sigma^{2})$计算得出，第三行是通过高斯分布的指数分布族形式表示得出，第四行即为假设（3）。</p>
<p>其中，将η与原始概率分布中的参数联系起来的函数成为正则相应函数（canonical response function），如$φ =\frac{1}{1+e^{-\eta}}、μ = η$即是正则响应函数。正则响应函数的逆成为正则关联函数（canonical link function）。</p>
<p>所以，对于广义线性模型，需要决策的是选用什么样的分布，当选取高斯分布时，我们就得到最小二乘模型，当选取伯努利分布时，我们得到 logistic 模型，这里所说的模型是假设函数 h 的形式。</p>
<p>最后总结一下：<font color="red"><strong>广义线性模型通过假设一个概率分布，得到不同的模型，而梯度下降和牛顿方法都是为了求取模型中的线性部分$(\theta^{T}x)$的参数$\theta$的。</strong></font></p>
<p><strong>多分类模型-Softmax Regression</strong></p>
<p>下面再给出GLM的一个例子——<strong>Softmax Regression</strong>.</p>
<p>假设一个分类问题，y可取k个值，即$y \epsilon{1,2,…,k}$。现在考虑的不再是一个二分类问题，现在的类别可以是多个。如邮件分类：垃圾邮件、个人邮件、工作相关邮件。下面要介绍的是多项式分布（multinomial distribution）。</p>
<p>多项式分布推导出的GLM可以解决多类分类问题，是 logistic 模型的扩展。对于多项式分布中的各个y的取值，我们可以使用k个参数$\phi_1,\phi_2,…,\phi_k$来表示这k个取值的概率。即</p>
<p>$$P(y=i) = \phi_{i}$$</p>
<p>但是，这些参数可能会冗余，更正式的说可能不独立，因为$\sum\phi<em>i=1$，知道了前k-1个，就可以通过$1-\sum</em>{i=1}^{k-1}\phi<em>{i}$计算出第k个概率。所以，我们只假定前k-1个结果的概率参数$\phi_1$,$\phi_2$,…,$\phi</em>{k-1}$，第k个输出的概率通过下面的式子计算得出：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%5Cphi_%7Bk%7D%20%3D%201-%20%5Csum_%7Bi%3D1%7D%5E%7Bk-1%7D%5Cphi_%7Bi%7D%24%24" alt="$$\phi_{k} = 1- \sum_{i=1}^{k-1}\phi_{i}$$"></p>
<p>为了使多项式分布能够写成指数分布族的形式，我们首先定义 T(y)，如下所示：</p>
<center><br><img src="http://img.blog.csdn.net/20151006125938706" alt=""><br></center>

<p>和之前的不一样，这里我们的$T(y)$不等$y$，$T(y)$现在是一个$k-1$维的向量，而不是一个真实值。接下来，我们将使用$(T(y))_{i}$表示$T(y)$的第i个元素。</p>
<p>下面我们引入指数函数I，使得：</p>
<p>$$I(True)=1,I(False)=0$$</p>
<p>这样，$T(y)$向量中的某个元素还可以表示成：</p>
<p>$$(T(y))_{i}=I(y=i)$$</p>
<p>举例来说，当$ y=2 时，T(2)_2=I(2=2)=1，T(2)_3=I(2=3)=0$。根据公式 15，我们还可以得到：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24E%5B%28T%28y%29%29_%7Bi%7D%5D%3D%5Csum_%7By%3D1%7D%5E%7Bk%7D%28T%28y%29%29%7B%5Cphi%7D_i%3D%5Csum_%7By%3D1%7D%5E%7Bk%7DI%28y%3Di%29%5Cphi_i%3D%5Cphi_i%24%24" alt="$$E[(T(y))_{i}]=\sum_{y=1}^{k}(T(y)){\phi}_i=\sum_{y=1}^{k}I(y=i)\phi_i=\phi_i$$"></p>
<p>$$\sum_{i=1}^{k}I(y=i)=1$$</p>
<p>下面，二项分布转变为指数分布族的推导如下：</p>
<center><br><img src="http://img.blog.csdn.net/20151006131133675" alt="这里写图片描述"><br></center>

<p>其中，最后一步的各个变量如下：</p>
<center><br><img src="http://img.blog.csdn.net/20151006131218488" alt="这里写图片描述"><br></center>

<p>由$\eta$的表达式可知：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%5Ceta_%7Bi%7D%3Dlog%5Cfrac%7B%5Cphi_%7Bi%7D%7D%7B%5Cphi_%7Bk%7D%7D%5CRightarrow%20%5Cphi_%7Bi%7D%3D%5Cphi_%7Bk%7De%5E%7B%5Ceta_%7Bi%7D%7D%24%24" alt="$$\eta_{i}=log\frac{\phi_{i}}{\phi_{k}}\Rightarrow \phi_{i}=\phi_{k}e^{\eta_{i}}$$"></p>
<p>为了方便，再定义：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%5Ceta_%7Bk%7D%20%3D%20log%20%5Cfrac%7B%5Cphi_%7Bk%7D%7D%7B%5Cphi_%7Bk%7D%7D%3D0%24%24" alt="$$\eta_{k} = log \frac{\phi_{k}}{\phi_{k}}=0$$"></p>
<p>于是，可以得到：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%5Cphi_%7Bi%7D%3D%5Csum_%7Bj%3D1%7D%5E%7Bk%7D%5Cphi_%7Bk%7De%5E%7B%5Ceta_%7Bi%7D%7D%3D1%20%5CRightarrow%20%5Cphi_%7Bk%7D%3D%5Cfrac%7B1%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7De%5E%7B%5Ceta_%7Bi%7D%7D%7D%24%24" alt="$$\sum_{j=1}^{k}\phi_{i}=\sum_{j=1}^{k}\phi_{k}e^{\eta_{i}}=1 \Rightarrow \phi_{k}=\frac{1}{\sum_{j=1}^{k}e^{\eta_{i}}}$$"></p>
<p>将上式代入到</p>
<p><img src="http://latex.codecogs.com/gif.latex?%5Ceta_%7Bi%7D%3Dlog%5Cfrac%7B%5Cphi_%7Bi%7D%7D%7B%5Cphi_%7Bk%7D%7D%5CRightarrow%20%5Cphi_%7Bi%7D%3D%5Cphi_%7Bk%7De%5E%7B%5Ceta_%7Bi%7D%7D" alt="$$\eta_{i}=log\frac{\phi_{i}}{\phi_{k}}\Rightarrow \phi_{i}=\phi_{k}e^{\eta_{i}}$$">，得到：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%5Cphi_%7Bi%7D%3D%5Cfrac%7Be%5E%7B%5Ceta_%7Bi%7D%7D%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bk%7De%5E%7B%5Ceta_%7Bi%7D%7D%7D%3D%5Cfrac%7Be%5E%7B%5Ceta_%7Bi%7D%7D%7D%7B1&plus;%5Csum_%7Bj%3D1%7D%5E%7Bk-1%7De%5E%7B%5Ceta_%7Bi%7D%7D%7D%24%24" alt="$$\phi_{i}=\frac{e^{\eta_{i}}}{\sum_{j=1}^{k}e^{\eta_{i}}}=\frac{e^{\eta_{i}}}{1+\sum_{j=1}^{k-1}e^{\eta_{i}}}$$"></p>
<p>从而，我们就得到了连接函数，有了连接函数后，就可以把多项式分布的概率表达出来:</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24P%28y%3Di%29%3D%5Cphi_%7Bi%7D%3D%5Cfrac%7Be%5E%7B%5Ceta_%7Bi%7D%7D%7D%7B1&plus;%5Csum_%7Bj%3D1%7D%5E%7Bk-1%7De%5E%7B%5Ceta_%7Bi%7D%7D%7D%3D%5Cfrac%7Be%5E%7B%5Ctheta_%7Bi%7D%5E%7BT%7Dx%7D%7D%7B1&plus;%5Csum_%7Bj%3D1%7D%5E%7Bk-1%7De%5E%7B%5Ctheta_%7Bj%7D%5E%7BT%7Dx%7D%7D%24%24" alt="$$P(y=i)=\phi_{i}=\frac{e^{\eta_{i}}}{1+\sum_{j=1}^{k-1}e^{\eta_{i}}}=\frac{e^{\theta_{i}^{T}x}}{1+\sum_{j=1}^{k-1}e^{\theta_{j}^{T}x}}$$"></p>
<p>注意到，上式中的每个参数$\eta_i$都是一个可用线性向量$\theta_i^Tx$表示出来的，因而这里的$\theta$其实是一个二维矩阵。</p>
<p>于是，我们可以得到假设函数 h 如下：</p>
<center><br><img src="http://img.blog.csdn.net/20151006132537928" alt="这里写图片描述"><br></center>

<p>那么就建立了假设函数，最后就获得了最大似然估计 </p>
<center><br><img src="http://img.blog.csdn.net/20151006132628356" alt="这里写图片描述"><br></center>

<p>对该式子可以使用梯度下降算法或者牛顿方法求得参数$\theta$后，使用假设函数$h$对新的样例进行预测，即可完成多类分类任务。这种多种分类问题的解法被称为 softmax regression.</p>
<h2 id="References"><strong>References</strong></h2><ul>
<li><a href="http://www.phengkimving.com/calc_of_one_real_var/08_app_of_the_der_part_2/08_05_approx_of_roots_of_func_newtons_meth.htm" target="_blank" rel="external">Approximations Of Roots Of Functions – Newton’s Method</a></li>
<li>机器学习-Andrew Ng 斯坦福大学<a href="http://open.163.com/movie/2008/1/E/D/M6SGF6VB4_M6SGHKAED.html" target="_blank" rel="external">机器学习视频-第四讲</a></li>
</ul>
<hr>
<center><strong>本栏目机器学习持续更新中，欢迎来访：<a href="http://blog.csdn.net/dream_angel_z" target="_blank" rel="external">Dream_Angel_Z 博客</a><br>新浪微博： <a href="http://weibo.com/liudiwei210" target="_black">@拾毅者</a><br><br></strong></center>]]></content>
    <summary type="html">
    <![CDATA[<font color="green">回头再温习一下Andrew Ng的机器学习视频课，顺便把没写完的笔记写完。</font>

<p>本节内容</p>
<ul>
<li>牛顿方法</li>
<li>指数分布族</li>
<li>广义线性模型</li>
</ul>]]>
    
    </summary>
    
      <category term="GLM" scheme="http://csuldw.github.io/tags/GLM/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="指数分布族" scheme="http://csuldw.github.io/tags/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E6%97%8F/"/>
    
      <category term="牛顿方法" scheme="http://csuldw.github.io/tags/%E7%89%9B%E9%A1%BF%E6%96%B9%E6%B3%95/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用python模拟网页数据提交]]></title>
    <link href="http://csuldw.github.io/2016/01/02/2016-01-02-extracte-data-from-web-server-in-python/"/>
    <id>http://csuldw.github.io/2016/01/02/2016-01-02-extracte-data-from-web-server-in-python/</id>
    <published>2016-01-02T02:24:00.000Z</published>
    <updated>2016-03-13T06:50:11.811Z</updated>
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>做实验的时候，需要将独立测试集的数据与别人server跑出来的结果进行比较，比如下面这个：<a href="http://bioinfo.ggc.org/bindn/" target="_blank" rel="external">http://bioinfo.ggc.org/bindn/</a> 。但是这个server一次性只能提交一个fasta文件，也就是说，我有很多数据的话，就要分多次提交。如果是人工的去操作，会比较耗时，而且工作量特别大，因此这里就需要模拟网页的数据提交。这就是本文的主要内容，</p>
<a id="more"></a>
<h2 id="思路">思路</h2><p>下面先来理清下思路。我的目的是通过自己构造post数据来实现数据提交。</p>
<p>当模拟在网页上提交数据时，首先要弄清楚整个数据处理流程，比如发送了什么样的数据，给谁发的等。那么如果我要在网页上提交数据的话，肯定是要传递参数的，所以我们要知道如何查找这些参数，这是最重要的一点。其次，模拟数据提交，必须要知道提交前的网页和提交后的网页，这样才能将提交后显示结果网页保存下来。最后就是数据处理了，使用正则表达式将需要的数据抽取出来。</p>
<h2 id="实践">实践</h2><h3 id="参数分析">参数分析</h3><p>关于参数，可以从数据包中分析出来，我是使用google自带的抓包工具分析的，使用ctrl+shift+I快捷键，点击进入Network列，如下图：</p>
<p><img src="/assets/articleImg/2016-01-01-img1.png" alt=""></p>
<p>可以看到，当前什么都没有，下面我将参数填写完整</p>
<p><img src="/assets/articleImg/2016-01-01-img2.png" alt=""></p>
<p>当我将数据设置好之后，点击Submit Query按钮后，结果如下图所示：</p>
<p><img src="/assets/articleImg/2016-01-01-img3.png" alt=""></p>
<p>多了一个bindn.pl文件，我们来看看这个文件的内容，看看headers部分：</p>
<p><img src="/assets/articleImg/2016-01-01-img4.png" alt=""></p>
<p>和图二进行比较，你会看到是相互对应。也就是说，这就是我们需要提交的参数：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postData = &#123;<span class="string">'seq'</span> : oneseq,  <span class="preprocessor">#oneseq是一个字符串，后面作为一个参数传递进来</span></span><br><span class="line">        <span class="string">'qtype'</span> : <span class="string">'rna'</span>,  </span><br><span class="line">        <span class="string">'vtype'</span> : <span class="string">'sp'</span>,</span><br><span class="line">        <span class="string">'val'</span> : <span class="string">'80'</span>,</span><br><span class="line">        <span class="string">'submit'</span> : <span class="string">'Submit Query'</span> </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>而点击发送后的请求URL和HTML头内容，如下图：</p>
<p><img src="/assets/articleImg/2016-01-01-img5.png" alt=""></p>
<p>所以现在我们可以得到以下这些数据（postData在上面已经分析出来了）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hosturl = <span class="string">'http</span>:<span class="comment">//bioinfo.ggc.org/bindn/' </span></span><br><span class="line">posturl = <span class="string">'http</span>:<span class="comment">//bioinfo.ggc.org/cgi-bin/bindn/bindn.pl' #可以从数据包中分析出，处理post请求的url  </span></span><br><span class="line">headers = &#123;<span class="string">'User</span>-Agent' : <span class="string">'Mozilla</span>/<span class="number">5.0</span> (Windows NT <span class="number">6.1</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">46.0</span>.<span class="number">2490.80</span> Safari/<span class="number">537.36</span>',  </span><br><span class="line">           <span class="string">'Referer</span>' : <span class="string">'http</span>:<span class="comment">//bioinfo.ggc.org/bindn/'&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="Python模拟">Python模拟</h3><p>分析结束后，我们要构造自己的HTTP数据包，并发送给指定url。我们通过urllib2等几个模块提供的API来实现request请求的发送和相应的接收。最后需要编写一个函数，将自己需要的内容抽取出来。完整代码和讲解如下如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Fri Jan 01 09:34:50 2016</span><br><span class="line"></span><br><span class="line">@author: liudiwei</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> urllib  </span><br><span class="line"><span class="keyword">import</span> urllib2  </span><br><span class="line"><span class="keyword">import</span> cookielib  </span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment">#首先定义一个模拟数据提交的函数，传入刚刚分析出来的四个参数即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scratchData</span><span class="params">(hosturl, posturl, postData, headers)</span>:</span></span><br><span class="line">    <span class="comment">#设置一个cookie处理器，它负责从服务器下载cookie到本地，并且在发送请求时带上本地的cookie  </span></span><br><span class="line">    cj = cookielib.LWPCookieJar()  </span><br><span class="line">    cookie_support = urllib2.HTTPCookieProcessor(cj)  </span><br><span class="line">    opener = urllib2.build_opener(cookie_support, urllib2.HTTPHandler)  </span><br><span class="line">    urllib2.install_opener(opener) </span><br><span class="line">    <span class="comment">#打开登录主页面（他的目的是从页面下载cookie，这样我们在再送post数据时就有cookie了，否则发送不成功）</span></span><br><span class="line">    urllib2.urlopen(hosturl)  </span><br><span class="line">    <span class="comment">#需要给Post数据编码  </span></span><br><span class="line">    postDataEncode = urllib.urlencode(postData)  </span><br><span class="line">    <span class="comment">#通过urllib2提供的request方法来向指定Url发送我们构造的数据，并完成数据发送过程  </span></span><br><span class="line">    request = urllib2.Request(posturl, postDataEncode, headers)  </span><br><span class="line">    <span class="keyword">print</span> request  </span><br><span class="line">    response = urllib2.urlopen(request)  </span><br><span class="line">    resultText = response.read()  </span><br><span class="line">    <span class="keyword">return</span> resultText </span><br><span class="line"></span><br><span class="line"><span class="comment">#将一次提交写到一个函数里面，每次只需传入一个序列即可，因为其它的参数不变</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BindN</span><span class="params">(oneseq, outdir)</span>:</span></span><br><span class="line">    <span class="comment">#当前页面，即提交数据页面</span></span><br><span class="line">    hosturl = <span class="string">'http://bioinfo.ggc.org/bindn/'</span> </span><br><span class="line">    <span class="comment">#post数据接收和处理的页面（我们要向这个页面发送我们构造的Post数据）  </span></span><br><span class="line">    posturl = <span class="string">'http://bioinfo.ggc.org/cgi-bin/bindn/bindn.pl'</span> <span class="comment">#可以从数据包中分析出，处理post请求的url  </span></span><br><span class="line">     <span class="comment">#构造header，一般header至少要包含一下两项。这两项是从抓到的包里分析得出的。  </span></span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.80 Safari/537.36'</span>,  </span><br><span class="line">               <span class="string">'Referer'</span> : <span class="string">'http://bioinfo.ggc.org/bindn/'</span>&#125;   </span><br><span class="line">    <span class="comment">#构造Post数据，他也是从抓大的包里分析得出的。</span></span><br><span class="line">    postData = &#123;<span class="string">'seq'</span> : oneseq,  </span><br><span class="line">            <span class="string">'qtype'</span> : <span class="string">'rna'</span>,  </span><br><span class="line">            <span class="string">'vtype'</span> : <span class="string">'sp'</span>,</span><br><span class="line">            <span class="string">'val'</span> : <span class="string">'80'</span>,</span><br><span class="line">            <span class="string">'submit'</span> : <span class="string">'Submit Query'</span> </span><br><span class="line">            &#125; </span><br><span class="line">    result = scratchData(hosturl, posturl, postData, headers)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"+++++"</span>, oneseq </span><br><span class="line">    chainname = oneseq[<span class="number">1</span>:<span class="number">5</span>] + oneseq[<span class="number">6</span>:<span class="number">7</span>]</span><br><span class="line">    outfilename = str(chainname) + <span class="string">'.html'</span></span><br><span class="line">    fw_result = open(outdir + <span class="string">'/'</span> + outfilename, <span class="string">'w'</span>)</span><br><span class="line">    fw_result.write(result)</span><br><span class="line">    fw_result.close()</span><br><span class="line">    <span class="keyword">return</span> result, str(chainname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用正则表达式提取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractBindN</span><span class="params">(htmlfmt, outfile)</span>:</span></span><br><span class="line">    fw_result = open(outfile, <span class="string">'w'</span>)</span><br><span class="line">    inputdata = htmlfmt.split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inputdata)):</span><br><span class="line">        onedata = inputdata[i].strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> onedata:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'&lt;'</span> <span class="keyword">in</span> onedata <span class="keyword">or</span> <span class="string">'*'</span> <span class="keyword">in</span> onedata:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        regText = onedata.split(<span class="string">'\t'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">r'^\d+$'</span>, regText) <span class="keyword">and</span> <span class="keyword">True</span> <span class="keyword">or</span> <span class="keyword">False</span>:</span><br><span class="line">            fw_result.write(onedata + <span class="string">'\n'</span>)</span><br><span class="line">    fw_result.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#main方法</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    oneseq = <span class="string">"&gt;2XD0_A\nMKFYTISSKYIEYLKEFDDKVPNSEDPTYQNPKAFIGIVLEIQGHKYLAPLTSPK\</span><br><span class="line">    KWHNNVKESSLSCFKLHENGVPENQLGLINLKFMIPIIEAEVSLLDLGNMPNTPYKRMLYKQLQFIRANSDKIA\</span><br><span class="line">    SKSDTLRNLVLQGKMQGTCNFSLLEEKYRDFGK"</span></span><br><span class="line">    outdir = <span class="string">"/home/liudiwei/result"</span> <span class="comment">#输出路径</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(outdir):</span><br><span class="line">        os.mkdir(outdir)</span><br><span class="line">    <span class="keyword">print</span> outdir</span><br><span class="line">    result, chainname = BindN(oneseq, outdir)</span><br><span class="line">    outfile = outdir + <span class="string">"/"</span> + chainname + <span class="string">".data"</span> <span class="comment">#最终输出的文件名</span></span><br><span class="line">    extractBindN(result, outfile)</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="背景">背景</h2><p>做实验的时候，需要将独立测试集的数据与别人server跑出来的结果进行比较，比如下面这个：<a href="http://bioinfo.ggc.org/bindn/">http://bioinfo.ggc.org/bindn/</a> 。但是这个server一次性只能提交一个fasta文件，也就是说，我有很多数据的话，就要分多次提交。如果是人工的去操作，会比较耗时，而且工作量特别大，因此这里就需要模拟网页的数据提交。这就是本文的主要内容，</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="数据提取" scheme="http://csuldw.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96/"/>
    
      <category term="正则表达式" scheme="http://csuldw.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习-CSDN个人译文目录]]></title>
    <link href="http://csuldw.github.io/2016/01/01/2016-01-01-csdn-cloud-column-translation/"/>
    <id>http://csuldw.github.io/2016/01/01/2016-01-01-csdn-cloud-column-translation/</id>
    <published>2016-01-01T02:24:00.000Z</published>
    <updated>2016-03-14T13:44:09.479Z</updated>
    <content type="html"><![CDATA[<h2 id="个人译文"><strong>个人译文</strong></h2><p>下面是本人在CSDN云计算栏目发布的翻译文章，如有翻译不准确的地方，还望多多包涵，希望能给大家带来点帮助！</p>
<a id="more"></a>
<p>译文列表如下：</p>
<ul>
<li>2015-12-31 <a href="http://www.csdn.net/article/1970-01-01/2826566" target="_blank" rel="external">如何让神经网络把熊猫识别为秃鹫</a></li>
<li>2015-12-25 <a href="http://www.csdn.net/article/2015-12-25/2826560" target="_blank" rel="external">25个Java机器学习工具&amp;库</a></li>
<li>2015-12-10 <a href="http://www.csdn.net/article/2015-12-10/2826435?t=1450960417375" target="_blank" rel="external">Python机器学习库</a></li>
<li>2015-12-07 <a href="http://www.csdn.net/article/2015-12-02/2826374?reload=1" target="_blank" rel="external">逻辑回归 vs 决策树 vs 支持向量机（II）</a></li>
<li>2015-12-02 <a href="http://www.csdn.net/article/2015-11-26/2826332" target="_blank" rel="external">逻辑回归、决策树和支持向量机（I）</a></li>
<li>2015-11-02 <a href="http://www.csdn.net/article/2015-11-02/2826107" target="_blank" rel="external">你应该知道的机器学习方法</a></li>
<li>2015-10-26 <a href="http://www.csdn.net/article/2015-10-23/2826027" target="_blank" rel="external">深度学习和拓扑数据分析的六大惊人之举</a></li>
<li>2015-10-16 <a href="http://www.csdn.net/article/2015-10-16/2825926" target="_blank" rel="external">[访谈]数据大师Olivier Grisel给志向高远的数据科学家的指引 - Part2</a></li>
<li>2015-10-11 <a href="http://www.csdn.net/article/2015-10-11/2825882" target="_blank" rel="external">[访谈] Olivier Grisel谈scikit-learn和机器学习技术的未来 - Part1</a></li>
<li>2015-09-14 <a href="http://www.csdn.net/article/2015-09-14/2825693" target="_blank" rel="external">LSTM实现详解</a></li>
<li>2015-09-10 <a href="http://www.csdn.net/article/2015-09-08/2825646" target="_blank" rel="external">从零实现来理解机器学习算法：书籍推荐及障碍的克服</a></li>
<li>2015-08-31  <a href="http://www.csdn.net/article/2015-08-27/2825551" target="_blank" rel="external">机器学习开发者的现代化路径：不需要从统计学微积分开始</a></li>
<li>2015-08-27 <a href="http://www.csdn.net/article/2015-08-27/2825549" target="_blank" rel="external">基于Python的卷积神经网络和特征提取</a></li>
<li>2015-08-20 <a href="http://www.csdn.net/article/2015-08-19/2825492" target="_blank" rel="external">你应该掌握的七种回归技术</a></li>
<li>2015-08-11 <a href="http://www.csdn.net/article/2015-08-10/2825430" target="_blank" rel="external">机器学习API Top 10：AT&amp;T Speech、IBM Watson和Google Prediction</a></li>
<li>2015-08-09 <a href="http://www.csdn.net/article/2015-08-07/2825415" target="_blank" rel="external">使用GPU和Theano加速深度学习</a></li>
<li>2015-08-03 <a href="http://www.csdn.net/article/2015-08-01/2825362" target="_blank" rel="external">从Theano到Lasagne：基于Python的深度学习的框架和库</a></li>
<li>2015-07-13 <a href="http://www.csdn.net/article/2015-07-13/2825187" target="_blank" rel="external">开发者成功使用机器学习的十大诀窍</a></li>
</ul>
<p>下面是其他译者的译文，仅供参考：</p>
<ul>
<li>2015-10-03 <a href="http://www.csdn.net/article/2015-10-01/2825840" target="_blank" rel="external">基于Hadoop集群的大规模分布式深度学习</a></li>
<li>2015-09-16 <a href="http://www.csdn.net/article/2015-09-15/2825714" target="_blank" rel="external">各种编程语言的深度学习库整理</a></li>
<li>2015-09-11 <a href="http://www.csdn.net/article/2015-09-08/2825647" target="_blank" rel="external">机器学习温和指南</a></li>
<li>2015-09-10 <a href="http://www.csdn.net/article/2015-09-10/2825668" target="_blank" rel="external">关于数据科学，书上不曾提及的三点经验</a></li>
<li>2015-08-12 <a href="http://www.csdn.net/article/2015-08-07/2825416" target="_blank" rel="external">特征工程 vs. 特征提取：比赛开始！</a></li>
</ul>
<p>由于本人翻译水平有限，有的地方可能有所漏洞，还望读者海涵。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="个人译文"><strong>个人译文</strong></h2><p>下面是本人在CSDN云计算栏目发布的翻译文章，如有翻译不准确的地方，还望多多包涵，希望能给大家带来点帮助！</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="译文" scheme="http://csuldw.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015，稳稳地幸福]]></title>
    <link href="http://csuldw.github.io/2015/12/31/2015-12-31-annual-summary/"/>
    <id>http://csuldw.github.io/2015/12/31/2015-12-31-annual-summary/</id>
    <published>2015-12-31T15:00:00.000Z</published>
    <updated>2016-03-12T11:24:05.933Z</updated>
    <content type="html"><![CDATA[<p>就用这首《稳稳地幸福》作为开场白吧，希望也有一种稳稳的幸福！</p>
<p><em>有一天，我发现自怜资格都已没有<br>只剩下不知疲倦的肩膀<br>担负着简单的满足<br>有一天，开始从平淡日子感受快乐<br>看到了明明白白的远方<br>我要的幸福……</em> </p>
<a id="more"></a>
<p>不知道从什么时候起，渐渐地开始喜欢安静，喜欢自言自语，喜欢胡思乱想，喜欢对着电脑敲打着键盘写着自己想说的话。也好，算是自己一种放松的方式吧。</p>
<p>2015对我来说是一个充满着故事的数字，装载了很多回忆，有美好的，当然也有难忘的。经历了很多，明白了许多，周围的人也在不断的发生变化，最明显的便是大学四年的室友也结婚了。这个话题似乎比较沉重，在这里就不谈了吧，归根结底，还是自己经历的太少了。</p>
<p>今年从研一进入了研二，过的很快，当你还没感觉到正式开始的时候，研究生生涯就已经过半了，同时也过了一整年。幸运地是，在研一期间收获了一群小伙伴。其实我很怀念今年三月的那段时间，实训的时候，一群实验室的同学经常上完实训课就结伴去食堂旁边的餐厅点菜，一边吃饭一边聊天，随便开玩笑，没有什么顾虑，有种亲切随和心安的感觉，当然还有一种大家庭的味道。当自己难过的时候，还有一群兄弟朋友在旁边陪伴，虽然偶尔会开下玩笑，但还是挺好的。虽然从四月开始，大家都纷纷出去实习了，但几个同城的小伙伴偶尔聚一次，搞点活动，过的倒也蛮潇洒。如果让我用一句话来形容我们的话，我会引用《速七》里面的一句话“we are not friends, we are family”。</p>
<p>言归正传，还是来总结一下今年的生活吧。说到总结，对于还生活在学生时期的我来说，学习是个不可逃避的话题，那么索性就先从学习开始吧。14年的时候，只是简单的学习了数据挖掘，当时拿着韩家炜的那本《数据挖掘概念与技术》就开始漫无目的的去看，很吃力，同样也很难理解，效果也不好，“万事开头难”确实是如此。一学期后，对算法并没有深入了解，然后就不了了事了。这次，乘着三月份之后大部分课程完结了，打算全面地重新学习下常用的算法知识。因而自从实训结束后，就全心地投入到ML的学习中了。看视频跑代码做实验等等，学习斯坦福大学AndrewNg的ML视频教程，还有《统计学习方法》，《机器学习实战》以及相关的Python机器学习库等，还买了很多的书籍，大多是与ML相关的书籍，也有和Linux相关的。虽然这个过程很艰苦，但慢慢的还是坚持了下来，对机器学习也有了进一步的认识，比如什么时候会发生overfiting，如何降低overfiting，又如何提高一个算法的robust等，说到底好的数据比算法更加重要吧，只是现在感觉缺乏一些实践。四月份，因为导师让我带本科生的云计算实验课，所以就顺便初步学习了Hadoop，但并没有深入，只是简单的配置了一下，了解了下Hadoop的文件系统HDFS。后来在博客里写了很多的博文，大多是和ML有关的（都是比较基础的），也有一些与python、Linux、R有关的文章，目前CSDN博客的访问量上升至7w+，主要还是给自己留一个空间，以后回头看的时候会有一些小成就感吧！也因此被CSDN的一个编辑人员发现。随后便成了CSDN云计算专栏的一名机器学习兼职翻译人员，开启了一段翻译旅程，主要负责将国外近期的机器学习优秀博文翻译成中文。时至今日，大概翻译过30余篇文章吧，受益匪浅，感触颇多。</p>
<p>五月下旬的时候，忘记是从哪儿冒出的灵感，突然脑子就产生了一个想法，决定搭建一个属于自己的博客，专门用来记录自己的学习与生活。所以在接下来的业余时间，就开始搭建了自己的<a href="http://csuldw.github.io">个人博客</a>。其实这个经历还是够呛的，起初自己很多东西都不知道，跟个小白没什么两样，比如域名解析、Git、VPS之类的也只是听过，没有实践过，有的只是一个目的（搭建博客）。然后听别人说到了WordPress，接着自己就去查阅资料，还花了点钱租了一个VPS并买了一个域名——csuldw。其实这个域名取名也是讲究了下，前三个字目csu表示Central South University，ldw是我名字的拼音首字母，很容易记的，然后就在VPS中搭建了一个WordPress个人博客，但使用WordPress搭建的博客挂在VPS上的访问速度真的不行，另外需要管理的东西太多了，也不方便发文章，现在连VPS账号都忘记了。无奈之下又去查资料，根据网上的推荐，就使用Jekyll搭建了一个静态博客，当时对这个主题还算满意。没过多久，想对主题进行修改，可是发现修改起来很困难（其实是自己对前端知识了解的不多）。最后，干脆再次换样式，换框架，然后便使用一款基于nodejs的Hexo框架在GitHub上搭建了一个纯静态博客。经过几番折腾之后，主题也修改好了，博客也就诞生了，自己也从一个Git小白慢慢地熟悉了Git，而且对Markdown的使用也越发熟练了，撰写笔记更加方便多了。一个小博客，算是今年的一个小成果吧，内容慢慢再充实。使用github搭建的静态博客，遇到的一个很直接的问题就是图片加载的比较慢，介于这一点，可以将图片上传到其它的图床中或是新浪相册，只要能够获取到图片的链接就OK了，说到底这个还是自己体验上的一个小强迫症吧。</p>
<p>下面是5月26日写下的日记，博客的缘由原来是这样的：</p>
<blockquote>
<p>2015.05.26 今天上午看了机器学习的“贝叶斯”部分，朴素贝叶斯比较简单，后来就去打印室帮一个在外地的在职研究生打印毕业论文。吃了中饭后无意间在网上看到说作为一个大学生，就应该有一个专属于自己的博客。带着一种学习的心情，去网上买了域名，租了一个美国的VPS，然后使用WordPress搭建了一个属于自己的博客。整个过程碰到了些许问题，然后请教横天的客服，原来是我这边网络的问题，后来就把VPS换成香港的，网速也上去了。很开心~不过由于WordPress是使用php编写的，而我学的是java，很多东西不是很懂，看来以后有时间得好好学习学习。然后自己又折腾了下github，因为看到一位大牛pluskid现在使用的是static 的blog，使用的是github，然后我折腾了好久，没折腾好。算了，先用着WordPress吧，等到以后那天也成“大牛”了，也换个地方折腾折腾。现在主要是能写下东西就ok了。中午没休息，好累，回去睡觉去了。</p>
</blockquote>
<p>说了这么多，在学习上其实还有一件虐心事，折腾了好几个月了，也就是论文，很揪心。七月份开始睡实验室，跑实验，开始是在自己电脑上面跑，几天没关机，电脑硬盘直接挂掉了，后来直接网购了一个SSD硬盘，换了原来的硬盘，把原来的硬盘撞在了光驱位用来存放临时数据，开机和关机都快了很多，心情一下子就愉快了。八月份跑完实验后就开始写论文，投稿的经历就不说了，结果就是至今还在大修，接下来还需要继续做实验，慢慢改吧，有时候做梦都在调参数，希望能够早点做完吧，然后顺利的出去实习！不过在这方面真的要感谢一下自己的导师，不仅耐心的指导我们，还特别地亲民和善，很nice的一位老师。说到论文，自己从实验中还是学到了很多东西。从数据集的处理，到特征选取，然后如何去处理不均衡数据问题，再到算法的使用、选择、评估。整个流程重复了好多遍，很多原本对理论模棱两可的知识都进一步理解了。比如评估指标的计算、ROC曲线的绘制以及scikit-learn的使用等，收获算是比较大吧。八月之后，从九月开始，大大小小的事情确实比较多了，自己能够安排的时间并不多，可现在回头一想，这段时间也并没有做出什么成果，一直处于瞎忙的状态，结果也就是“郁郁而终”了。其实起初我对自己的时间是有计划的，只是突如其来的事情太多，再加上看论文作报告修改论文等等，一下子一个学期就过去了。唯一值得欣慰的就是拿到了今年的研究生国奖，“否极泰来，物极必反”，大概就是这样的吧。敲门声响起无数次，其它的都是诱惑，只有一次是机会，估计是把今年的运气都集在这里了。突然想到了那句话“上帝为你关上一扇门的同时,还打开了一扇天窗”！</p>
<p><img src="/assets/articleImg/2015-12-31-desktop.jpg" alt="fdsfsf"></p>
<div class="caption">『上图是三月底的桌面，下图是十二月底的桌面，多了很多的书籍.』</div>


<p>在学习上还有一件让我印象比较深而且很难忘的事情，那就是今年一月下旬那会儿做的事情，应导师之需去配置实验室的cluster（集群）。当时自己压根就不知道cluster是什么，然后就去配置。当然，这里的cluster并不是大家常说的Hadoop，而是Torque，一种用于高性能计算的cluster。当时凭着之前自学的Linux知识，就从装系统开始，一步一步的去配。开始是在实验室的三台台式机器上做测试，只记得那会儿出错后就重装系统，很笨很笨的方式，遇到问题也只能去Google搜索，而那会儿对英文有种莫名恐惧的feel，想必大多数人都有过这种feel！经过几天之后，这三天机器配好了，然后就去配置服务器上的机器，一共开了62台虚拟机器，就我一个人，当时还是个小白，有问题也只能去Google。现在回想下，都不知道自己当时是怎么熬过来的，所幸还是把所有服务器配好了。最后集群之间可以通过NFS进行文件共享，还使用NIS对用户进行统一管理，只是对软件没有使用统一的管理方式，比如现在需要安装一个python库，那么我就需要给所有的机器都安装一遍，工作量太大，不科学。现在也想到了一种解决方法，就是将python安装在一个共享目录下，所有的库也安装在在此目录下，然后把这个目录mount到其它节点中，理论上是可以解决的。只是自那之后就没有对系统进行升级了，有时间再去折腾吧！！！</p>
<p>最近应导师之需，让我想个方法把今年大家做的报告PPT集中起来，比如新建一个百度云账号，或者在我们的服务器上建立一个公共文件夹等。起初我自己想到的是在Github上面建立一个仓库，然后让大家都把东西上传到上面去，也比较方便，但是考虑到Github上面的仓库都是公共的（私有的需要付费），所以这个念头从一开始就被自己全盘否决了。后来想，在服务器上弄个ftp服务器怎么样呢？就这样一个想法，剩下的就是如何去实现。记得之前也有这个想法，五月份的时候，不过那时用的外网的服务器是学校的机器，因为当时配置完SELinux时重启了服务器，后来导致半个小时没启动成功。下面是当天的日记：</p>
<blockquote>
<p>2015.05.28 今天按照导师的要求在学校的服务器上挂载了我们自己内网服务器上的两个共享文件夹，成功了。后来导师说装一个Samba吧，我正打算在学校的服务器上装的时候，安装完了还没有配置，需要重启机器，我就使用reboot重启了，结果服务器启动不了了。我就纳闷了，这怎么可能。然后我就跟管理服务器的史大牛汇报了一下，因为他在北京，所以不能处理，就跟管理这台服务器的周老师说了。这不说还好，一说就被骂了。因为周老师都不知道我们有这台服务器的权限，这台服务器的密码还是史给我们的，这下把他坑惨了。差点把他从北京坑回来了。所幸没什么事，过了没多久服务器启动成功了。然后周老师把密码都给改了，因为我们实验室的路由器的网络和实验室服务器的网络是两个不同内网，不在一个局域网，使用PuTTY登陆不上去。之前是因为学校的服务器接了多个网卡，我们可以通过先登录到学校的服务器上，然后通过内网透析使用SSH切换到我们自己的服务器上，现在好了，没权限了，让给我们开个非root用户当做登陆用户都不肯，导师说学校那帮人最懒了，一点也不假呀，占着资源不肯放。然后晚上跟导师群聊了下，导师说我们干脆自己再买一台服务器算了，免得用学校的到时候出问题了又赖在我们头上。汗，只能这样了，加油吧，多学点linux操作~fighting！！！</p>
</blockquote>
<p>周老师将服务器密码改了之后，最后导师就干脆自己买了一台服务器。因为这台服务器的大多配置都是我配的，比较了解。因为对其他机器没什么依赖，所以重启机器也不会出任何问题。于是就打算在这台服务器上配置一个FTP服务器。因为配置服务器当天中午开完组会之后没休息，所以从开始到最后，用了将近一个下午的时间。碰到的一个比较简单的问题就是端口设置，如何让防火墙开放某个端口。去年自己在虚拟机上的centos6.5系统配置过这个，当时是直接将防火墙关闭掉，但现在考虑到安全问题，所以不能这么做了。其实只要弄懂了思路，整个配置也就显得简单了。如果默认端口号是21的话，可以直接直接访问[ftp://192.168.12.12]，不过我在配置vsftpd的时候修改了端口，所以需要在ip地址后面加上端口号，也就是类似这种[ftp://192.168.12.12:9999]。配置的时候，在细节上也碰到一些问题，不过通过google还是很容易就搜到结果的。总的来说，得到了一个小道理：对于小白来说，就是用时间去攒经验，用时间去买教训，所以必须自己去动手实践，这样才能得到更加直观的结果。而我希望我能够尽最大的速度攒更多的经验，买更多的教训。学习就是一个不断升华的过程，以前看似复杂而困难的问题，当你在相关知识上达到一定深度之后，它们都将随之而变的简单。现在能做的就是不断的去练习、去实践，然后去总结，化教训为经验！</p>
<p>今年做过很多次小组报告，大多时候讲的主题都是与课题相关的论文。有时候自己在作报告的时候也会紧张，因为先前准备的不充分，很多论文中的东西还来不及理解，有时甚至连文章中的核心思想都还没完全弄懂，讲出来之后，大家可能也很迷惑。通过多次的锻炼，在这方面还是有了很大的提升，给我的教训就是：要做好一个报告，前提是自己要对这个报告主题内容详熟，能够达到那种完全脱稿的水平就再好不过了。这里说的脱稿并不是不看ppt，而是不要对着ppt上面的内容进行实读，要能够用自己的话进行总结，进行归纳，通过一个主题，自己能够扩展其他的内容，然后将语言表达通顺就OK了。在多次的报告讲解中我发现，如果是讲解自己的论文，那么完全不需要做太多的准备，毕竟整个实验过程自己都知道。另外，每次在讲解服务器的时候，思路很清晰，讲起来也很顺手，可能也是因为熟悉的原因吧！但是大家能不能听懂，又是另外一回事了吧，事实上我觉得听完之后能有个概念也就差不多了。</p>
<p>谈完学习，下面来说说与娱乐有关的吧。很遗憾，今年并没有去过多少地方游玩，离学校最远的地方也只是张家界（虽然离家很近，但我却从未去过），走得较多的还是市内的景点吧，去过植物园，爬过岳麓山，逛过橘子洲等，还回过几次农大，摘过草莓，看过枫叶，顺便在校园里散散心。其实并不是自己不想出去，而是今年压根就没闲下来，或者说是自己不想闲吧。一方面，时间确实比较紧，一直奔波在宿舍与实验室之间，更多的是想多学点东西；另一方面，自己今年也确实没计划过要去别的地方，然后很快地一年就过了。曾经自己也想过要去哪些地方，走哪些路，看哪些风景，想在某年某月某一天，背起行囊去流浪。就这样，一个人，一个背包，还有一颗毅然行动的心，去一个陌生的地方。曾想象，一个人留恋于古色古香的苏杭，闲游于景色迷人的西湖，雷峰塔下，断桥旁边，坐于亭中观看行人匆匆，烟雨濛濛。提一壶新茗，浪迹天涯，悠然地寻找江南文化的气息。曾期待，一个人游走在车水马龙的外滩，越过黄浦江眺望远方的东方明珠，在一片灯红酒绿迷人的世界里，感叹着时代的变迁。曾盼望，一个人站在魅力弥漫的日光城下，看着那神圣的布达拉宫，听颂着来自上天的独白，随着飘动的经幡，传到遥远的他方。曾渴望，一个人漫步于浪漫之都，仰望埃菲尔铁塔，身处薰衣草花海，品尝法式甜点，惊叹画家之笔，触摸着法兰西风情熏陶下香榭丽舍的梧桐树。曾梦想，一个人浪迹在伦敦街头，乘一辆红色双层巴士，与阿狸一同探寻永远站的方向。然后寻一家小店，品位正宗英国红茶带来的英伦历史的沉淀，感受风雨后之的痕迹。就这样，一个人，一座城。然而，后来慢慢地变得开始理性了，渐渐地想的也多了，明白的东西也多了。那么还是让我现实点，踏实地做该做的事情吧！突然想到那句，“累就对了,舒服是留给死人的！”，是的，加油吧！时机到了，会有机会出去的（算是给自己一个安慰吧T_T！）。只需记住，越有故事的人越沉静简单，越肤浅单薄的人越浮躁不安。每一个优秀的人，都有一段沉默的时光。</p>
<p>相比于游山玩山，今年做的最多的娱乐活动就是看电影了。回想了下，三月看了《帕丁顿熊》，四月看了吴京主演的《战狼》，还有《速度与激情7》，五月看了《何以笙箫默》，七月月看了《捉妖记》，八月看了《大圣归来》、九月看了《港囧》与《碟中谍5神秘国度》，十月看了《夏洛特烦恼》、《小王子》以及《蚁人》，就这些，有搞笑的，也有比较敷衍人的，总的来说还是比较开心，算是弥补了今年没有外出游玩的自己吧！还记得九月下旬那会儿，中秋在即，去了大学母校拜访了文静姐，一个正在享受着当母亲的老师。晚上请我吃了一顿大餐，还送给我一提月饼，感觉好幸福，所以我从来都不去羡慕别人家的老师啦^_^！十一月回农大看枫叶，逛了下校园，然后去红旗市场的溜冰场玩了一会儿，那时那地那景那情，缠绕于指尖，记忆犹深！其实我的爱好也很多的，比如摄影、爬山、溜冰、打桌球、唱K（属于瞎吼的那种）等等，当然也包括了学习（必要时还是得装一下，虽然装的不像）。只是现在除了想学好点，似乎对其它的东西都渐渐地失去了以往的热情，没有了那份心思和真诚，简单地说就是心不在此吧。都说在外待太久，会比较想家，可能我属于异类，回头想想，从过年后回校到现在，中途只回家待了三天，而且还待不住。比往年少了很多，以前至少暑假会回去，各方面的原因都有，可能真是因为自己长大了。其实长大并不可怕，可怕的应该是遗忘吧。</p>
<p><img src="/assets/articleImg/2015-12-31-movie_all1.jpg" alt=""></p>
<div class="caption">『今年保留的所有电影票，与以往比较，多了很多.』</div>

<p>今年并没有得什么大病，只是生过两次小病，并无大碍，但生病的时候还是让人很难受的。一次是在六月底七月初的时候，由于喉咙发炎，接着引发了感冒，发烧，然后头晕，后来连噎食喉咙都痛，大夏天的真是受罪。另外一次是十二月，也是喉咙发炎，不过幸好及时吃了消炎药，没有恶化，第三天就好了。可前些日子，突然心脏部位略微阵痛，算是尝到了什么叫心痛，真正的心痛，应该是最近太累了，一个本命年，过的真是受罪。恩，对，本命年，已经二十四了！！！希望明年的自己能有一个健康的身体吧。写到这里，不禁地想总结一下自己今年的作息。从三月实训开时，早上八点半到晚上五点半待在机房，晚上直到十点多才离开实验室，持续到27号实训结束，一个月只外出三次，一次农大，一次植物园，一次新校区。四月，外出看过两次电影。五月接待同学一天，然后张家界来回三天。六月全月不外出。七月开始睡实验室，中途和小伙伴们聚餐一次，外出看电影一次。八月开始赶论文到中旬，加班至一两点。中下旬接待同学，外出两天，随后搬往宿舍休息。九月回家待了三天，同学聚餐一次，外出看电影两次，农大探望老师一次。十月导师组织烧烤活动一次，外出看电影三次。十一月去农大看枫叶一次。十二月同学结婚，外出两天。其余时间都待在了实验室。对我来说，似乎没有假期与周末可言吧，每天都是一样的日子，千篇一律，有时待到十一点左右才回去，还是那句话，“累就对了，舒服是留给死人的！”。一年的实验室生活，碰到过很多问题，也学到了很多。每一位苦行僧的背后大概都有一段不为人知的往事吧。事实上，如果自己想休息，倒也可以给自己放个假，自由但不放纵，收敛自如，感觉还是很自在、很舒服！毕竟除了待在实验室，也没有其他的地方可以去，似乎到了这里情绪有些低落！！！！</p>
<p><img src="/assets/articleImg/2015-12-31-lab-morning.jpg" alt=""></p>
<div class="caption">『某天早晨，阳光从对面楼层的玻璃反射到我的卓子上，很温暖，特别的温馨.』</div>


<p>今年参与的活动不多，除了四月的时候研会举行的那次“最强班集体活动”外，还有一次就是十月中旬左右导师组织的野外烧烤了，其它的就是同学聚餐之类的。回想下四月份，那时的我还算比较积极，参加了好几个比赛项目，有的还拿到了第一名，不过不是个人赛啦。最后我们1402班拿下了冠军，奖励了400大洋呀，钱没发下来就先出去吃了顿好的，算是意料之外的收获吧。另外，印象比较深刻的就是那时的抽奖活动，至今都记忆犹新。也就是那些跟我一起的小伙伴每个人都抽到了奖品，唯独我没抽到，想必我应该就是那个传说中万中无一的人了(<em>^__^</em>)……。这应该不是巧合，运气太背了，于是乎“本命年”似乎又躺枪了，(^__^) ……。十月那会儿的烧烤活动，是由导师发起的，不过烧烤食物的原材料是由我和其他几个人一起去超市购买的。因为是第一次买这些食材，没有经验，份量更是不好估计，所幸最后大家都吃完了，关键是大家开心就好！</p>
<p>事实上，每个人都有不开心的时候，我也一样，但我的不开心，我的难受，我都尽量留给了自己。只是很多时候，那些安慰别人的话，怎么也安慰不了自己。原因不详，有待细查！那么在这里，就让所有不开心的事情随着2015的离去而过去吧！似乎是从今年五月起，慢慢地开始戒掉了QQ、微信这些社交网络，不会再刻意地去翻阅手机动态，不再专注于回复别人或是查看别人的回复，开始做一个沉默寡言的人，事不关已的事也无需多去关心，只是偶尔会在Sina这样一个安静的人少的地方水水心情！现在，也已习惯了这种节奏，晚上回到宿舍，洗漱完之后也不再会像以往那样经常刷状态，反倒是给自己省下了很多时间做其他的事情！我的计划是明年上半年就出去实习，如果能够早点学校这边的事情搞完，自己也就多点时间复习面试知识。“没有三两三，哪敢上梁山”嘛，掂量掂量自己的水平，提前做好面试准备，也好有个心理准备。可能很多人都觉得我学的好，不过，自己到底有几斤几两，水深还是不深，自己还是有自知之明的，能够将自己80%的好表现出来就行了。Remember，你所恐惧的东西，最终都将变成你的弱点！每当一个人独处的时候，总会想到很多的事情。过去，现在，未来，总有自己可想的事。现在的我，更多的是希望好好把技术学扎实，锻炼好自己各方面能力吧。之前就说过这样一句话，“对现在的自己要求高点，就是给未来的自已最好的礼物！”，一点都没错。相信自己！每当翻阅浙大张弛原和张睿卿两位大牛的文章，总给我一种奋勇向上的激情。如果自己的知识能够达到一定的深度，即便是苦点累点或是慢点，也值了！自己选择的路，跪着也要走完。</p>
<p><img src="/assets/articleImg/2015-12-31-huatian.jpg" alt=""></p>
<div class="caption">『今年十二月，大学室友结婚接新娘的那天早上在华天酒店拍的，当时还没系腰带.』</div>

<p>今年结婚的同学有两个，一位是大学时候的班长，一位是大学的一位室友。一个在二月，一个在十二月，很喜庆，一年好始好终的过了！班长结婚是在常德石门，因此几个有空的同学就跑到常德石门去祝福了，虽说参加别人的婚礼就像是花钱去看别人虐狗（开个玩笑），但有空还是要去的啦，至少还可以当个演员嘛^_^。在大学室友结婚那天也是挺开心的，当了一回伴郎。当伴郎收获比较多的就是，对整个婚礼的流程都了解的很清楚，当地的习俗也知道个大概。身为伴郎，在当天的酒席上并没有吃饭，只记得那天喝的有点多。那种酒席上的玻璃杯，喝了三大半杯白酒，只不过当伴郎喝酒也是没办法的事！随后应新郎支托给同学们开了间麻将房，接着去他们打麻将，自己就在里面睡了一下午，后来大脑虽然清醒，但真的很是难受，半醉半醒的状态更是不堪回首。毕竟我也是不喜欢喝酒的，当然也不抽烟，更谈不上喜欢了。说到吃的，其实我并不挑食，草莓，香蕉，水龙果，橘子好多水果都吃，喜欢喝咖啡，奶茶，绿茶，还喜欢嗑瓜子，最近又喜欢上夏威夷果子，而对巧克力也是无法抗拒的。以前还喜欢吃各类糖果，算一算也是蛮多的。只是如今一天到对着电脑，也顾不上吃这些水果零食了。说到大学同学，自从班长结婚之后，今年就很少聚了，大家交流的也很少了。一方面，大家应该都很忙吧，各自忙各自的，就像我一样。另一方面，可能班长结婚后，没有一个好的据点了吧！另外，听说有位同学已经奉子领证了，果真是士别三日当刮目相待呀！！！</p>
<p><img src="/assets/articleImg/2015-12-31-tiedao1.jpg" alt=""></p>
<div class="caption">『学校的西门，摄于某个晴空万里的冬天下午.』</div>

<p>来到中南，步入一个新的地方，认识了新的同学，结交了新的朋友，进入了一种新的学习状态，一年又半载，很多事情都在不经意间就开始了，而我也早已习惯了这里的生活！数落着剩下的研途生涯，希望自己能够学到更多的东西吧。烟雾蒙蒙的今晚，已经看不到点点繁星了，望着天空残寂的孤月，明亮中夹带着些许凄美，些许迷离。唏嘘的叹息，在这无眠清寂的长夜里，留下无数的落寞。过往的点滴，都渐渐的在遗逝的记忆里沉淀。走过了似水流年，看过了风花雪月，曾经有一段时光，做了温馨的梦，曾经有一场梦，沧桑中透着凄凉，曾经也有一座城市，却成了一生的梦。夜已深，心已静，默默的守候着今年最后的一点时光，就此成为往后的回忆。。。</p>
<p><img src="/assets/articleImg/2015-12-31-bagong.jpg" alt=""></p>
<div class="caption">『执着忠厚的八公.』</div>

<p>总之，好好奋斗吧……</p>
<p><em>我要稳稳的幸福<br>能抵挡失落的痛楚<br>一个人的路途<br>也不会孤独</em>  </p>
<p>2016年，祝大家新年快乐！同时也希望自己在新的一年能有一个好的开始！</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>就用这首《稳稳地幸福》作为开场白吧，希望也有一种稳稳的幸福！</p>
<p><em>有一天，我发现自怜资格都已没有<br>只剩下不知疲倦的肩膀<br>担负着简单的满足<br>有一天，开始从平淡日子感受快乐<br>看到了明明白白的远方<br>我要的幸福……</em> </p>]]>
    
    </summary>
    
      <category term="总结" scheme="http://csuldw.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="总结" scheme="http://csuldw.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[25个Java机器学习工具&库(译)]]></title>
    <link href="http://csuldw.github.io/2015/12/25/2015-12-25-25-Java-Machine-Learning-Tools-&-Libraries/"/>
    <id>http://csuldw.github.io/2015/12/25/2015-12-25-25-Java-Machine-Learning-Tools-&-Libraries/</id>
    <published>2015-12-25T14:24:00.000Z</published>
    <updated>2016-03-08T09:04:26.439Z</updated>
    <content type="html"><![CDATA[<p>本列表总结了25个Java机器学习工具&amp;库：</p>
<ul>
<li>原文地址：<a href="http://bigdataanalyticsnews.com/25-java-machine-learning-tools-libraries/" target="_blank" rel="external">25 Java Machine Learning Tools &amp; Libraries</a></li>
<li>CSDN译文链接：<a href="http://www.csdn.net/article/2015-12-25/2826560" target="_blank" rel="external">http://www.csdn.net/article/2015-12-25/2826560</a></li>
</ul>
<a id="more"></a>
<p>1.<a href="http://www.cs.waikato.ac.nz/ml/weka/" target="_blank" rel="external">Weka</a>集成了数据挖掘工作的机器学习算法。这些算法可以直接应用于一个数据集上或者你可以自己编写代码来调用。Weka包括一系列的工具，如数据预处理、分类、回归、聚类、关联规则以及可视化。</p>
<p>2.<a href="http://moa.cms.waikato.ac.nz/" target="_blank" rel="external">Massive Online Analysis</a>（MOA）是一个面向数据流挖掘的流行开源框架，有着非常活跃的成长社区。它包括一系列的机器学习算法（分类、回归、聚类、异常检测、概念漂移检测和推荐系统）和评估工具。关联了WEKA项目，MOA也是用Java编写的，其扩展性更强。</p>
<p>3.<a href="http://meka.sourceforge.net/" target="_blank" rel="external">MEKA</a>项目提供了一个面向多标签学习和评价方法的开源实现。在多标签分类中，我们要预测每个输入实例的多个输出变量。这与“普通”情况下只涉及一个单一目标变量的情形不同。此外，MEKA基于WEKA的机器学习工具包。</p>
<p>4.<a href="https://adams.cms.waikato.ac.nz/" target="_blank" rel="external">Advanced Data mining And Machine learning System</a>（ADAMS）是一种新型的柔性工作流引擎，旨在迅速建立并保持真实世界的复杂知识流，它是基于GPLv3发行的。</p>
<p>5.<a href="http://elki.dbs.ifi.lmu.de/" target="_blank" rel="external">Environment for Developing KDD-Applications Supported by Index-Structure</a>（ELKI）是一款基于Java的开源（AGPLv3）数据挖掘软件。ELKI主要集中于算法研究，重点研究聚类分析中的无监督方法和异常检测。</p>
<p>6.<a href="http://mallet.cs.umass.edu/" target="_blank" rel="external">Mallet</a>是一个基于Java的面向文本文件的机器学习工具包。Mallet支持分类算法，如最大熵、朴素贝叶斯和决策树分类。</p>
<p>7.<a href="http://www.heatonresearch.com/encog" target="_blank" rel="external">Encog</a>是一个先进的机器学习框架，集成了支持向量机（SVM）、人工神经网络、遗传算法、贝叶斯网络、隐马尔可夫模型（HMM）、遗传编程和遗传算法。</p>
<p>8.<a href="http://www.datumbox.com/" target="_blank" rel="external">Datumbox</a>机器学习框架是一个用Java编写的开源框架，允许快速地开发机器学习和统计应用。该框架的核心重点包括大量的机器学习算法以及统计测试，能够处理中等规模的数据集。</p>
<p>9.<a href="http://deeplearning4j.org/" target="_blank" rel="external">Deeplearning4j</a>是使用Java和Scala编写的第一个商业级的、开源的、分布式深入学习库。其设计的目的是用于商业环境中，而不是作为一个研究工具。</p>
<p>10.<a href="http://mahout.apache.org/" target="_blank" rel="external">Mahout</a>是一个内置算法的机器学习框架。Mahout-Samsara帮助人们创建他们自己的数学，并提供了一些现成的算法实现。</p>
<p>11<a href="https://rapidminer.com/" target="_blank" rel="external">Rapid Miner</a>是德国多特蒙特技术大学开发的。它为开发者开发应用程序提供了一个GUI（图形用户界面）和Java API。它还提供了一些机器学习算法，用来做数据处理、可视化以及建模。</p>
<p>12.<a href="http://samoa.incubator.apache.org/" target="_blank" rel="external">Apache SAMOA</a>是一个机器学习（ML）框架，内嵌面向分布式流ML算法的编程抽象，并且允许在没有直接处理底层分布式流处理引擎（DSPEe，如Apache Storm、Apache S4和Apache samza）复杂性的情况下，开发新的ML算法。用户可以开发分布式流ML算法，而且可以在多个DSPEs上执行。</p>
<p>13.<a href="http://neuroph.sourceforge.net/" target="_blank" rel="external">Neuroph</a>通过提供支持创建、训练和保存神经网络的Java网络库和GUI工具，简化了神经网络开发。</p>
<p>14.<a href="http://oryx.io/" target="_blank" rel="external">Oryx 2</a>是一个建立在Apache Spark和Apache Kafka的Lambda架构实现，但随着实时大规模机器学习而逐渐开始专业化。这是一个用于构建应用程序的框架，但也包括打包，以及面向协同过滤、分类、回归和聚类的端到端的应用程序。</p>
<p>15.<a href="http://nlp.stanford.edu/software/classifier.shtml" target="_blank" rel="external">Stanford Classifier</a>是一个机器学习工具，它可以将数据项归置到一个类别。一个概率分类器，比如这个，它可以对一个数据项给出类分配的概率分布。该软件是最大熵分类器的一个Java实现。</p>
<p>16<a href="http://www.cortical.io/" target="_blank" rel="external">io</a>是一个Retina API，有着快速精确的类似大脑的自然语言处理算法。</p>
<p>17.<a href="https://github.com/EdwardRaff/JSAT/tree/master" target="_blank" rel="external">JSAT</a>是一个快速入门的机器学习库。该库是我在业余时间开发的，基于GPL3发行的。库中的一部分内容可自主学习，例如所有的代码都是独立的。JSAT没有外部依赖，而且是纯Java编写的。</p>
<p>18.<a href="http://nd4j.org/" target="_blank" rel="external">N-Dimensional Arrays for Java(ND4J)</a>是一个用于JVM的科学计算库。它们是用来在生产环境中使用的，这表明例程的设计是以最小的内存需求来运行的。</p>
<p>19.<a href="https://www.openhub.net/p/8582" target="_blank" rel="external">Java Machine Learning Library</a>（Java机器学习库）是一系列机器学习算法的相关实现。这些算法，无论是源代码还是文档，都编写的很出色。其主要语言是Java。</p>
<p>20.<a href="http://java-ml.sourceforge.net/" target="_blank" rel="external">Java-ML</a>是一个使用Java编写的一系列机器学习算法的Java API。它只提供了一个标准的算法接口。</p>
<p>21.<a href="http://spark.apache.org/mllib/" target="_blank" rel="external">MLlib(Spark)</a> 是Apache Spark的可扩展机器学习库。虽然是Java，但该库与平台还支持Java，Scala和Python绑定。此库是最新的，并且算法很多。</p>
<p>22.<a href="https://github.com/h2oai/h2o-3" target="_blank" rel="external">H2O</a>是用于智能应用的机器学习API。它在大数据上对统计学、机器学习和数学进行了规模化。H2O可扩展，开发者可以在核心部分使用简单的数学知识。</p>
<p>23.<a href="https://github.com/WalnutiQ/wAlnut" target="_blank" rel="external">WalnutiQ</a>是人脑部分面向对象模型，有着理论常用的学习算法（正在向简单强烈的情感人工智能模型方向研究）。</p>
<p>24.<a href="http://sourceforge.net/p/lemur/wiki/RankLib/" target="_blank" rel="external">RankLib</a>是一个排名学习算法库。目前已经实现八种流行的算法。</p>
<p>25.<a href="https://github.com/numenta/htm.java" target="_blank" rel="external">htm.java</a>（基于Java的Hierarchical Temporal Memory算法实现）是一个面向智能计算的Numenta平台的Java接口。<a href="http://www.demnag.com/b/java-machine-learning-tools-libraries-cm570/" target="_blank" rel="external">源码</a></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>本列表总结了25个Java机器学习工具&amp;库：</p>
<ul>
<li>原文地址：<a href="http://bigdataanalyticsnews.com/25-java-machine-learning-tools-libraries/">25 Java Machine Learning Tools &amp; Libraries</a></li>
<li>CSDN译文链接：<a href="http://www.csdn.net/article/2015-12-25/2826560">http://www.csdn.net/article/2015-12-25/2826560</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="框架&amp;库" scheme="http://csuldw.github.io/tags/%E6%A1%86%E6%9E%B6-%E5%BA%93/"/>
    
      <category term="译文" scheme="http://csuldw.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeetCode题解目录[待更新]]]></title>
    <link href="http://csuldw.github.io/2015/12/12/2015-12-12-LeetCode-ans/"/>
    <id>http://csuldw.github.io/2015/12/12/2015-12-12-LeetCode-ans/</id>
    <published>2015-12-11T16:00:00.000Z</published>
    <updated>2016-03-24T03:04:53.331Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://www.csuldw.com/2015/12/12/2015-12-12-LeetCode-ans/" target="_blank" rel="external">http://www.csuldw.com/2015/12/12/2015-12-12-LeetCode-ans/</a></p>
<p>本文是先前做LeetCode时的题解目录，代码有C++编写的，也有python编写的【内容待更新】。</p>
<p>注：目录是使用python编码排序的，非手工排版。</p>
<p><img src="/assets/articleImg/2015-12-12-leetcode.png" alt="leetcode"></p>
<a id="more"></a> 
<p><a target="black" href="http://www.csuldw.com/leetcode/LeetCode[155]-Min Stack.html">LeetCode[155]-Min Stack</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[100]-Same Tree.html">Leetcode[100]-Same Tree</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[101]-Symmetric Tree.html">Leetcode[101]-Symmetric Tree</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[102]-Binary Tree Level Order Traversal.html">Leetcode[102]-Binary Tree Level Order Traversal</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[103]-Binary Tree Zigzag Level Order Traversal.html">Leetcode[103]-Binary Tree Zigzag Level Order Traversal</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[104]-Maximum Depth of Binary Tree.html">Leetcode[104]-Maximum Depth of Binary Tree</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[107]-Binary Tree Level Order Traversal II.html">Leetcode[107]-Binary Tree Level Order Traversal II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[110]-Balanced Binary Tree.html">Leetcode[110]-Balanced Binary Tree</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[111]-Minimum Depth of Binary Tree.html">Leetcode[111]-Minimum Depth of Binary Tree</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[113]-Path Sum II.html">Leetcode[113]-Path Sum II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[114]-Flatten Binary Tree to Linked List.html">Leetcode[114]-Flatten Binary Tree to Linked List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[118]-Pascal" s="" triangle.html'="">Leetcode[118]-Pascal's Triangle</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[119]-Pascal" s="" triangle="" ii.html'="">Leetcode[119]-Pascal's Triangle II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[125]-Valid Palindrome.html">Leetcode[125]-Valid Palindrome</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[128]-Longest Consecutive Sequence.html">Leetcode[128]-Longest Consecutive Sequence</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[129]-Sum Root to Leaf Numbers.html">Leetcode[129]-Sum Root to Leaf Numbers</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[12]-Integer to Roman+++.html">Leetcode[12]-Integer to Roman+++</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[136]-Single Number.html">Leetcode[136]-Single Number</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[137]-Single Number II.html">Leetcode[137]-Single Number II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[13]-Roman to Integer+++.html">Leetcode[13]-Roman to Integer+++</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[141]-Linked List Cycle.html">Leetcode[141]-Linked List Cycle</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[143]-Reorder List.html">Leetcode[143]-Reorder List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[144]-Binary Tree Preorder Traversal.html">Leetcode[144]-Binary Tree Preorder Traversal</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[145]-Binary Tree Postorder Traversal.html">Leetcode[145]-Binary Tree Postorder Traversal</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[147]-Insertion Sort List.html">Leetcode[147]-Insertion Sort List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[148]-Sort List.html">Leetcode[148]-Sort List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[153]-Find Minimum in Rotated Sorted Array.html">Leetcode[153]-Find Minimum in Rotated Sorted Array</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[154]-Find Minimum in Rotated Sorted Array II.html">Leetcode[154]-Find Minimum in Rotated Sorted Array II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[15]-3Sum.html">Leetcode[15]-3Sum</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[162]-Find Peak Element.html">Leetcode[162]-Find Peak Element</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[169]-Majority Element.html">Leetcode[169]-Majority Element</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[173]-Binary Search Tree Iterator.html">Leetcode[173]-Binary Search Tree Iterator</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[189]-Rotate Array.html">Leetcode[189]-Rotate Array</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[18]-4Sum.html">Leetcode[18]-4Sum</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[191]-Number of Bits.html">Leetcode[191]-Number of Bits</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[198]-House Robber.html">Leetcode[198]-House Robber</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[19]-Remove Nth Node From End of List.html">Leetcode[19]-Remove Nth Node From End of List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[1]-Two Sum.html">Leetcode[1]-Two Sum</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[202]-Happy Number.html">Leetcode[202]-Happy Number</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[203]-Remove Linked List Elements.html">Leetcode[203]-Remove Linked List Elements</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[206]-Reverse Linked List.html">Leetcode[206]-Reverse Linked List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[20]-Valid Parentheses.html">Leetcode[20]-Valid Parentheses</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[215]-Kth Largest Element in an Array.html">Leetcode[215]-Kth Largest Element in an Array</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[217]-Contains Duplicate.html">Leetcode[217]-Contains Duplicate</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[219]-Contains Duplicate II.html">Leetcode[219]-Contains Duplicate II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[21]-Merge Two Sorted Lists.html">Leetcode[21]-Merge Two Sorted Lists</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[222]-Count Complete Tree Nodes.html">Leetcode[222]-Count Complete Tree Nodes</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[226]-Invert Binary Tree.html">Leetcode[226]-Invert Binary Tree</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[231]-Power of Two.html">Leetcode[231]-Power of Two</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[237]-Delete Node in a Linked List.html">Leetcode[237]-Delete Node in a Linked List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[242]-Valid Anagram.html">Leetcode[242]-Valid Anagram</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[258]-Add Digits.html">Leetcode[258]-Add Digits</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[260]-Single Number III.html">Leetcode[260]-Single Number III</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[263]-Ugly Number++.html">Leetcode[263]-Ugly Number++</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[26]-Remove Duplicates from Sorted Array.html">Leetcode[26]-Remove Duplicates from Sorted Array</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[27]-Remove Element.html">Leetcode[27]-Remove Element</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[283]-Move Zeroes.html">Leetcode[283]-Move Zeroes</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[292]-Nim Game.html">Leetcode[292]-Nim Game</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[300]-Longest Increasing Subsequence.html">Leetcode[300]-Longest Increasing Subsequence</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[33]-Search in Rotated Sorted Array.html">Leetcode[33]-Search in Rotated Sorted Array</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[35]-Search Insert Position.html">Leetcode[35]-Search Insert Position</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[36]-Valid Sudoku.html">Leetcode[36]-Valid Sudoku</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[4]-Median of Two Sorted Arrays.html">Leetcode[4]-Median of Two Sorted Arrays</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[53]-Maximum Subarray.html">Leetcode[53]-Maximum Subarray</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[62]-Unique Paths.html">Leetcode[62]-Unique Paths</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[63]-Unique Paths II.html">Leetcode[63]-Unique Paths II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[66]-Plus One.html">Leetcode[66]-Plus One</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[70]-Climbing Stairs.html">Leetcode[70]-Climbing Stairs</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[74]-Search a 2D Matrix.html">Leetcode[74]-Search a 2D Matrix</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[7]-Reverse Integer.html">Leetcode[7]-Reverse Integer</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[81]-Search for a Range.html">Leetcode[81]-Search for a Range</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[82]-Remove Duplicates from Sorted List II.html">Leetcode[82]-Remove Duplicates from Sorted List II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[83]-Remove Duplicates from Sorted List.html">Leetcode[83]-Remove Duplicates from Sorted List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[86]-Partition List.html">Leetcode[86]-Partition List</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[88]-Merge Sorted Array.html">Leetcode[88]-Merge Sorted Array</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[92]-Reverse Linked List II.html">Leetcode[92]-Reverse Linked List II</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[94]-Binary Tree Inorder Traversal.html">Leetcode[94]-Binary Tree Inorder Traversal</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[96]-Unique Binary Search Trees.html">Leetcode[96]-Unique Binary Search Trees</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[98]-Validate Binary Search Tree.html">Leetcode[98]-Validate Binary Search Tree</a><br><a target="black" href="http://www.csuldw.com/leetcode/Leetcode[9]-Palindrome Number.html">Leetcode[9]-Palindrome Number</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="http://www.csuldw.com/2015/12/12/2015-12-12-LeetCode-ans/">http://www.csuldw.com/2015/12/12/2015-12-12-LeetCode-ans/</a></p>
<p>本文是先前做LeetCode时的题解目录，代码有C++编写的，也有python编写的【内容待更新】。</p>
<p>注：目录是使用python编码排序的，非手工排版。</p>
<p><img src="/assets/articleImg/2015-12-12-leetcode.png" alt="leetcode"></p>]]>
    
    </summary>
    
      <category term="LeetCode" scheme="http://csuldw.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://csuldw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法与数据结构" scheme="http://csuldw.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python笔记-几种取整方式]]></title>
    <link href="http://csuldw.github.io/2015/12/04/2015-12-04-Python-Round/"/>
    <id>http://csuldw.github.io/2015/12/04/2015-12-04-Python-Round/</id>
    <published>2015-12-04T04:12:00.000Z</published>
    <updated>2016-03-08T09:02:37.645Z</updated>
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>　　在处理数据的时候，碰到了一个问题，就是取整方式！比如给定一个数值型列表，我需要分别获取它位置为长度的0%,25%,50%,75%,100%处的几个数字。但Python自带的<code>int</code>是向下取整，如果数字长度是5，理论上这五个数字分别对应0%,25%,50%,75%,100%的位置，但使用<code>int</code>，结果却并不是入次。比如当<code>5*0.75</code>时,如果加上<code>int(5*0.75)</code>，就等于<code>3</code>，而我想要的应该是4，显然不是我想要的，所以这里需要用到向上取整方式。因此，顺便总结了一下Python的几种取整方式。</p>
<a id="more"></a>
<h2 id="取整方式">取整方式</h2><p>　　下面介绍几种常用的取整方法，包括向下取整、四舍五入、向上取整。</p>
<h3 id="（1）向下取整">（1）向下取整</h3><p>　　向下取整很简单，直接使用int()函数即可，如下代码(Python 2.7.5 IDLE)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">a</span> = <span class="number">3.75</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">int</span><span class="params">(a)</span></span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="（2）四舍五入">（2）四舍五入</h3><p>　　第二种就是对数字进行四舍五入，具体的看下面的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; a=<span class="number">3.25</span>;b=<span class="number">3.75</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; round(a);round(b)</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="number">4.0</span></span><br></pre></td></tr></table></figure>
<h2 id="（3)向上取整">（3)向上取整</h2><p>　　但三种，就是向上取整，也就是我这次数据处理中需要的，由于之前没在Python中用到过，所以不太熟悉，其实Python的math中就带了向上取整的函数，即<code>ceil</code>方法，专门用于向上取整，实例如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">import</span> <span class="tag">math</span></span><br><span class="line">&gt;&gt;&gt; <span class="tag">math</span><span class="class">.ceil</span>(3<span class="class">.25</span>)</span><br><span class="line">4<span class="class">.0</span></span><br><span class="line">&gt;&gt;&gt; <span class="tag">math</span><span class="class">.ceil</span>(3<span class="class">.75</span>)</span><br><span class="line">4<span class="class">.0</span></span><br></pre></td></tr></table></figure>
<p>好了，取整方式，大概就是这三种，介绍到此吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="背景">背景</h2><p>　　在处理数据的时候，碰到了一个问题，就是取整方式！比如给定一个数值型列表，我需要分别获取它位置为长度的0%,25%,50%,75%,100%处的几个数字。但Python自带的<code>int</code>是向下取整，如果数字长度是5，理论上这五个数字分别对应0%,25%,50%,75%,100%的位置，但使用<code>int</code>，结果却并不是入次。比如当<code>5*0.75</code>时,如果加上<code>int(5*0.75)</code>，就等于<code>3</code>，而我想要的应该是4，显然不是我想要的，所以这里需要用到向上取整方式。因此，顺便总结了一下Python的几种取整方式。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python笔记-均值列表]]></title>
    <link href="http://csuldw.github.io/2015/12/04/2015-12-04-Python-two-list-add-item-add-item/"/>
    <id>http://csuldw.github.io/2015/12/04/2015-12-04-Python-two-list-add-item-add-item/</id>
    <published>2015-12-04T01:03:00.000Z</published>
    <updated>2016-03-13T05:54:06.975Z</updated>
    <content type="html"><![CDATA[<p>一个小小的实例，做个小笔记！</p>
<p>比如有三个列表，列表元素均为数值型，三个列表的长度都一样，现在我想要求这三个列表的均值，即求一个均值列表，对应元素为上述三个列表对应元素的均值。</p>
<a id="more"></a>
<p>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">meanMethod</span><span class="params">(one,two,three)</span>:</span></span><br><span class="line">    comb = zip(one,two,three)</span><br><span class="line">    <span class="keyword">return</span> [float(i+j+k)/<span class="number">3</span> <span class="keyword">for</span> i,j,k <span class="keyword">in</span> comb]</span><br></pre></td></tr></table></figure>
<p>第二行使用的是zip函数，先将三个列表合并起来，zip函数返回的是一个列表，但里面的元素是一个元组。</p>
<p>第三行是列表推导式，计算comb每个元组的均值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个小小的实例，做个小笔记！</p>
<p>比如有三个列表，列表元素均为数值型，三个列表的长度都一样，现在我想要求这三个列表的均值，即求一个均值列表，对应元素为上述三个列表对应元素的均值。</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EM-最大期望算法]]></title>
    <link href="http://csuldw.github.io/2015/12/02/2015-12-02-EM-algorithms/"/>
    <id>http://csuldw.github.io/2015/12/02/2015-12-02-EM-algorithms/</id>
    <published>2015-12-02T02:24:00.000Z</published>
    <updated>2016-03-14T07:40:34.143Z</updated>
    <content type="html"><![CDATA[<p>对于EM算法，一直都是云里雾里琢磨不清。所以，今天索性就下个决定，不搞懂它，善不罢休。通过今天的学习，加上之前的基础，EM算法终于算是搞明白了。果真是做事不冲动点，真的很难有结果。下面，我打算将EM算法的整个推导过程通俗地来讲解一遍，虽然网上也有很多EM算法的理论知识讲解，但我觉得只有自己再来整理并总结一遍，才能理解的更加透彻，这样收获的知识也会更多。</p>
<p>根据自己的博文写作风格，首先来看一张EM算法的聚类图，来自wikipedia，效果直观点。</p>
<p><img src="/assets/articleImg/2015-12-02-EM_Clustering_of_Old_Faithful_data.gif" alt=""></p>
<a id="more"></a>
<p>期望最大算法是一种从不完全数据或有数据丢失的数据集（存在隐含变量）中求解概率模型参数的最大似然估计方法。EM算法是机器学习十大算法之一，之所以被纳入十大算法之中，是因为它解决了其它算法解决不了的问题或者效果更佳。下面先来说说它的定义吧。</p>
<h2 id="一、定义">一、定义</h2><p>EM算法，全称Expectation Maximization Algorithm，译作最大期望化算法或期望最大算法，它是一种迭代算法，用于含有隐变量（hidden variable）的概率参数模型的最大似然估计或极大后验概率估计。</p>
<h2 id="二、Jensen不等式">二、Jensen不等式</h2><p>在完善EM算法之前，首先来了解下Jensen不等式，因为在EM算法的推导过程中会用到。</p>
<p>Jensen不等式在优化理论中大量用到，首先来回顾下凸函数和凹函数的定义。假设f是定义域为实数的函数，如果对于所有的x，f(x)的二阶导数大于等于0，那么f是凸函数。当x是向量时，如果hessian矩阵H是半正定（即H&gt;=0），那么f是凸函数。如果，f(x)的二阶导数小于0或者H&gt;0，那么f就是凹函数。</p>
<p>Jensen不等式描述如下：</p>
<ul>
<li>如果f是凸函数，X是随机变量，则E[f(X)]&gt;=f(E[X])，特别地，如果f是严格凸函数，E[f(X)]&gt;=f(E[X])，那么当且仅当p(x=E[X])=1时（也就是说X是常量），E[f(x)]=f(E[X])；</li>
<li>如果f是凹函数，X是随机变量，则f(E[X])&lt;=E[f(X)].当f是（严格）凹函数当且仅当-f是（严格）凸函数。</li>
</ul>
<p>通过下面这张图，可以加深印象：</p>
<p><img src="/assets/articleImg/2015-12-02-Jensen-inequality.png" alt=""></p>
<p>图中，实线f是凸函数，X是随机变量，有0.5的概率是a，有0.5的概率是b。X的期望值就是a和b的中值了，图中可以看到E[f(X)]&gt;=f(E[X])成立。</p>
<h2 id="三、EM算法">三、EM算法</h2><p>EM算法推导过程中，会使用到极大似然估计法估计参数，所以，首先给出一个求最大似然函数估计值的一般步骤：</p>
<ul>
<li>（1）写出似然函数；</li>
<li>（2）对似然函数取对数，并整理；</li>
<li>（3）求导数，令导数为0，得到似然方程；</li>
<li>（4）解似然方程，得到的参数即为所求；</li>
</ul>
<p>关于极大似然估计的实例，就不在提及了，下面介绍EM算法。</p>
<p>给定m个训练样本{$x^{(1)},…,x^{(m)}$},样本间相互独立，根据分布，我们可以得到一个似然函数：</p>
<p><img src="/assets/articleImg/2015-12-02-gs1.png" alt=""></p>
<p>第一步是对极大似然函数取对数，第二步是对每个样本实例的每个可能类别<code>z</code>求联合分布概率和。但直接来求这个参数$\theta$,可能很困难，因为存在一个隐含类别变量<code>z</code>。如果这个<code>z</code>是个已知的数，那么我们就可以使用极大似然估计来估算。所以，在这种情形下，EM算法就派上用场了。</p>
<p>EM是一种解决存在隐含变量优化问题的有效方法。既然不能直接最大化$l(\theta)$，我们可以不断地建立$l$的下界（E步），然后优化下界（M步）。依次迭代，直至收敛。</p>
<hr>
<p>下面简单的描述下EM的算法思想：</p>
<font color="#1986C7"><strong>EM算法通过引入隐含变量,然后使用MLE（极大似然估计）进行迭代求解参数</strong></font>。假设引入隐含变量后有两个参数，EM算法会先固定第一个变量，然后使用MLE计算第二个变量值，然后通过固定第二个变量，再使用MLE估测第一个变量值，依次迭代，直至收敛。关于收敛终止条件，后面会提到。<br><br>EM算法分为两步，E-Step和M-Step。<br><br>- E-Step：通过observed data和现有模型估计参数估计值 missing data；<br>- M-Step：假设missing data已知的情况下，最大化似然函数。<br><br><strong>由于算法保证了每次迭代之后，似然函数都会增加，所以函数最终会收敛(最后有推到)</strong>。<br><br>—-<br><br>## 四、EM算法推导<br><br>下面来推导EM算法：<br><br>对于每个实例$i$,用$Q_{i}$表示样本实例隐含变量<code>z</code>的某种分布，$Q_i$满足条件（$\sum_zQ_i(z)=1,Q_i(z)&gt;=0$） ,如果$Q_i$是连续性的，则$Q_i$表示概率密度函数，需要将求和符号换成积分符号。<br><br>对于前面的式子，做如下变换：<br><br><img src="/assets/articleImg/2015-12-02-gs2.png" alt=""><br><br>上面三个式子中，式（1）和式（2）比较容易理解，式（1）是根据联合概率密度下某个变量的边缘密度函数来求解的，这里把z当做是随机变量。对每一个样本i的所有可能类别z求等式右边的联合概率密度函数和，也就得到等式左边为随机变量x的边缘概率密度。由于对式（1）直接求导非常困难，所以将其变换为式（2），分子分母都乘以一个相等的函数。而在式（2）变为式（3）的过程，采用了上面提到的<strong>Jensen不等式</strong>。下面来仔细分析下：<br><br><font color="red">把（1）式中的log函数体看成是一个整体，由于log(x)的二阶导数为$-\frac{1}{x^2}$,小于0，为凹函数。所以使用Jensen不等式时，应该使用第二条规则：<strong>f(E[X])&gt;=E[f(x)]</strong>。</font>

<p>还记得当年读大学的时候，概率论中的随机变量的期望计算方法么，如下所示：</p>
<p><img src="/assets/articleImg/2015-12-02-p2.png" alt=""></p>
<p>因此，结合上面的知识点，我们可以把(2)式当中的$Q_i(z^{(i)})$看成相应的概率$p_i$，把$\frac{p(x^{i},z^{(i)};\theta)}{Q_i(z^{(i)})}$看作是$z^{(i)}$的函数$g(z)$，</p>
<p>类似地，根据期望公式$E(x)=\sum x*p(x)$可以得到：</p>
<p><img src="/assets/articleImg/2015-12-02-gs3.png" alt=""></p>
<p>其实就是$\frac{p(x^{i},z^{(i)};\theta)}{Q_i(z^{(i)})}$的期望，再根据凹函数对应的Jensen不等式性质：</p>
<p><img src="/assets/articleImg/2015-12-02-gs4.png" alt=""></p>
<p>因此便得到了公式（3）。</p>
<p>OK，现在我们知道上面的式子（2）和式子（3）两个不等式可以写成：似然函数L(θ)&gt;=J(z,Q)的形式（z为隐含变量），那么我们可以通过不断的最大化这个下界J，来使得L(θ)不断提高，最终达到它的最大值。用下面这个图形象的说明下：</p>
<p><img src="/assets/articleImg/2015-12-02-p3.png" alt=""></p>
<p>这里来说下上图的内在含义，<font color="#1986c7"><strong>首先我们固定θ，调整Q(z)使下界J(z,Q)上升至与L(θ)在此点θ处相等（绿色曲线到蓝色曲线），然后固定Q(z)，调整θ使下界J(z,Q)达到最大值（θt到θt+1），然后再固定θ，调整Q(z)……直到收敛到似然函数L(θ)的最大值处的θ</strong></font>。<font color="red">这里有两个问题：①什么时候下界J(z,Q)与L(θ)在此点θ处相等？②为什么一定会收敛？</font></p>
<p>首先来解决第一个问题（<del><font color="red">①什么时候下界J(z,Q)与L(θ)在此点θ处相等？</font></del>）。在Jensen不等式中说到，当自变量X=E(X)时，即为常数的时候，等式成立。而在这里，为：</p>
<p><img src="/assets/articleImg/2015-12-02-gs5.png" alt=""></p>
<p>对该式做个变换，取所有的z，得到</p>
<p>$$\sum_z{p(x^{i},z^{(i)};\theta)}=\sum_z{Q_i(z^{(i)})}c$$</p>
<p>因为前面提到$\sum_zQ_i(z)=1$（因为概率之和为1），所以可以推导出：</p>
<p>$$\sum_z{p(x^{i},z^{(i)};\theta)}=c$$</p>
<p>因此也就可以得到下面的式子：</p>
<p><img src="/assets/articleImg/2015-12-02-gs6.png" alt=""></p>
<p>至此，我们推出了在固定参数θ后，使下界拉升的Q(z)的计算公式就是后验概率（条件概率），解决了Q(z)如何选择的问题。这一步就是E步，建立L(θ)的下界。接下来的M步，就是在给定Q(z)后，调整θ，去极大化L(θ)的下界J（在固定Q(z)后，下界还可以调整的更大）。所以，到了这一步，来总结下使用EM算法的步骤：</p>
<p>第一步，初始化分布参数θ；<br>第二步，重复以下步骤直到收敛：</p>
<ul>
<li>E步骤：根据参数的初始值或上一次迭代的模型参数来计算出的隐性变量的后验概率（条件概率），其实就是隐性变量的期望值。作为隐藏变量的现有估计值：</li>
</ul>
<p><img src="/assets/articleImg/2015-12-02-gs7.png" alt=""></p>
<ul>
<li>M步骤：最大化似然函数从而获得新的参数值：</li>
</ul>
<p><img src="/assets/articleImg/2015-12-02-gs8.png" alt=""></p>
<p>通过不断的迭代，然后就可以得到使似然函数L(θ)最大化的参数θ了。</p>
<p>到了这一步，那么问题又就来了，该怎么确保EM收敛呢？(<font color="red"><del>②为什么一定会收敛？</del></font>)下面来证明下.</p>
<p>假定$\theta^{(t)}$和$\theta^{(t+1)}$是EM第t次和t+1次迭代后的结果。如果我们证明了$l(\theta^{(t)})&lt;=l(\theta^{(t+1)})$，也就是说极大似然估计单调增加，那么最终我们会到达最大似然估计的最大值。下面来证明，选定$\theta^{(t)}$之后，我们得到E步：</p>
<p><img src="/assets/articleImg/2015-12-02-gs9.png" alt=""></p>
<p>这一步保证了在给定$\theta^{(t)}$时，Jensen不等式中的等式成立，也就是</p>
<p><img src="/assets/articleImg/2015-12-02-gs10.png" alt=""></p>
<p>然后进行M步，固定$Q_i^{(t)}(z^{(i)})$,并将$\theta^{(t)}$试作变量，对上面的式子求导，得到$\theta^{(t+1)}$,这样经过一些推导会有以下式子成立：</p>
<p><img src="/assets/articleImg/2015-12-02-gs11.png" alt=""></p>
<p>在公式（4）中，得到$\theta^{(t+1)}$,只是最大化$l(\theta^{(t)})$,也就是$l(\theta^{(t+1)})$的下界，并没有使等式成立，等式成立只有是在固定$\theta$，并按E步得到$Q_i$时才能成立。</p>
<p>这样就证明了$l(\theta)$会单调增加。如果要判断收敛情况，可以这样来做：<font color="#1986C7"><strong>一种收敛方法是$l(\theta)$不再变化，还有一种就是变化幅度很小,即根据$l(\theta)^{(t+1)}-l(\theta)^{(t)}$的值来决定</strong></font>。</p>
<p>EM算法类似于坐标上生法（coordinate ascent）：E步：固定θ，优化Q；M步：固定Q，优化θ；交替将极值推向最大。</p>
<h2 id="五、应用">五、应用</h2><ul>
<li><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006924.html" target="_blank" rel="external">混合高斯模型（Mixtures of Gaussians）</a></li>
<li><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006910.html" target="_blank" rel="external">K-means聚类算法</a></li>
</ul>
<h2 id="六、References">六、References</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm" target="_blank" rel="external">wikipedia维基百科</a></li>
<li><a href="http://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="external">JerryLead博客-（EM算法）The EM Algorithm</a></li>
<li><a href="http://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="external">从最大似然到EM算法浅解</a></li>
<li><a href="http://blog.csdn.net/abcjennifer/article/details/8170378" target="_blank" rel="external">Rachel Zhang-EM算法原理</a></li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于EM算法，一直都是云里雾里琢磨不清。所以，今天索性就下个决定，不搞懂它，善不罢休。通过今天的学习，加上之前的基础，EM算法终于算是搞明白了。果真是做事不冲动点，真的很难有结果。下面，我打算将EM算法的整个推导过程通俗地来讲解一遍，虽然网上也有很多EM算法的理论知识讲解，但我觉得只有自己再来整理并总结一遍，才能理解的更加透彻，这样收获的知识也会更多。</p>
<p>根据自己的博文写作风格，首先来看一张EM算法的聚类图，来自wikipedia，效果直观点。</p>
<p><img src="/assets/articleImg/2015-12-02-EM_Clustering_of_Old_Faithful_data.gif" alt=""></p>]]>
    
    </summary>
    
      <category term="EM" scheme="http://csuldw.github.io/tags/EM/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[今日阅读]]></title>
    <link href="http://csuldw.github.io/2015/11/25/2015-11-25-Reading-Today/"/>
    <id>http://csuldw.github.io/2015/11/25/2015-11-25-Reading-Today/</id>
    <published>2015-11-25T13:24:00.000Z</published>
    <updated>2016-03-08T09:04:55.617Z</updated>
    <content type="html"><![CDATA[<p>【先给出一张数据科学家的日常工作流图】</p>
<p><img src="http://ww4.sinaimg.cn/large/637f3c58gw1eydjolk7mwj20gq09x76m.jpg" alt="data science work diagram"></p>
<a id="more"></a>
<hr>
<p>今天翻译了一篇CSDN给的译文，同时也审阅了一篇译文，对LR、DT、SVM又有了进一步的认识，下面附上两篇博文链接，另外加上一篇同一作者的博文。</p>
<ul>
<li><a href="http://www.edvancer.in/logistic-regression-vs-decision-trees-vs-svm-part1/" target="_blank" rel="external">Logistic Regression Vs Decision Trees Vs SVM: Part I</a></li>
<li><a href="http://www.edvancer.in/logistic-regression-vs-decision-trees-vs-svm-part2/" target="_blank" rel="external">Logistic Regression vs Decision Trees vs SVM: Part II</a></li>
<li><a href="http://www.edvancer.in/8-data-science-skills/" target="_blank" rel="external">8 must have data science skills</a></li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>【先给出一张数据科学家的日常工作流图】</p>
<p><img src="http://ww4.sinaimg.cn/large/637f3c58gw1eydjolk7mwj20gq09x76m.jpg" alt="data science work diagram"></p>]]>
    
    </summary>
    
      <category term="Data Science" scheme="http://csuldw.github.io/tags/Data-Science/"/>
    
      <category term="今日阅读" scheme="http://csuldw.github.io/categories/%E4%BB%8A%E6%97%A5%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法代码汇总]]></title>
    <link href="http://csuldw.github.io/2015/11/21/2015-11-21-machine-learning-algorithms/"/>
    <id>http://csuldw.github.io/2015/11/21/2015-11-21-machine-learning-algorithms/</id>
    <published>2015-11-21T02:24:00.000Z</published>
    <updated>2016-03-13T05:54:30.243Z</updated>
    <content type="html"><![CDATA[<p><br></p>
<p>【机器学习算法代码汇总-Python&amp;R】- <a link="http://csuldw.github.io/assets/pdf/Full-CheatSheet-on-Machine-Learning-Algorithms(Python-and-R-Codes).pdf" target="_black">PDF文件下载</a>.</p>
<p><img src="http://ww3.sinaimg.cn/large/637f3c58gw1ey8lm4rhn5j20s40fp466.jpg" alt="机器学习算法代码汇总1"></p>
<a id="more"></a>
<p><img src="http://ww3.sinaimg.cn/large/637f3c58gw1ey8lkrdcwlj20s93kl4qq.jpg" alt="机器学习算法代码汇总2"></p>
<p>原文链接：<a href="http://www.analyticsvidhya.com/blog/2015/09/full-cheatsheet-machine-learning-algorithms/" target="_blank" rel="external">点击这里</a>.</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p><br></p>
<p>【机器学习算法代码汇总-Python&amp;R】- <a link="http://csuldw.github.io/assets/pdf/Full-CheatSheet-on-Machine-Learning-Algorithms(Python-and-R-Codes).pdf"target="_black">PDF文件下载</a>.</p>
<p><img src="http://ww3.sinaimg.cn/large/637f3c58gw1ey8lm4rhn5j20s40fp466.jpg" alt="机器学习算法代码汇总1"></p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实验笔记[1]-DSSP文件提取序列]]></title>
    <link href="http://csuldw.github.io/2015/11/18/2015-11-18%20ExpNotes%5B1%5D-Extract%20protein%20sequences%20from%20a%20fasta%20file/"/>
    <id>http://csuldw.github.io/2015/11/18/2015-11-18 ExpNotes[1]-Extract protein sequences from a fasta file/</id>
    <published>2015-11-18T04:24:00.000Z</published>
    <updated>2016-03-08T08:54:38.237Z</updated>
    <content type="html"><![CDATA[<p><strong>提示：以下内容乃个人实验笔记！</strong></p>
<h3 id="功能描述">功能描述</h3><p>从格式化后的dssp文件<code>DSSP</code>（单一文件）中提取序列信息，要求输出的序列不含有<code>X</code>残基，并且序列最短长度<code>minlen</code>可人为指定，一般设置为<code>40</code>。</p>
<a id="more"></a>
<p><code>DSSP</code>文件格式Top10:</p>
<pre><code class="markdown">1A12        1       21     A     K                      0   0  172        0      172          0, 0.0         2,-1.9         0, 0.0         0, 0.0       0.000     360.0     360.0     360.0     129.7        9.7      -11.3       33.7
1A12        2       22     A     K            -         0   0  164        0      164          1,-0.1         2,-0.2         0, 0.0         0, 0.0      -0.433     360.0    -153.3     -64.1      85.0       10.1      -13.4       30.5
1A12        3       23     A     V            -         0   0   42        0       42         -2,-1.9         2,-0.2       114,-0.1       768,-0.1      -0.429       8.7    -128.1     -66.5     129.9       11.5      -10.5       28.4
1A12        4       24     A     K            -         0   0  130        0      130         -2,-0.2         2,-0.3       765,-0.1       113,-0.3      -0.476      21.9    -164.8     -79.9     149.3       10.9      -10.9       24.7
1A12        5       25     A     V            -         0   0   13        0       13        111,-2.8         2,-0.2        -2,-0.2       113,-0.2      -0.942       6.3    -177.4    -126.4     157.4       13.6      -10.6       22.1
1A12        6       26     A     S            -         0   0   20        0       20        719,-1.4         2,-0.3        -2,-0.3       720,-0.1      -0.694       8.2    -153.8    -133.2    -164.5       13.4      -10.1       18.3
1A12        7       27     A     H        >   -         0   0    2        0        2         -2,-0.2         3,-1.6       718,-0.1       721,-0.3      -0.944      32.3    -112.1    -169.7     155.9       15.9       -9.9       15.4
1A12        8       28     A     R      T 3  S+         0   0   53        0       53        718,-0.4       720,-0.3       716,-0.3       717,-0.1       0.690     115.2      60.4     -69.3     -20.9       16.0       -8.3       12.0
1A12        9       29     A     S      T 3  S+         0   0   34        0       34        146,-0.2        -1,-0.3       718,-0.1         2,-0.2       0.548      78.3     108.7     -77.8     -13.9       15.9      -11.8       10.5
1A12       10       30     A     H        <   -         0   0   22        0       22         -3,-1.6         2,-0.3       145,-0.1        93,-0.1      -0.516      67.8    -130.5     -73.7     135.3       12.6      -12.8       12.0
</code></pre>


<hr>
<h3 id="代码">代码</h3><p><code>generateSeqFromDSSP.py</code>文件如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="string">'''</span><br><span class="line">Parameters：</span><br><span class="line">    - dsspfile:	为格式过的DSSP文件</span><br><span class="line">    - foseq: 	为输出的序列文件</span><br><span class="line">    - fochain: 	输出的蛋白链文件</span><br><span class="line">    - minLen:  	最短的序列长度</span><br><span class="line">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSeqFromDSSP</span><span class="params">(dsspfile, foseq, fochain, minLen)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(dsspfile, <span class="string">'r'</span>) <span class="keyword">as</span> inputfile:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> foseq.strip():</span><br><span class="line">            foseq = <span class="string">'protein'</span>+ str(minLen) + <span class="string">'.dssp.seq'</span></span><br><span class="line">        outchain = open(fochain, <span class="string">'w'</span>)</span><br><span class="line">        <span class="keyword">with</span> open(foseq, <span class="string">'w'</span>) <span class="keyword">as</span> outputfile:</span><br><span class="line">            residue=[];Ntype=[]</span><br><span class="line">            preType=[];preRes=[]</span><br><span class="line">            firstline=[];secondline=[];content=<span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> eachline <span class="keyword">in</span> inputfile:</span><br><span class="line">                oneline = eachline.split(<span class="string">'\t'</span>) </span><br><span class="line">                residue = oneline[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> residue.strip(): </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                Ntype = oneline[<span class="number">3</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> Ntype.strip():</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> preRes!=residue:</span><br><span class="line">                    content = <span class="string">''</span>.join(firstline)+<span class="string">'\n'</span>+<span class="string">''</span>.join(secondline) +<span class="string">'\n'</span></span><br><span class="line">                    <span class="keyword">if</span> len(secondline)&gt;=int(minLen) <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">'X'</span> <span class="keyword">in</span> secondline:</span><br><span class="line">                        outchain.write(<span class="string">''</span>.join(firstline) + <span class="string">'\n'</span>)</span><br><span class="line">                        outputfile.write(content)</span><br><span class="line">                    firstline=[]</span><br><span class="line">                    firstline.append(<span class="string">'&gt;'</span> + residue + <span class="string">':'</span> + Ntype)</span><br><span class="line">                    secondline=[];secondline.append(oneline[<span class="number">4</span>].strip())</span><br><span class="line">                    preRes = residue;preType = Ntype</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> Ntype != preType:</span><br><span class="line">                    content = <span class="string">''</span>.join(firstline)+<span class="string">'\n'</span>+<span class="string">''</span>.join(secondline)+<span class="string">'\n'</span></span><br><span class="line">                    <span class="keyword">if</span> len(secondline)&gt;=int(minLen) <span class="keyword">and</span>  <span class="keyword">not</span> <span class="string">'X'</span> <span class="keyword">in</span> secondline:</span><br><span class="line">                        outchain.write(<span class="string">''</span>.join(firstline) + <span class="string">'\n'</span>)</span><br><span class="line">                        outputfile.write(content)</span><br><span class="line">                    firstline=[]</span><br><span class="line">                    firstline.append(<span class="string">'&gt;'</span> + residue + <span class="string">':'</span> + Ntype)</span><br><span class="line">                    secondline=[];secondline.append(oneline[<span class="number">4</span>].strip())</span><br><span class="line">                    preRes = residue;preType = Ntype</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#如果Ntype不为空，且等于preType</span></span><br><span class="line">                    secondline.append(oneline[<span class="number">4</span>].strip())</span><br><span class="line">            content = <span class="string">''</span>.join(firstline)+<span class="string">'\n'</span> + <span class="string">''</span>.join(secondline) +<span class="string">'\n'</span></span><br><span class="line">            <span class="comment">#选择长度大于40而且序列中不存在‘X’残基的序列</span></span><br><span class="line">            <span class="keyword">if</span> len(secondline) &gt;= int(minLen) <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">'X'</span> <span class="keyword">in</span> secondline:  </span><br><span class="line">                outchain.write(<span class="string">''</span>.join(firstline) + <span class="string">'\n'</span>)</span><br><span class="line">                outputfile.write(content)</span><br><span class="line">        outchain.close()</span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    os.chdir(<span class="string">"/ifs/home/liudiwei/DNA_BP/_data/Exp_DBPI/"</span>)</span><br><span class="line">    dsspfile = os.sys.argv[<span class="number">1</span>]</span><br><span class="line">    foseq = os.sys.argv[<span class="number">2</span>]</span><br><span class="line">    fochain = os.sys.argv[<span class="number">3</span>]</span><br><span class="line">    minlen = os.sys.argv[<span class="number">4</span>]</span><br><span class="line">    getSeqFromDSSP(dsspfile, foseq, fochain, minlen)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Test_sample">Test sample</h3><p>在Linux控制台中输入下面命令：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python generateSeqFromDSSP.py \</span><br><span class="line"><span class="regexp">/ifs/</span>home<span class="regexp">/liudiwei/</span>DNA_BP<span class="regexp">/_data/</span>Exp_DBPI<span class="regexp">/dssp_testset/</span>DSSP \</span><br><span class="line"><span class="regexp">/ifs/</span>home<span class="regexp">/liudiwei/</span>DNA_BP<span class="regexp">/_data/</span>Exp_DBPI<span class="regexp">/protein_test.seq \</span><br><span class="line">/i</span>fs<span class="regexp">/home/</span>liudiwei<span class="regexp">/DNA_BP/</span>_data<span class="regexp">/Exp_DBPI/</span>protein_test.chain \</span><br><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>输出文件：</p>
<p><code>protein_test.seq</code>格式Top10：</p>
<pre><code class="markdown">>1A12:A
KKVKVSHRSHSTEPGLVLTLGQGDVGQLGLGENVMERKKPALVSIPEDVVQAEAGGMHTVCLSKSGQVYSFGCNDEGALGRDTSVEGSEMVPGKVELQEKVVQVSAGDSHTAALTDDGRVFLWGSFRDNNGVIGLLEPMKKSMVPVQVQLDVPVVKVASGNDHLVMLTADGDLYTLGCGEQGQLGRVPELFANRGGRQGLERLLVPKCVMLKSRGSRGHVRFQDAFCGAYFTFAISHEGHVYGFGLSNYHQLGTPGTESCFIPQNLTSFKNSTKSWVGFSGGQHHTVCMDSEGKAYSLGRAEYGRLGLGEGAEEKSIPTLISRLPAVSSVACGASVGYAVTKDGRVFAWGMGTNYQLGTGQDEDAWSPVEMMGKQLENRVVLSVSSGGQHTVLLVKDKEQS
>1A12:B
KKVKVSHRSHSTEPGLVLTLGQGDVGQLGLGENVMERKKPALVSIPEDVVQAEAGGMHTVCLSKSGQVYSFGCNDEGALGRDTSVEGSEMVPGKVELQEKVVQVSAGDSHTAALTDDGRVFLWGSFRDNNGVIGLLEPMKKSMVPVQVQLDVPVVKVASGNDHLVMLTADGDLYTLGCGEQGQLGRVPELFANRGGRQGLERLLVPKCVMLKSRGSRGHVRFQDAFCGAYFTFAISHEGHVYGFGLSNYHQLGTPGTESCFIPQNLTSFKNSTKSWVGFSGGQHHTVCMDSEGKAYSLGRAEYGRLGLGEGAEEKSIPTLISRLPAVSSVACGASVGYAVTKDGRVFAWGMGTNYQLGTGQDEDAWSPVEMMGKQLENRVVLSVSSGGQHTVLLVKDKEQS
>1A12:C
KKVKVSHRSHSTEPGLVLTLGQGDVGQLGLGENVMERKKPALVSIPEDVVQAEAGGMHTVCLSKSGQVYSFGCNDEGALGRDTSVEGSEMVPGKVELQEKVVQVSAGDSHTAALTDDGRVFLWGSFRDNNGVIGLLEPMKKSMVPVQVQLDVPVVKVASGNDHLVMLTADGDLYTLGCGEQGQLGRVPELFANRGGRQGLERLLVPKCVMLKSRGSRGHVRFQDAFCGAYFTFAISHEGHVYGFGLSNYHQLGTPGTESCFIPQNLTSFKNSTKSWVGFSGGQHHTVCMDSEGKAYSLGRAEYGRLGLGEGAEEKSIPTLISRLPAVSSVACGASVGYAVTKDGRVFAWGMGTNYQLGTGQDEDAWSPVEMMGKQLENRVVLSVSSGGQHTVLLVKDKEQS
>1BCH:1
AIEVKLANMEAEINTLKSKLELTNKLHAFSMGKKSGKKFFVTNHERMPFSKVKALaSELRGTVAIPRNAEENKAIQEVAKTSAFLGITDEVTEGQFMYVTGGRLTYSNWKKDQPDDWYGHGLGGGEDbVHIVDNGLWNDISbQASHTAVaEFPA
>1BCH:2
AIEVKLANMEAEINTLKSKLELTNKLHAFSMGKKSGKKFFVTNHERMPFSKVKALcSELRGTVAIPRNAEENKAIQEVAKTSAFLGITDEVTEGQFMYVTGGRLTYSNWKKDQPDDWYGHGLGGGEDdVHIVDNGLWNDISdQASHTAVcEFPA
</code></pre>

<p><code>protein_test.chain</code>文件格式Top10:</p>
<pre><code class="markdown">>1A12:A
>1A12:B
>1A12:C
>1BCH:1
>1BCH:2
>1BCH:3
>1BF6:B
>1BYP:A
>1C7J:A
>1CHM:A
<code></code></code></pre>

<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>提示：以下内容乃个人实验笔记！</strong></p>
<h3 id="功能描述">功能描述</h3><p>从格式化后的dssp文件<code>DSSP</code>（单一文件）中提取序列信息，要求输出的序列不含有<code>X</code>残基，并且序列最短长度<code>minlen</code>可人为指定，一般设置为<code>40</code>。</p>]]>
    
    </summary>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/tags/BioInfo/"/>
    
      <category term="DSSP" scheme="http://csuldw.github.io/tags/DSSP/"/>
    
      <category term="预处理" scheme="http://csuldw.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/categories/BioInfo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[补集计算: B=U-A]]></title>
    <link href="http://csuldw.github.io/2015/11/17/2015-11-17%20B=U-A/"/>
    <id>http://csuldw.github.io/2015/11/17/2015-11-17 B=U-A/</id>
    <published>2015-11-17T07:11:00.000Z</published>
    <updated>2015-11-22T05:12:27.232Z</updated>
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>在做数据处理的时候，根据原论文的蛋白质链下载蛋白质PDB文件，大体上还算正常。但是有的protein的PDB文件在PDB数据库已经不存在了，所以下载后的PDB文件理论上只属于原论文提到的PDB文件的一个子集。由于数据比较大，手动去找会耗费大量的时间，所以为了找出这些不存在的PDB文件，下面写一段代码来实现。</p>
<h2 id="问题转换与实现">问题转换与实现</h2><p>首先，将问题转化成一个数学问题。</p>
<a id="more"></a>
<p>问题转化：原论文提及的数据集（一个大集合U），现在下载到的只是一个子集合A，目的是求出U中不包含A的子集合（补集）：<code>B=U-A</code>.</p>
<p>最终转化为：根据集合U和子集A，计算A的补集B=U-A.</p>
<p>参数：</p>
<ul>
<li>file1：大集合文件U</li>
<li>file2: 下载后的一个子集合A</li>
<li>outfile：输出文件</li>
</ul>
<p>代码如下：</p>
<p>compareTwoFile.py</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#-*- coding: utf-<span class="number">8</span> -*-</span><br><span class="line">import os</span><br><span class="line">def <span class="function"><span class="title">compareTwoFile</span><span class="params">(file1,file2,outfile)</span></span>:</span><br><span class="line">    with <span class="function"><span class="title">open</span><span class="params">(outfile,<span class="string">'w'</span>)</span></span> as fo: </span><br><span class="line">        fw = []</span><br><span class="line">        with <span class="function"><span class="title">open</span><span class="params">(file1,<span class="string">'r'</span>)</span></span> as fr1:</span><br><span class="line">            fr1_con = [each.<span class="function"><span class="title">strip</span><span class="params">()</span></span> <span class="keyword">for</span> each <span class="keyword">in</span> fr1.<span class="function"><span class="title">readlines</span><span class="params">()</span></span>] </span><br><span class="line">            with <span class="function"><span class="title">open</span><span class="params">(file2,<span class="string">'r'</span>)</span></span> as fr2:</span><br><span class="line">                fr2_con =[each.<span class="function"><span class="title">strip</span><span class="params">()</span></span> <span class="keyword">for</span> each <span class="keyword">in</span> fr2.<span class="function"><span class="title">readlines</span><span class="params">()</span></span>]</span><br><span class="line">                <span class="keyword">for</span> eachline <span class="keyword">in</span> fr1_con:</span><br><span class="line">                    <span class="keyword">if</span> eachline not <span class="keyword">in</span> fr2_con:</span><br><span class="line">                        fw.<span class="function"><span class="title">append</span><span class="params">(eachline)</span></span></span><br><span class="line">        fo.<span class="function"><span class="title">write</span><span class="params">(<span class="string">''</span>.join(fw)</span></span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>: </span><br><span class="line">    file1 = os<span class="class">.sys</span><span class="class">.argv</span>[<span class="number">1</span>]</span><br><span class="line">    file2 = os<span class="class">.sys</span><span class="class">.argv</span>[<span class="number">2</span>]</span><br><span class="line">    outfile = os<span class="class">.sys</span><span class="class">.argv</span>[<span class="number">3</span>]</span><br><span class="line">    <span class="function"><span class="title">compareTwoFile</span><span class="params">(file1,file2,outfile)</span></span></span><br></pre></td></tr></table></figure>
<p>Test sample:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python compareTwoFile.py \</span><br><span class="line"><span class="regexp">/ifs/</span>home<span class="regexp">/liudiwei/</span>DNA_BP<span class="regexp">/_data/</span>Exp_DBPI<span class="regexp">/train_set.protein  \</span><br><span class="line">/i</span>fs<span class="regexp">/home/</span>liudiwei<span class="regexp">/DNA_BP/</span>_data<span class="regexp">/Exp_DBPI/</span>pdb_trainset.txt \</span><br><span class="line"><span class="regexp">/ifs/</span>home<span class="regexp">/liudiwei/</span>DNA_BP<span class="regexp">/_data/</span>Exp_DBPI<span class="regexp">/compare.result</span></span><br></pre></td></tr></table></figure>
<p>file1和file2的top10格式：</p>
<pre><code>1A02
1A0A
1A3Q
1A53
1A8E
1A8P
1A8Y
1AAC    
1ABE
1AC5
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题描述">问题描述</h2><p>在做数据处理的时候，根据原论文的蛋白质链下载蛋白质PDB文件，大体上还算正常。但是有的protein的PDB文件在PDB数据库已经不存在了，所以下载后的PDB文件理论上只属于原论文提到的PDB文件的一个子集。由于数据比较大，手动去找会耗费大量的时间，所以为了找出这些不存在的PDB文件，下面写一段代码来实现。</p>
<h2 id="问题转换与实现">问题转换与实现</h2><p>首先，将问题转化成一个数学问题。</p>]]>
    
    </summary>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/tags/BioInfo/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/categories/BioInfo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Download PDB file with wget command]]></title>
    <link href="http://csuldw.github.io/2015/11/16/2015-11-16%20Download%20PDB%20file%20with%20wget%20command/"/>
    <id>http://csuldw.github.io/2015/11/16/2015-11-16 Download PDB file with wget command/</id>
    <published>2015-11-16T02:24:00.000Z</published>
    <updated>2016-03-08T08:54:14.739Z</updated>
    <content type="html"><![CDATA[<p>在Linux服务器下，使用<code>wget</code>命令下载PDB文件，即蛋白质文件。</p>
<ul>
<li>输入文件格式：一个存有<code>protein chain</code>的单独文件，每行的格式为：<code>1A34A</code></li>
<li>输出文件：多个蛋白质文件，买一行下载一个蛋白质，格式：1A34.pdb<a id="more"></a>
download.py文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadPDB</span><span class="params">(namefile,outpath)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(outpath):</span><br><span class="line">        os.mkdir(outpath)</span><br><span class="line">    os.chdir(outpath)</span><br><span class="line">    inputfile = open(namefile,<span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">for</span> eachline <span class="keyword">in</span> inputfile:</span><br><span class="line">        pdbname = eachline.lower().strip()[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        os.system(<span class="string">"wget http://ftp.wwpdb.org/pub/pdb/data/structures/all/pdb/pdb"</span> + pdbname + <span class="string">".ent.gz"</span>)</span><br><span class="line">        os.system(<span class="string">"gzip -d pdb"</span> + pdbname + <span class="string">'.ent.gz'</span>)</span><br><span class="line">        os.system(<span class="string">"mv pdb"</span> + pdbname + <span class="string">".ent "</span> + pdbname.upper() + <span class="string">'.pdb'</span>)</span><br><span class="line">    inputfile.close()</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    chainfile = os.sys.argv[<span class="number">1</span>] </span><br><span class="line">    outpath = os.sys.argv[<span class="number">2</span>]</span><br><span class="line">    proteinList = downloadPDB(chainfile,outpath)</span><br><span class="line"><span class="string">"""</span><br><span class="line">test sample</span><br><span class="line">python download.py /ifs/home/liudiwei/DNA_BP/_data/Exp_DBPI/train_set.txt /ifs/home/liudiwei/DNA_BP/_data/Exp_DBPI/pdb_trainset   </span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<p>命令解释：首先打开文件，然后逐行读取蛋白链，根据蛋白链的前四个字符，得到蛋白质的名字，然后使用<code>wget</code>命令下载<code>.ent.gz</code>文件，最后使用<code>gzip</code>解压文件即可。</p>
<p>命令行输入：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python download<span class="class">.py</span> ../filepath  ../dirpath</span><br></pre></td></tr></table></figure>
<p>其中<code>filepath</code>表示的是一个存有多行，每行表示一个蛋白链的单独文件。</p>
<p>Top10格式如下：</p>
<pre><code>1A12A
1BCH1
1BF6A
1BYPA
1C7JA
1CHMA
1CMNA
1CUHA
1CZYA
1D7EA
</code></pre><p>最后的输出文件Top5：</p>
<pre><code><span class="number">1</span>A12<span class="class">.pdb</span>
<span class="number">1</span>BCH<span class="class">.pdb</span>
<span class="number">1</span>BF6<span class="class">.pdb</span>
<span class="number">1</span>BYP<span class="class">.pdb</span>
<span class="number">1</span>C7J.pdb
</code></pre><hr>
<center><strong><br>此文乃原创博文，如果你从中有所收获，欢迎前来赞助，为博主送上你的支持：<a href="http://csuldw.github.io/donation" target="_black"><font color="red">【赞助中心】</font></a>。<br>  CSDN博客： <a href="http://blog.csdn.net/dream_angel_z" target="_black">【Dream_Angel_Z】</a><br>新浪微博： <a href="http://weibo.com/liudiwei210" target="_black">【@拾毅者】</a><br><br></strong></center>]]></content>
    <summary type="html">
    <![CDATA[<p>在Linux服务器下，使用<code>wget</code>命令下载PDB文件，即蛋白质文件。</p>
<ul>
<li>输入文件格式：一个存有<code>protein chain</code>的单独文件，每行的格式为：<code>1A34A</code></li>
<li>输出文件：多个蛋白质文件，买一行下载一个蛋白质，格式：1A34.pdb]]>
    
    </summary>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/tags/BioInfo/"/>
    
      <category term="PDB" scheme="http://csuldw.github.io/tags/PDB/"/>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/categories/BioInfo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine Learning-Normalization]]></title>
    <link href="http://csuldw.github.io/2015/11/15/2015-11-15%20normalization/"/>
    <id>http://csuldw.github.io/2015/11/15/2015-11-15 normalization/</id>
    <published>2015-11-15T02:24:00.000Z</published>
    <updated>2016-03-08T08:53:59.832Z</updated>
    <content type="html"><![CDATA[<p>本文主要介绍两种基本的数据归一化方法。</p>
<ul>
<li>min-max标准化（Min-Max Normalization）</li>
<li>Z-score标准化方法</li>
</ul>
<p>归一化方法有两种形式，一种是把数变为（0，1）之间的小数，一种是把有量纲表达式变为无量纲表达式。</p>
<a id="more"></a>
<p>数据标准化（归一化）处理是数据挖掘的一项基础工作，不同评价指标往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，为了消除指标之间的量纲影响，需要进行数据标准化处理，以解决数据指标之间的可比性。原始数据经过数据标准化处理后，各指标处于同一数量级，适合进行综合对比评价。</p>
<p>下面是归一化和没有归一化的比较：</p>
<p>没有经过归一化，寻找最优解过程如下：</p>
<p><img src="/assets/images/2015111501.png" alt="2015111501"></p>
<p>经过归一化，把各个特征的尺度控制在相同的范围内：</p>
<p><img src="/assets/images/2015111502.png" alt="2015111502"></p>
<p>从经验上说，归一化是让不同维度之间的特征在数值上有一定比较性，可以大大提高分类器的准确性。</p>
<p>以下是两种常用的归一化方法：</p>
<h2 id="1-min-max标准化（Min-Max_Normalization）">1.min-max标准化（Min-Max Normalization）</h2><p>也称为离差标准化，是对原始数据的线性变换，使结果值映射到[0 - 1]之间。转换函数如下：</p>
<p>$$x^{*}=\frac{x-x_{min}}{x_{max}-x_{min}}$$</p>
<p>x_min表示样本数据的最小值，x_max表示样本数据的最大值。</p>
<p><strong>Python代码实现：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">Normalization</span><span class="params">(x)</span></span>:</span><br><span class="line">	return [(<span class="function"><span class="title">float</span><span class="params">(i)</span></span>-<span class="function"><span class="title">min</span><span class="params">(x)</span></span>)/<span class="function"><span class="title">float</span><span class="params">(max(x)</span></span>-<span class="function"><span class="title">min</span><span class="params">(x)</span></span>) <span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">b=<span class="function"><span class="title">Normalization</span><span class="params">(x)</span></span></span><br></pre></td></tr></table></figure>
<p>Output：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0.0, <span class="number">0.166666666</span><span class="number">66666666</span>, 0.0, 0.5, <span class="number">0.33333333</span><span class="number">33333333</span>, <span class="number">0.166666666</span><span class="number">66666666</span>, <span class="number">0.66666666</span><span class="number">66666666</span>, <span class="number">0.83333333</span><span class="number">33333334</span>, <span class="number">0.166666666</span><span class="number">66666666</span>, 1.0]</span><br></pre></td></tr></table></figure>
<p>如果想要将数据映射到[-1,1]，则将公式换成：</p>
<p>$$x^{*}=\frac{x-x_{mean}}{x_{max}-x_{min}}$$</p>
<p>x_mean表示数据的均值</p>
<p><strong>Python代码实现：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def <span class="function"><span class="title">Normalization2</span><span class="params">(x)</span></span>:</span><br><span class="line">	return [(<span class="function"><span class="title">float</span><span class="params">(i)</span></span>-np.<span class="function"><span class="title">mean</span><span class="params">(x)</span></span>)/(<span class="function"><span class="title">max</span><span class="params">(x)</span></span>-<span class="function"><span class="title">min</span><span class="params">(x)</span></span>) <span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">b=<span class="function"><span class="title">Normalization2</span><span class="params">(x)</span></span></span><br></pre></td></tr></table></figure>
<p>Output：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-<span class="number">0.38333333</span><span class="number">33333333</span>, -<span class="number">0.216666666</span><span class="number">66666665</span>, -<span class="number">0.38333333</span><span class="number">33333333</span>, <span class="number">0.116666666</span><span class="number">6666667</span>, -<span class="number">0.04999999</span><span class="number">9999999968</span>, -<span class="number">0.216666666</span><span class="number">66666665</span>, <span class="number">0.28333333</span><span class="number">333333338</span>, <span class="number">0.45000000</span><span class="number">000000001</span>, -<span class="number">0.216666666</span><span class="number">66666665</span>, <span class="number">0.61666666</span><span class="number">66666667</span>]</span><br></pre></td></tr></table></figure>
<p>注意：上面的Normalization是处理单个列表的。</p>
<h2 id="2-z-score标准化方法">2.z-score标准化方法</h2><p>这种方法给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。经过处理的数据符合标准正态分布，即均值为0，标准差为1，转化函数为：</p>
<p>$$x^{*}=\frac{x-\mu}{\sigma}$$</p>
<p>其中，μ表示所有样本数据的均值，σ表示所有样本的标准差。</p>
<p><strong>Python代码实现：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def <span class="function"><span class="title">z_score</span><span class="params">(x)</span></span>:</span><br><span class="line">    x_mean=np.<span class="function"><span class="title">mean</span><span class="params">(x)</span></span></span><br><span class="line">    s2=<span class="function"><span class="title">sum</span><span class="params">([(i-np.mean(x)</span></span>)*(i-np.<span class="function"><span class="title">mean</span><span class="params">(x)</span></span>) <span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> x])/<span class="function"><span class="title">len</span><span class="params">(x)</span></span></span><br><span class="line">    return [(i-x_mean)/s2 <span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> x]</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">print <span class="function"><span class="title">z_score</span><span class="params">(x)</span></span></span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-<span class="number">0.57356608</span><span class="number">478802995</span>, -<span class="number">0.324189526</span><span class="number">18453861</span>, -<span class="number">0.57356608</span><span class="number">478802995</span>, <span class="number">0.174563591</span><span class="number">02244395</span>, -<span class="number">0.07481296</span><span class="number">7581047343</span>, -<span class="number">0.324189526</span><span class="number">18453861</span>, <span class="number">0.423940149</span><span class="number">62593524</span>, <span class="number">0.67331670</span><span class="number">822942646</span>, -<span class="number">0.324189526</span><span class="number">18453861</span>, <span class="number">0.92269326</span><span class="number">683291775</span>]</span><br></pre></td></tr></table></figure>
<hr>
<center><strong><br>此文乃博主即兴之作，如果你从中有所收获，欢迎前来赞助，为博主送上你的支持：<a href="http://csuldw.github.io/donation" target="_black"><font color="red">【赞助中心】</font></a>。<br>  CSDN博客： <a href="http://blog.csdn.net/dream_angel_z" target="_black">【Dream_Angel_Z】</a><br>新浪微博： <a href="http://weibo.com/liudiwei210" target="_black">【@拾毅者】</a><br><br></strong></center>]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要介绍两种基本的数据归一化方法。</p>
<ul>
<li>min-max标准化（Min-Max Normalization）</li>
<li>Z-score标准化方法</li>
</ul>
<p>归一化方法有两种形式，一种是把数变为（0，1）之间的小数，一种是把有量纲表达式变为无量纲表达式。</p>]]>
    
    </summary>
    
      <category term="normalization" scheme="http://csuldw.github.io/tags/normalization/"/>
    
      <category term="标准化" scheme="http://csuldw.github.io/tags/%E6%A0%87%E5%87%86%E5%8C%96/"/>
    
      <category term="预处理" scheme="http://csuldw.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Add header and footer to some file]]></title>
    <link href="http://csuldw.github.io/2015/11/03/2015-11-03%20Add%20header%20and%20footer%20to%20some%20file/"/>
    <id>http://csuldw.github.io/2015/11/03/2015-11-03 Add header and footer to some file/</id>
    <published>2015-11-03T08:24:00.000Z</published>
    <updated>2016-03-13T05:54:59.446Z</updated>
    <content type="html"><![CDATA[<p>今天整理资料的时候，发现要在很多文件中的头部和尾部添加相同的文本，于是自己使用Python做了一个简单的文件拼接功能，也可以说是文件追加功能，给一个文件批量追加头尾内容，达到省事的效果，顺便还可以练习下Python。下面来介绍下这个功能的代码：</p>
<p>现在有三个文件，如下：</p>
<ul>
<li>content.txt 位于一个叫path的文件中；</li>
<li>header.txt用于添加到content.txt头部的文件；</li>
<li>footer.txt用于添加到content.txt尾部的文件。</li>
</ul>
<p>现在要实现的功能就是，将header和footer分别添加到content的头部和尾部。 </p>
<a id="more"></a>
<hr>
<p>函数说明：</p>
<ul>
<li>add_footer(infile, outfile)：用于将footer内容添加到content中，第一个参数表示的添加到尾部的文件，如输入footer.txt，第二个为内容文件。如content.txt文件</li>
<li>add_header(infile, outfile, auto=True): 用于将一个文件放入好另一个文件的头部，如果auto=Ture，则不对内容做修改，auto为False的话，这里添加了部分需要的东西，如文件的创建时间、标题等信息。</li>
<li>addHeadAndFooter(path, header, footer, auto=False)：核心函数，调用头尾两个方法，此处的path为文件夹名称，该函数的功能是将path文件夹下的所有文件都添加头和尾的内容，auto默认为False，功能和上面的相同。</li>
<li>getStdTime(seconds):将时间戳格式的日期转换为标准格式，如：2015-11-03 10:24</li>
</ul>
<p>代码（AddHeader.py）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Tue Nov 03 10:32:26 2015</span><br><span class="line">@author: liudiwei</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_footer</span><span class="params">(infile, outfile)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(infile,<span class="string">'r'</span>) <span class="keyword">as</span> inputfile:</span><br><span class="line">        <span class="keyword">with</span> open(outfile,<span class="string">'a'</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">            outfile.write(<span class="string">"\n\n"</span>+<span class="string">''</span>.join(inputfile.readlines()))</span><br><span class="line"><span class="comment">#如果auto==True，直接将文件内容加入到当前文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_header</span><span class="params">(infile, outfile, auto=True)</span>:</span> </span><br><span class="line">    inf=open(infile,<span class="string">'r'</span>)</span><br><span class="line">    outf = open(outfile,<span class="string">'r'</span>)</span><br><span class="line">    header = inf.readlines()</span><br><span class="line">    content=outf.readlines()</span><br><span class="line">    <span class="keyword">if</span> auto==<span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">with</span> open(outfile,<span class="string">'w'</span>) <span class="keyword">as</span> output:</span><br><span class="line">            output.write(<span class="string">''</span>.join(header)+ <span class="string">"\n\n"</span> \</span><br><span class="line">                            +<span class="string">''</span>.join(content))  </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ctime=getStdTime(os.path.getctime(outfile))</span><br><span class="line">        title=<span class="string">"title: "</span> + outfile.split(<span class="string">'/'</span>)[<span class="number">1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> title</span><br><span class="line">        add_content=<span class="string">"---\n"</span></span><br><span class="line">        add_content=add_content+title+<span class="string">'\n'</span>  <span class="comment">#add title</span></span><br><span class="line">        add_content=add_content+ctime +<span class="string">'\n'</span> <span class="comment">#add date</span></span><br><span class="line">        add_content=add_content+<span class="string">''</span>.join(header)</span><br><span class="line">        <span class="keyword">with</span> open(outfile,<span class="string">'w'</span>) <span class="keyword">as</span> output:</span><br><span class="line">            output.write(<span class="string">''</span>.join(add_content)+ <span class="string">"\n\n"</span> \</span><br><span class="line">                        +<span class="string">''</span>.join(content))  </span><br><span class="line">    outf.close()</span><br><span class="line">    inf.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addHeadAndFooter</span><span class="params">(path, header, footer, auto=False)</span>:</span></span><br><span class="line">    filelist=os.listdir(path)</span><br><span class="line">    <span class="keyword">for</span> eachfile <span class="keyword">in</span> filelist:</span><br><span class="line">        add_header(header,path + <span class="string">"/"</span> + eachfile, auto)</span><br><span class="line">        add_footer(footer,path + <span class="string">"/"</span> + eachfile)       </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getStdTime</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    x = time.localtime(seconds)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"date: "</span>+ time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>,x)        </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> (len(os.sys.argv)&lt;<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">raise</span> TypeError()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"os.sys.arg"</span></span><br><span class="line">    <span class="comment">#path="path"</span></span><br><span class="line">    <span class="comment">#header="head.md"</span></span><br><span class="line">    <span class="comment">#footer="footer.md"</span></span><br><span class="line">    os.chdir(<span class="string">"."</span>)</span><br><span class="line">    path=os.sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> path</span><br><span class="line">    header=os.sys.argv[<span class="number">2</span>]</span><br><span class="line">    footer=os.sys.argv[<span class="number">3</span>]</span><br><span class="line">    filelist=os.listdir(path)</span><br><span class="line">    addHeadAndFooter(path,header,footer)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Success added!"</span>    </span><br><span class="line"><span class="comment">#----------------    </span></span><br><span class="line"><span class="comment"># command </span></span><br><span class="line"><span class="comment"># python AddHead.py "path" "header.txt" "footer.txt"</span></span><br><span class="line"><span class="comment">#----------------</span></span><br></pre></td></tr></table></figure>
<p>直接在console控制台上运行下列代码即可 </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python AddHeader<span class="class">.py</span> <span class="string">"path"</span> <span class="string">"header.txt"</span> <span class="string">"footer.txt"</span></span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天整理资料的时候，发现要在很多文件中的头部和尾部添加相同的文本，于是自己使用Python做了一个简单的文件拼接功能，也可以说是文件追加功能，给一个文件批量追加头尾内容，达到省事的效果，顺便还可以练习下Python。下面来介绍下这个功能的代码：</p>
<p>现在有三个文件，如下：</p>
<ul>
<li>content.txt 位于一个叫path的文件中；</li>
<li>header.txt用于添加到content.txt头部的文件；</li>
<li>footer.txt用于添加到content.txt尾部的文件。</li>
</ul>
<p>现在要实现的功能就是，将header和footer分别添加到content的头部和尾部。 </p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python-RegEx（正则表达式）]]></title>
    <link href="http://csuldw.github.io/2015/10/29/2015-10-29%20Python%20RegEx/"/>
    <id>http://csuldw.github.io/2015/10/29/2015-10-29 Python RegEx/</id>
    <published>2015-10-29T12:24:00.000Z</published>
    <updated>2016-03-23T12:25:49.452Z</updated>
    <content type="html"><![CDATA[<p>关于Python的正则表达式，初步学习了下，感觉跟shell脚本的正则表达式大体相同，先来做个小结吧！</p>
<h2 id="正则表达式">正则表达式</h2><p>正则表达式在实际的文本文件处理中，经常用到，其实正则表达式并不是Python的一部分，其它语言中都有。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能真的十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。如果已经在其他语言里使用过正则表达式，只需要简单看一看就可以上手了。</p>
<p>下图展示了使用正则表达式进行匹配的流程： </p>
<p><img src="http://ww4.sinaimg.cn/large/637f3c58gw1exic0q7k4ej20cj055t9e.jpg" alt=""></p>
<a id="more"></a>
<p>从上图我们可以看出，正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同，但也是很好理解的，来看看下面的这个正则表达式模式。</p>
<table>
<thead>
<tr>
<th>ID</th>
<th style="text-align:right">模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:right">^</td>
<td>匹配字符串的开头</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:right">$</td>
<td>匹配字符串的末尾。</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:right">.</td>
<td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:right">[…]</td>
<td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:right">[^…]</td>
<td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:right">*</td>
<td>匹配0个或多个的表达式。</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:right">+</td>
<td>匹配1个或多个的表达式。</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:right">?</td>
<td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:right">{ n,}</td>
<td>精确匹配n个前面表达式。</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:right">{n,m}</td>
<td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:right">(re)</td>
<td>G匹配括号内的表达式，也表示一个组</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:right">(?imx)</td>
<td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:right">(?-imx)</td>
<td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:right">(?:re)</td>
<td>类似 (…), 但是不表示一个组</td>
</tr>
<tr>
<td>15</td>
<td style="text-align:right">(?imx:re)</td>
<td>在括号中使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>16</td>
<td style="text-align:right">(?-imx:re)</td>
<td>在括号中不使用i, m, 或 x 可选标志</td>
</tr>
<tr>
<td>17</td>
<td style="text-align:right">(?#…)</td>
<td>注释.</td>
</tr>
<tr>
<td>18</td>
<td style="text-align:right">(?=re)</td>
<td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td>
</tr>
<tr>
<td>19</td>
<td style="text-align:right">(?!re)</td>
<td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功</td>
</tr>
<tr>
<td>20</td>
<td style="text-align:right">(?&gt;re)</td>
<td>匹配的独立模式，省去回溯。</td>
</tr>
<tr>
<td>21</td>
<td style="text-align:right">\w</td>
<td>匹配字母数字,等价于’[A-Za-z0-9_]’</td>
</tr>
<tr>
<td>22</td>
<td style="text-align:right">\W</td>
<td>匹配非字母数字, [^A-Za-z0-9_]’</td>
</tr>
<tr>
<td>23</td>
<td style="text-align:right">\s</td>
<td>匹配任意空白字符，等价于[\t\n\r\f].</td>
</tr>
<tr>
<td>24</td>
<td style="text-align:right">\S</td>
<td>匹配任意非空字符,等价于[^ \f\n\r\t\v]</td>
</tr>
<tr>
<td>25</td>
<td style="text-align:right">\d</td>
<td>匹配任意数字，等价于[0-9].</td>
</tr>
<tr>
<td>26</td>
<td style="text-align:right">\D</td>
<td>匹配任意非数字,等价于[^0-9]。</td>
</tr>
<tr>
<td>27</td>
<td style="text-align:right">\A</td>
<td>匹配字符串开始</td>
</tr>
<tr>
<td>28</td>
<td style="text-align:right">\Z</td>
<td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c</td>
</tr>
<tr>
<td>29</td>
<td style="text-align:right">\z</td>
<td>匹配字符串结束</td>
</tr>
<tr>
<td>30</td>
<td style="text-align:right">\G</td>
<td>匹配最后匹配完成的位置。</td>
</tr>
<tr>
<td>31</td>
<td style="text-align:right">\b</td>
<td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td>
</tr>
<tr>
<td>32</td>
<td style="text-align:right">\B</td>
<td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td>
</tr>
<tr>
<td>33</td>
<td style="text-align:right">\n, \t, 等.</td>
<td>匹配一个换行符。匹配一个制表符。等</td>
</tr>
<tr>
<td>34</td>
<td style="text-align:right">\1…\9</td>
<td>匹配第n个分组的子表达式。</td>
</tr>
<tr>
<td>35</td>
<td style="text-align:right">\10</td>
<td>匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。</td>
</tr>
</tbody>
</table>
<p>下面从正则表达式的几个函数/方法来简单介绍下正则表达式的用法。</p>
<hr>
<h2 id="re-match()函数">re.match()函数</h2><p>re.match 尝试<font color="#007FFF"><strong>从字符串的开头匹配一个模式</strong></font>，如：下面的例子匹配第一个单词。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"This is a very beautiful girl, I like her very much."</span></span><br><span class="line">m = re.match(<span class="string">r"(\w+)\s"</span>, text)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">	<span class="keyword">print</span> m.group(<span class="number">0</span>), <span class="string">'\n'</span>, m.group(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'not match'</span></span><br></pre></td></tr></table></figure>
<p>输出:</p>
<pre><code class="markdown">
This
This
</code></pre>

<p>re.match的函数原型为：re.match(pattern, string, flags)</p>
<ul>
<li>第一个参数是正则表达式，这里为”(\w+)\s”，如果匹配成功，则返回一个Match，否则返回一个None；</li>
<li>第二个参数表示要匹配的字符串；</li>
<li>第三个参数是标致位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</li>
</ul>
<hr>
<h2 id="re-search()函数">re.search()函数</h2><p>re.search函数会在字符串内查找模式匹配,只到找到第一个匹配然后返回，如果字符串没有匹配，则返回None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"This is a very beautiful girl, I like her very much."</span></span><br><span class="line">m = re.search(<span class="string">r'\sbeaut(i)ful\s'</span>, text)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">	<span class="keyword">print</span> m.group(<span class="number">0</span>), m.group(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="keyword">print</span> <span class="string">'not search'</span></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<pre><code class="markdown">
beautiful i
</code></pre>

<p>re.search的函数原型为： re.search(pattern, string, flags)</p>
<p>每个参数的含意与re.match一样。 </p>
<hr>
<h2 id="re-match()与re-search()的区别">re.match()与re.search()的区别</h2><font color="#007FFF"><strong>re.match只匹配字符串的开始，如果字符串从一开始就不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</strong></font>

<p>请看下面这个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">line = <span class="string">"This is a very beautiful girl, I like her very much."</span>;</span><br><span class="line">m = re.match( <span class="string">r'girl'</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"match --&gt; m.group() : "</span>, m.group()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"No match!!"</span></span><br></pre></td></tr></table></figure>
<p>match会从字符串起始出进行模式匹配，即模式中的其实字母‘g’匹配‘This’中的‘T’，所以，匹配失败。</p>
<pre><code class="markdown">No match!!
</code></pre>

<p>如果使用的是search，来看看结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = re.search( <span class="string">r'girl'</span>, line, re.M|re.I)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"search --&gt; m.group() : "</span>, m.group()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"No match!"</span></span><br></pre></td></tr></table></figure>
<p>以上实例运行结果如下：</p>
<pre><code class="markdown">search --> m.group() :  girl
</code></pre>

<hr>
<h2 id="re-sub()_&amp;_re-subn()函数">re.sub() &amp; re.subn()函数</h2><p>re.sub用于替换字符串中的匹配项。下面一个例子将字符串中的空格 ‘ ‘ 替换成 ‘-‘ : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"I like Cats more than dogs!"</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">r'\s+'</span>, <span class="string">'-'</span>, text)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code class="markdown">
I-like-Cats-more-than-dogs!
</code></pre>


<p>re.sub的函数原型为：<font color="#007FFF"><strong>re.sub(pattern, repl, string, count)</strong></font></p>
<p>其中第二个函数是替换后的字符串；本例中为’-‘</p>
<p>第四个参数指替换个数。默认为0，表示每个匹配项都替换。</p>
<p>re.sub还允许使用函数对匹配项的替换进行复杂的处理。如：re.sub(r’\s’, lambda m: ‘[‘ + m.group(0) + ‘]’, text, 0)；将字符串中的空格’ ‘替换为’[ ]’。</p>
<p>注：re.subn和re.sub大体相似，唯一不同的就是返回结果，subn会将匹配的个数也显示出来。</p>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> re</span><br><span class="line">&gt;&gt;&gt;text = <span class="string">"I like Cats more than dogs!"</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> re.subn(<span class="string">r'\s+'</span>, <span class="string">'-'</span>, text)</span><br><span class="line"></span><br><span class="line">(<span class="string">'I-like-Cats-more-than-dogs!'</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="re-split()函数">re.split()函数</h2><p>可以使用re.split来分割字符串，如：re.split(r’-‘, text)；将字符串按’-‘符号分割成一个单词列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text=<span class="string">"I-really-like-this-girl!"</span></span><br><span class="line">re.split(<span class="string">r'-'</span>,text)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code class="markdown">
['I', 'really', 'like', 'this', 'girl!']
</code></pre>


<hr>
<h2 id="re-findall()函数">re.findall()函数</h2><p>re.findall可以获取字符串中所有匹配的字符串。如：re.findall(r’\w*i\w*‘, text)；获取字符串中，包含’oo’的所有单词。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text=<span class="string">"I-really-like-this-girl!"</span></span><br><span class="line">re.findall(<span class="string">r'girl'</span>,text)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<pre><code class="markdown">['like', 'this', 'girl']
</code></pre>

<hr>
<h2 id="re-compile()函数">re.compile()函数</h2><p>可以把正则表达式编译成一个正则表达式对象。可以把那些经常使用的正则表达式编译成正则表达式对象，这样可以提高一定的效率。下面是一个正则表达式对象的一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regex = re.compile(<span class="string">r'\w*er\w*'</span>) <span class="comment"># 将正则表达式编译成Pattern对象</span></span><br><span class="line">text = <span class="string">"This is a very beautiful girl, I like her very much."</span></span><br><span class="line">m = regex.search(text) <span class="comment">#使用regex来匹配text字符串</span></span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">    <span class="keyword">print</span> m.group() <span class="comment"># 使用Match获得分组信息</span></span><br><span class="line"><span class="keyword">print</span> regex.findall(text)   <span class="comment">#查找所有包含'oo'的单词</span></span><br><span class="line"><span class="keyword">print</span> regex.sub(<span class="keyword">lambda</span> m: <span class="string">'['</span> + m.group(<span class="number">0</span>) + <span class="string">']'</span>, text) <span class="comment">#将字符串中含有'oo'的单词用[]括起来。</span></span><br></pre></td></tr></table></figure>
<p>分别输出下列信息：</p>
<pre><code class="markdown">'very'
['very', 'her', 'very']
This is a [very] beautiful girl, I like [her] [very] much.
</code></pre>

<hr>
<h2 id="邮箱验证">邮箱验证</h2><p>使用Python写一个简单的邮箱验证的正则表达式：</p>
<p>根据csu.ldw@csu.edu.cn来填写规则</p>
<p>规则：</p>
<ul>
<li>@前面可以有’.’, ‘_’, ‘-‘, 但不能出现在头尾，而且不能连续出现</li>
<li>@后面到结尾之间，可以有多个子域名</li>
<li>邮箱的结尾为2~5个字母，比如cn、com、name等</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Thu Oct 29 20:28:57 2015</span><br><span class="line">@author: liudiwei</span><br><span class="line">"""</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">regex = re.compile(<span class="string">'^[A-Za-z0-9]+(([\.\_\-])?[A-Za-z0-9]+)+@([A-Za-z]+.)+[A-Za-z]&#123;2,5&#125;$'</span>)</span><br><span class="line">m = regex.match(<span class="string">"csu.ldw@csu.edu.cn"</span>)</span><br><span class="line"><span class="keyword">if</span> m:</span><br><span class="line">    <span class="keyword">print</span> m.group()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"no match!"</span></span><br></pre></td></tr></table></figure>
<p>测试输出：</p>
<pre><code class="markdown">csu.ldw@csu.edu.cn
</code></pre>

<p>当m = regex.match(“_csu.ldw@csu.edu.cn”)<br>当邮箱为：</p>
<pre><code class="markdown">_csu.ldw@csu.edu.cn  
csu.ldw_@csu.edu.cn
csu.ldw@csu_.edu.cn
_csu.ldw@csu.edu.cn1
</code></pre>

<p>都不会匹配</p>
<p>提示：合法邮箱的规则可能不够完善，这里就简单的匹配这三个规则吧！</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于Python的正则表达式，初步学习了下，感觉跟shell脚本的正则表达式大体相同，先来做个小结吧！</p>
<h2 id="正则表达式">正则表达式</h2><p>正则表达式在实际的文本文件处理中，经常用到，其实正则表达式并不是Python的一部分，其它语言中都有。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能真的十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。如果已经在其他语言里使用过正则表达式，只需要简单看一看就可以上手了。</p>
<p>下图展示了使用正则表达式进行匹配的流程： </p>
<p><img src="http://ww4.sinaimg.cn/large/637f3c58gw1exic0q7k4ej20cj055t9e.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="RegEx" scheme="http://csuldw.github.io/tags/RegEx/"/>
    
      <category term="正则表达式" scheme="http://csuldw.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[scikit-learn Preprocessing]]></title>
    <link href="http://csuldw.github.io/2015/10/25/2015-10-25%20scikit-learn%20preprocessing/"/>
    <id>http://csuldw.github.io/2015/10/25/2015-10-25 scikit-learn preprocessing/</id>
    <published>2015-10-25T02:24:00.000Z</published>
    <updated>2016-03-13T05:55:40.918Z</updated>
    <content type="html"><![CDATA[<p>本文主要是对照<a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing" target="_blank" rel="external">scikit-learn的preprocessing</a>章节结合代码简单的回顾下预处理技术的几种方法，主要包括标准化、数据最大最小缩放处理、正则化、特征二值化和数据缺失值处理。内容比较简单，仅供参考！</p>
<p>首先来回顾一下下面要用到的基本知识。</p>
<a id="more"></a>
<h2 id="一、知识回顾"><strong>一、知识回顾</strong></h2><p>均值公式：</p>
<p>$$\bar{x}=\frac{1}{n}\sum_{i=1}^{n}x_{i}$$</p>
<p>方差公式：</p>
<p>$$s^{2}=\frac{1}{n}\sum_{i=1}^{n}(x_{i}-\bar{x})^{2}$$</p>
<p>0-范数，向量中非零元素的个数。</p>
<p>1-范数：</p>
<p>$$||X||= \sum_{i=1}^{n} |x_{i}|$$</p>
<p>2-范数：</p>
<p>$$||X||_{2} =  (\sum_{i=1}^{n} x_{i}^{2})^{\frac{1}{2}}$$</p>
<p>p-范数的计算公式：</p>
<p>$$||X||_{p}=(|x1|^{p}+|x2|^{p}+…+|xn|^{p})^{\frac{1}{p}}$$</p>
<hr>
<p>数据标准化：当单个特征的样本取值相差甚大或明显不遵从高斯正态分布时，标准化表现的效果较差。实际操作中，经常忽略特征数据的分布形状，移除每个特征均值，划分离散特征的标准差，从而等级化，进而实现数据中心化。</p>
<h2 id="二、标准化(Standardization)，或者去除均值和方差进行缩放"><strong>二、标准化(Standardization)，或者去除均值和方差进行缩放</strong></h2><p>公式为：(X-X_mean)/X_std 计算时对每个属性/每列分别进行.</p>
<p>将数据按其属性(按列进行)减去其均值，然后除以其方差。最后得到的结果是，对每个属性/每列来说所有数据都聚集在0附近，方差值为1。</p>
<p>首先说明下sklearn中preprocessing库里面的scale函数使用方法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing.scale(X, axis=<span class="number">0</span>, with_mean=<span class="keyword">True</span>,with_std=<span class="keyword">True</span>,<span class="keyword">copy</span>=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>根据参数的不同，可以沿任意轴标准化数据集。</p>
<p>参数解释：</p>
<ul>
<li>X：数组或者矩阵</li>
<li>axis：int类型，初始值为0，axis用来计算均值 means 和标准方差 standard deviations. 如果是0，则单独的标准化每个特征（列），如果是1，则标准化每个观测样本（行）。</li>
<li>with_mean: boolean类型，默认为True，表示将数据均值规范到0</li>
<li>with_std: boolean类型，默认为True，表示将数据方差规范到1</li>
</ul>
<p><strong>一个简单的例子</strong></p>
<p>假设现在我构造一个数据集X，然后想要将其标准化。下面使用不同的方法来标准化X：</p>
<p><strong>方法一：使用sklearn.preprocessing.scale()函数</strong></p>
<p><strong>方法说明：</strong></p>
<ul>
<li>X.mean(axis=0)用来计算数据X每个特征的均值；</li>
<li>X.std(axis=0)用来计算数据X每个特征的方差；</li>
<li>preprocessing.scale(X)直接标准化数据X。</li>
</ul>
<p>将代码整理到一个文件中：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from sklearn <span class="built_in">import</span> preprocessing </span><br><span class="line"><span class="built_in">import</span> numpy as np</span><br><span class="line"><span class="variable">X =</span> np.array([[ <span class="number">1</span>., -<span class="number">1</span>.,  <span class="number">2</span>.],</span><br><span class="line">              [ <span class="number">2</span>.,  <span class="number">0</span>.,  <span class="number">0</span>.],</span><br><span class="line">              [ <span class="number">0</span>.,  <span class="number">1</span>., -<span class="number">1</span>.]])</span><br><span class="line"><span class="comment"># calculate mean</span></span><br><span class="line"><span class="variable">X_mean =</span> X.mean(<span class="variable">axis=</span><span class="number">0</span>)</span><br><span class="line"><span class="comment"># calculate variance </span></span><br><span class="line"><span class="variable">X_std =</span> X.std(<span class="variable">axis=</span><span class="number">0</span>)</span><br><span class="line"><span class="comment"># standardize X</span></span><br><span class="line"><span class="variable">X1 =</span> (X-X_mean)/X_std</span><br><span class="line"><span class="comment"># use function preprocessing.scale to standardize X</span></span><br><span class="line"><span class="variable">X_scale =</span> preprocessing.scale(X)</span><br></pre></td></tr></table></figure>
<p>最后X_scale的值和X1的值是一样的，前面是单独的使用数学公式来计算，主要是为了形成一个对比，能够更好的理解scale()方法。</p>
<p><strong>方法2：sklearn.preprocessing.StandardScaler类</strong></p>
<p>该方法也可以对数据X进行标准化处理，实例如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import preprocessing </span><br><span class="line">import numpy as np</span><br><span class="line">X = np.array([[ <span class="number">1</span>., -<span class="number">1</span>.,  <span class="number">2</span>.],</span><br><span class="line">              [ <span class="number">2</span>.,  <span class="number">0</span>.,  <span class="number">0</span>.],</span><br><span class="line">              [ <span class="number">0</span>.,  <span class="number">1</span>., -<span class="number">1</span>.]])</span><br><span class="line">scaler = preprocessing.<span class="function"><span class="title">StandardScaler</span><span class="params">()</span></span></span><br><span class="line">X_scaled = scaler.<span class="function"><span class="title">fit_transform</span><span class="params">(X)</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法得到最后的结果都是一样的。</p>
<hr>
<h2 id="三、将特征的取值缩小到一个范围（如0到1）"><strong>三、将特征的取值缩小到一个范围（如0到1）</strong></h2><p>除了上述介绍的方法之外，另一种常用的方法是将属性缩放到一个指定的最大值和最小值(通常是1-0)之间，这可以通过preprocessing.MinMaxScaler类来实现。</p>
<p>使用这种方法的目的包括：</p>
<ul>
<li>1、对于方差非常小的属性可以增强其稳定性；</li>
<li>2、维持稀疏矩阵中为0的条目。</li>
</ul>
<p>下面将数据缩至0-1之间，采用MinMaxScaler函数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import preprocessing </span><br><span class="line">import numpy as np</span><br><span class="line">X = np.array([[ <span class="number">1</span>., -<span class="number">1</span>.,  <span class="number">2</span>.],</span><br><span class="line">              [ <span class="number">2</span>.,  <span class="number">0</span>.,  <span class="number">0</span>.],</span><br><span class="line">              [ <span class="number">0</span>.,  <span class="number">1</span>., -<span class="number">1</span>.]])</span><br><span class="line">min_max_scaler = preprocessing.<span class="function"><span class="title">MinMaxScaler</span><span class="params">()</span></span></span><br><span class="line">X_minMax = min_max_scaler.<span class="function"><span class="title">fit_transform</span><span class="params">(X)</span></span></span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array(<span class="string">[[ 0.5       ,  0.        ,  1.        ],</span><br><span class="line">       [ 1.        ,  0.5       ,  0.33333333],</span><br><span class="line">       [ 0.        ,  1.        ,  0.        ]]</span>)</span><br></pre></td></tr></table></figure>
<p>测试用例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X_test = np.array(<span class="string">[[ -3., -1.,  4.]]</span>)</span><br><span class="line">&gt;&gt;&gt; X_test_minmax = min_max_scaler.transform(X_test)</span><br><span class="line">&gt;&gt;&gt; X_test_minmax</span><br><span class="line">array(<span class="string">[[-1.5       ,  0.        ,  1.66666667]]</span>)</span><br></pre></td></tr></table></figure>
<p>注意：这些变换都是对列进行处理。</p>
<p>当然，在构造类对象的时候也可以直接指定最大最小值的范围：feature_range=(min, max)，此时应用的公式变为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_std=(X-X.<span class="function"><span class="title">min</span><span class="params">(axis=<span class="number">0</span>)</span></span>)/(X.<span class="function"><span class="title">max</span><span class="params">(axis=<span class="number">0</span>)</span></span>-X.<span class="function"><span class="title">min</span><span class="params">(axis=<span class="number">0</span>)</span></span>)</span><br><span class="line">X_minmax=X_std/(X.<span class="function"><span class="title">max</span><span class="params">(axis=<span class="number">0</span>)</span></span>-X.<span class="function"><span class="title">min</span><span class="params">(axis=<span class="number">0</span>)</span></span>)+X.<span class="function"><span class="title">min</span><span class="params">(axis=<span class="number">0</span>)</span></span>)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四、正则化(Normalization)"><strong>四、正则化(Normalization)</strong></h2><p>正则化的过程是将每个样本缩放到单位范数(每个样本的范数为1)，如果要使用如二次型(点积)或者其它核方法计算两个样本之间的相似性这个方法会很有用。</p>
<p>该方法是文本分类和聚类分析中经常使用的向量空间模型（Vector Space Model)的基础.</p>
<p>Normalization主要思想是对每个样本计算其p-范数，然后对该样本中每个元素除以该范数，这样处理的结果是使得每个处理后样本的p-范数(l1-norm,l2-norm)等于1。</p>
<p><strong>方法1：使用sklearn.preprocessing.normalize()函数</strong></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = [[ <span class="number">1.</span>, -<span class="number">1.</span>,  <span class="number">2.</span>],</span><br><span class="line"><span class="keyword">...</span>      [ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line"><span class="keyword">...</span>      [ <span class="number">0.</span>,  <span class="number">1.</span>, -<span class="number">1.</span>]]</span><br><span class="line">&gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm=<span class="string">'l2'</span>)</span><br><span class="line">&gt;&gt;&gt; X_normalized                                      </span><br><span class="line">array([[ <span class="number">0.40</span><span class="keyword">...</span>, -<span class="number">0.40</span><span class="keyword">...</span>,  <span class="number">0.81</span><span class="keyword">...</span>],</span><br><span class="line">       [ <span class="number">1.</span>  <span class="keyword">...</span>,  <span class="number">0.</span>  <span class="keyword">...</span>,  <span class="number">0.</span>  <span class="keyword">...</span>],</span><br><span class="line">       [ <span class="number">0.</span>  <span class="keyword">...</span>,  <span class="number">0.70</span><span class="keyword">...</span>, -<span class="number">0.70</span><span class="keyword">...</span>]])</span><br></pre></td></tr></table></figure>
<p><strong>方法2：sklearn.preprocessing.StandardScaler类</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; normalizer = preprocessing.<span class="constant">Normalizer</span>().fit(<span class="constant">X</span>)  <span class="comment"># fit does nothing</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; normalizer</span><br><span class="line"><span class="constant">Normalizer</span>(copy=<span class="constant">True</span>, norm=<span class="string">'l2'</span>)</span><br></pre></td></tr></table></figure>
<p>然后使用正则化实例来转换样本向量：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; normalizer.transform(X)                            </span><br><span class="line">array(<span class="string">[[ 0.40..., -0.40...,  0.81...],</span><br><span class="line">       [ 1.  ...,  0.  ...,  0.  ...],</span><br><span class="line">       [ 0.  ...,  0.70..., -0.70...]]</span>)</span><br><span class="line">&gt;&gt;&gt; normalizer.transform(<span class="string">[[-1.,  1., 0.]]</span>)             </span><br><span class="line">array(<span class="string">[[-0.70...,  0.70...,  0.  ...]]</span>)</span><br></pre></td></tr></table></figure>
<p>两种方法都可以，效果是一样的。</p>
<hr>
<h2 id="五、二值化(Binarization)"><strong>五、二值化(Binarization)</strong></h2><p>特征的二值化主要是为了将数据特征转变成boolean变量。在sklearn中，sklearn.preprocessing.Binarizer函数可以实现这一功能。实例如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X = <span class="string">[[ 1., -1.,  2.],</span><br><span class="line">...      [ 2.,  0.,  0.],</span><br><span class="line">...      [ 0.,  1., -1.]]</span></span><br><span class="line">&gt;&gt;&gt; binarizer = preprocessing.Binarizer().fit(X)  # fit does nothing</span><br><span class="line">&gt;&gt;&gt; binarizer</span><br><span class="line">Binarizer(copy=True, threshold=<span class="number">0.0</span>)</span><br><span class="line">&gt;&gt;&gt; binarizer.transform(X)</span><br><span class="line">array(<span class="string">[[ 1.,  0.,  1.],</span><br><span class="line">       [ 1.,  0.,  0.],</span><br><span class="line">       [ 0.,  1.,  0.]]</span>)</span><br></pre></td></tr></table></figure>
<p>Binarizer函数也可以设定一个阈值，结果数据值大于阈值的为1，小于阈值的为0，实例代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; binarizer = preprocessing.<span class="function"><span class="title">Binarizer</span><span class="params">(threshold=<span class="number">1.1</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; binarizer.<span class="function"><span class="title">transform</span><span class="params">(X)</span></span></span><br><span class="line">array([[ <span class="number">0</span>.,  <span class="number">0</span>.,  <span class="number">1</span>.],</span><br><span class="line">       [ <span class="number">1</span>.,  <span class="number">0</span>.,  <span class="number">0</span>.],</span><br><span class="line">       [ <span class="number">0</span>.,  <span class="number">0</span>.,  <span class="number">0</span>.]])</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="六、缺失值处理"><strong>六、缺失值处理</strong></h2><p>由于不同的原因，许多现实中的数据集都包含有缺失值，要么是空白的，要么使用NaNs或者其它的符号替代。这些数据无法直接使用scikit-learn分类器直接训练，所以需要进行处理。幸运地是，sklearn中的<strong>Imputer</strong>类提供了一些基本的方法来处理缺失值，如使用均值、中位值或者缺失值所在列中频繁出现的值来替换。</p>
<p>下面是使用均值来处理的实例：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import Imputer</span><br><span class="line">&gt;&gt;&gt; imp = Imputer(missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; imp.fit(<span class="string">[[1, 2], [np.nan, 3], [7, 6]]</span>)</span><br><span class="line">Imputer(axis=<span class="number">0</span>, copy=True, missing_values=<span class="string">'NaN'</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; X = <span class="string">[[np.nan, 2], [6, np.nan], [7, 6]]</span></span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(imp.transform(X))                           </span><br><span class="line"><span class="string">[[ 4.          2.        ]</span><br><span class="line"> [ 6.          3.666...]</span><br><span class="line"> [ 7.          6.        ]]</span></span><br></pre></td></tr></table></figure>
<p>Imputer类同样支持稀疏矩阵：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import scipy<span class="class">.sparse</span> as sp</span><br><span class="line">&gt;&gt;&gt; X = sp.<span class="function"><span class="title">csc_matrix</span><span class="params">([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span></span></span><br><span class="line">&gt;&gt;&gt; imp = <span class="function"><span class="title">Imputer</span><span class="params">(missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, axis=<span class="number">0</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; imp.<span class="function"><span class="title">fit</span><span class="params">(X)</span></span></span><br><span class="line"><span class="function"><span class="title">Imputer</span><span class="params">(axis=<span class="number">0</span>, copy=True, missing_values=<span class="number">0</span>, strategy=<span class="string">'mean'</span>, verbose=<span class="number">0</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; X_test = sp.<span class="function"><span class="title">csc_matrix</span><span class="params">([[<span class="number">0</span>, <span class="number">2</span>], [<span class="number">6</span>, <span class="number">0</span>], [<span class="number">7</span>, <span class="number">6</span>]])</span></span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">print</span><span class="params">(imp.transform(X_test)</span></span>)                      </span><br><span class="line">[[ <span class="number">4</span>.          <span class="number">2</span>.        ]</span><br><span class="line"> [ <span class="number">6</span>.          <span class="number">3.666</span>...]</span><br><span class="line"> [ <span class="number">7</span>.          <span class="number">6</span>.        ]]</span><br></pre></td></tr></table></figure>
<p>本文讲解的比较接单，如果对这些不是很理解的话，请到scikit-learn的官网中查看英文版本：<a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing" target="_blank" rel="external">preprocessing</a>.</p>
<h2 id="References"><strong>References</strong></h2><ul>
<li><a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing" target="_blank" rel="external">Scikit-learn preprocessing</a>.</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文主要是对照<a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing">scikit-learn的preprocessing</a>章节结合代码简单的回顾下预处理技术的几种方法，主要包括标准化、数据最大最小缩放处理、正则化、特征二值化和数据缺失值处理。内容比较简单，仅供参考！</p>
<p>首先来回顾一下下面要用到的基本知识。</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="scikit-learn" scheme="http://csuldw.github.io/tags/scikit-learn/"/>
    
      <category term="预处理" scheme="http://csuldw.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习之特征工程]]></title>
    <link href="http://csuldw.github.io/2015/10/24/2015-10-24%20feature%20engineering/"/>
    <id>http://csuldw.github.io/2015/10/24/2015-10-24 feature engineering/</id>
    <published>2015-10-24T02:24:00.000Z</published>
    <updated>2016-03-13T05:55:50.418Z</updated>
    <content type="html"><![CDATA[<p>在这个振奋人心的程序员节日里，我决定认真地写一篇文章来纪念一下自己这长达六年程序员史。o(╯□╰)o</p>
<p>本文是一篇关于特征工程的总结类文章，如有不足之处或理解有偏差的地方，还望多多指教。</p>
<p>首先，给一张特征工程的思维导图吧：</p>
<p><img src="http://ww1.sinaimg.cn/large/637f3c58gw1exd7mcjk7yj28k33uwaoe.jpg" alt="特征工程"></p>
<a id="more"></a>
<center><br><font color="green"><strong>【如果要浏览图片，建议将其下载到本地，使用图片浏览软件查看】</strong></font><br></center>

<p>关于特征工程（Feature Engineering），已经是很古老很常见的话题了，坊间常说：“数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已”。由此可见，特征工程在机器学习中占有相当重要的地位。在实际应用当中，可以说特征工程是机器学习成功的关键。纵观Kaggle、KDD等国内外大大小小的比赛，每个竞赛的冠军其实并没有用到很高深的算法，大多数都是在特征工程这个环节做出了出色的工作，然后使用一些常见的算法，比如LR，就能得到出色的性能。遗憾的是，在很多的书籍中并没有直接提到Feature Engineering，更多的是Feature selection。这也并不，很多ML书籍都是以讲解算法为主，他们的目的是从理论到实践来理解算法，所以用到的数据要么是使用代码生成的，要么是已经处理好的数据，并没有提到特征工程。在这篇文章，我打算自我总结下特征工程，让自己对特征工程有个全面的认识。在这我要说明一下，我并不是说那些书写的不好，其实都很有不错，主要是因为它们的目的是理解算法，所以直接给出数据相对而言对于学习和理解算法效果更佳。</p>
<p>这篇文章主要从以下三个问题出发来理解特征工程：</p>
<ul>
<li>特征工程是什么？</li>
<li>为什么要做特征工程？</li>
<li>应该如何做特征工程？</li>
</ul>
<p>对于第一个问题，我会通过特征工程的目的来解释什么是特征工程。对于第二个问题，主要从特征工程的重要性来阐述。对于第三个问题，我会从特征工程的子问题以及简单的处理方法来进一步说明。下面来看看详细内容！</p>
<hr>
<h2 id="1、特征工程是什么"><strong>1、特征工程是什么</strong></h2><p>首先来解释下什么是特征工程？</p>
<p>当你想要你的预测模型性能达到最佳时，你要做的不仅是要选取最好的算法，还要尽可能的从原始数据中获取更多的信息。那么问题来了，<font color="red">你应该如何为你的预测模型得到更好的数据呢？</font></p>
<p>想必到了这里你也应该猜到了，是的，这就是特征工程要做的事，它的目的就是<font color="red">获取更好的训练数据</font>。</p>
<p>关于特征工程的定义，Wikipedia上是这样说的：</p>
<pre><code>Feature engineering is <span class="operator">the</span> <span class="built_in">process</span> <span class="operator">of</span> <span class="keyword">using</span> domain knowledge <span class="operator">of</span> <span class="operator">the</span> data <span class="built_in">to</span> <span class="built_in">create</span> features that make machine learning algorithms work. ”
</code></pre><p>我的理解：</p>
<pre><code>特征工程是利用数据领域的相关知识来创建能够使机器学习算法达到最佳性能的特征的过程。
</code></pre><p>简而言之，特征工程就是一个把原始数据转变成特征的过程，这些特征可以很好的描述这些数据，并且利用它们建立的模型在未知数据上的表现性能可以达到最优（或者接近最佳性能）。从数学的角度来看，特征工程就是人工地去设计输入变量X。</p>
<p>特征工程更是一门艺术，跟编程一样。导致许多机器学习项目成功和失败的主要因素就是使用了不同的特征。说了这么多，想必你也大概知道了为什么要做特征工程，下面来说说特征工程的重要性。</p>
<hr>
<h2 id="2、特征工程的重要性"><strong>2、特征工程的重要性</strong></h2><p>OK！知道了特征工程是什么，那么我们必须要来了解下特征工程的重要性，为什么在实际工作中都要有特征工程这个过程，下面不同的角度来分析一下。</p>
<p>首先，我们大家都知道，数据特征会直接影响我们模型的预测性能。你可以这么说：“选择的特征越好，最终得到的性能也就越好”。这句话说得没错，但也会给我们造成误解。事实上，<font color="green">你得到的实验结果取决于你选择的模型、获取的数据以及使用的特征，甚至你问题的形式和你用来评估精度的客观方法也扮演了一部分</font>。此外，你的实验结果还受到许多相互依赖的属性的影响，你需要的是能够很好地描述你数据内部结构的好特征。</p>
<p><strong>（1）特征越好，灵活性越强</strong></p>
<p>只要特征选得好，即使是一般的模型（或算法）也能获得很好的性能，因为大多数模型（或算法）在好的数据特征下表现的性能都还不错。<font color="red">好特征的灵活性在于它允许你选择不复杂的模型，同时运行速度也更快，也更容易理解和维护</font>。</p>
<p><strong>（2）特征越好，构建的模型越简单</strong></p>
<p>有了好的特征，即便你的参数不是最优的，你的模型性能也能仍然会表现的很nice，所以你就不需要花太多的时间去寻找最有参数，这大大的降低了模型的复杂度，使模型趋于简单。</p>
<p><strong>（3）特征越好，模型的性能越出色</strong></p>
<p>显然，这一点是毫无争议的，我们进行特征工程的最终目的就是提升模型的性能。</p>
<p>下面从特征的子问题来分析下特征工程。</p>
<hr>
<h2 id="3、特征工程子问题"><strong>3、特征工程子问题</strong></h2><p>大家通常会把特征工程看做是一个问题。事实上，在特征工程下面，还有许多的子问题，主要包括：Feature Selection（特征选择）、Feature Extraction（特征提取）和Feature construction（特征构造）.下面从这三个子问题来详细介绍。</p>
<h3 id="3-1_特征选择Feature_Selection"><strong>3.1 特征选择Feature Selection</strong></h3><p>首先，从特征开始说起，假设你现在有一个标准的Excel表格数据，它的每一行表示的是一个观测样本数据，表格数据中的每一列就是一个特征。在这些特征中，有的特征携带的信息量丰富，有的（或许很少）则属于无关数据（irrelevant data），我们可以通过特征项和类别项之间的相关性（特征重要性）来衡量。比如，在实际应用中，常用的方法就是使用一些评价指标单独地计算出单个特征跟类别变量之间的关系。如Pearson相关系数，Gini-index（基尼指数），IG（信息增益）等，下面举Pearson指数为例，它的计算方式如下：</p>
<p>$$r_{xy}^2=(\frac{con(x,y)}{\sqrt{var(x)var(y)}})$$</p>
<p>其中，x属于X，X表一个特征的多个观测值，y表示这个特征观测值对应的类别列表。</p>
<p>Pearson相关系数的取值在0到1之间，如果你使用这个评价指标来计算所有特征和类别标号的相关性，那么得到这些相关性之后，你可以将它们从高到低进行排名，然后选择一个子集作为特征子集（比如top 10%），接着用这些特征进行训练，看看性能如何。此外，你还可以画出不同子集的一个精度图，根据绘制的图形来找出性能最好的一组特征。</p>
<p>这就是特征工程的子问题之一——特征选择，它的目的是<font color="red"><strong>从特征集合中挑选一组最具统计意义的特征子集，从而达到降维的效果</strong></font>。</p>
<p>做特征选择的原因是因为这些特征对于目标类别的作用并不是相等的，一些无关的数据需要删掉。做特征选择的方法有多种，上面提到的这种特征子集选择的方法属于filter（刷选器）方法，它主要侧重于单个特征跟目标变量的相关性。优点是计算时间上较高效,对于过拟合问题也具有较高的鲁棒性。缺点就是倾向于选择冗余的特征,因为他们不考虑特征之间的相关性,有可能某一个特征的分类能力很差，但是它和某些其它特征组合起来会得到不错的效果。另外做特征子集选取的方法还有wrapper（封装器）和Embeded(集成方法)。wrapper方法实质上是一个分类器，封装器用选取的特征子集对样本集进行分类，分类的精度作为衡量特征子集好坏的标准,经过比较选出最好的特征子集。常用的有逐步回归（Stepwise regression）、向前选择（Forward selection）和向后选择（Backward selection）。它的优点是考虑了特征与特征之间的关联性，缺点是：当观测数据较少时容易过拟合，而当特征数量较多时,计算时间又会增长。对于Embeded集成方法，它是学习器自身自主选择特征，如使用Regularization做特征选择，或者使用决策树思想，细节这里就不做介绍了。这里还提一下，在做实验的时候，我们有时候会用Random Forest和Gradient boosting做特征选择，本质上都是基于决策树来做的特征选择，只是细节上有些区别。</p>
<p>综上所述，特征选择过程一般包括产生过程，评价函数，停止准则，验证过程，这4个部分。如下图所示：</p>
<center><br><img src="/assets/images/feature selection.png" alt="feature selection"><br></center>


<p>(1) <strong>产生过程( Generation Procedure )</strong>：产生过程是搜索特征子集的过程，负责为评价函数提供特征子集。搜索特征子集的过程有多种，将在2.2小节展开介绍。<br>(2) <strong>评价函数( Evaluation Function )</strong>：评价函数是评价一个特征子集好坏程度的一个准则。评价函数将在2.3小节展开介绍。<br>(3) <strong>停止准则( Stopping Criterion )</strong>：停止准则是与评价函数相关的，一般是一个阈值，当评价函数值达到这个阈值后就可停止搜索。<br>(4) <strong>验证过程( Validation Procedure )</strong> ：在验证数据集上验证选出来的特征子集的有效性。</p>
<h3 id="3-2_特征提取"><strong>3.2 特征提取</strong></h3><p>特征提取的子问题之二——特征提取。</p>
<p>原则上来讲，特征提取应该在特征选择之前。特征提取的对象是原始数据（raw data），它的目的是<font color="red"><strong>自动地构建新的特征，将原始特征转换为一组具有明显物理意义（Gabor、几何特征[角点、不变量]、纹理[LBP HOG]）或者统计意义或核的特征</strong></font>。比如通过变换特征取值来减少原始数据中某个特征的取值个数等。对于表格数据，你可以在你设计的特征矩阵上使用主要成分分析（Principal Component Analysis，PCA)来进行特征提取从而创建新的特征。对于图像数据，可能还包括了线或边缘检测。</p>
<p>常用的方法有：</p>
<ul>
<li>PCA (Principal component analysis，主成分分析)</li>
<li>ICA (Independent component analysis，独立成分分析)</li>
<li>LDA （Linear Discriminant Analysis，线性判别分析）</li>
</ul>
<p>对于图像识别中，还有SIFT方法。</p>
<h3 id="3-3_特征构建_Feature_Construction"><strong>3.3 特征构建 Feature Construction</strong></h3><p>特征提取的子问题之二——特征构建。</p>
<p>在上面的特征选择部分，我们提到了对特征重要性进行排名。那么，这些特征是如何得到的呢？在实际应用中，显然是不可能凭空而来的，需要我们手工去构建特征。关于特征构建的定义，可以这么说：<font color="green"><strong>特征构建指的是从原始数据中人工的构建新的特征</strong></font>。我们需要人工的创建它们。这需要我们花大量的时间去研究真实的数据样本，思考问题的潜在形式和数据结构，同时能够更好地应用到预测模型中。</p>
<p>特征构建需要很强的洞察力和分析能力，要求我们能够从原始数据中找出一些具有物理意义的特征。假设原始数据是表格数据，一般你可以使用混合属性或者组合属性来创建新的特征，或是分解或切分原有的特征来创建新的特征。</p>
<hr>
<h2 id="4、特征工程处理过程"><strong>4、特征工程处理过程</strong></h2><p>那么问题来了，特征工程具体是在哪个步骤做呢？</p>
<p>具体的机器学习过程是这样的一个过程：</p>
<ul>
<li>1.（Task before here）</li>
<li>2.选择数据(Select Data): 整合数据，将数据规范化成一个数据集，收集起来.</li>
<li>3.数据预处理（Preprocess Data）: 数据格式化，数据清理，采样等.</li>
<li>4.数据转换（Transform Data）: <font color="red"><strong>这个阶段做特征工程</strong></font>.</li>
<li>5.数据建模（Model Data）: 建立模型，评估模型并逐步优化.</li>
<li>(Tasks after here…)</li>
</ul>
<p>我们发现，特征工程和数据转换其实是等价的。<font color="red"><strong>事实上，特征工程是一个迭代过程，我们需要不断的设计特征、选择特征、建立模型、评估模型，然后才能得到最终的model</strong></font>。下面是特征工程的一个迭代过程：</p>
<ul>
<li>1.头脑风暴式特征：意思就是进你可能的从原始数据中提取特征，暂时不考虑其重要性，对应于特征构建；</li>
<li>2.设计特征：根据你的问题，你可以使用自动地特征提取，或者是手工构造特征，或者两者混合使用；</li>
<li>3.选择特征：使用不同的特征重要性评分和特征选择方法进行特征选择；</li>
<li>4.评估模型：使用你选择的特征进行建模，同时使用未知的数据来评估你的模型精度。</li>
</ul>
<p>By the way, 在做feature selection的时候，会涉及到特征学习（Feature Learning），这里说下特征学习的概念，一般而言，特征学习（Feature Learning）是指学习输入特征和一个训练实例真是类别之间的关系。</p>
<p>下面举个例子来简单了解下特征工程的处理。</p>
<p>首先是来说下特征提取，假设你的数据里现在有一个颜色类别的属性，比如是“item_Color”,它的取值有三个，分别是：<em>red，blue，unknown</em>。从特征提取的角度来看，你可以将其转化成一个二值特征“<em>has_color</em>”，取值为1或0。其中1表示有颜色，0表示没颜色。你还可以将其转换成三个二值属性：<em>Is_Red, Is_Blue and Is_Unknown</em>。这样构建特征之后，你就可以使用简单的线性模型进行训练了。</p>
<p>另外再举一个例子，假设你有一个日期时间 (i.e. 2014-09-20T20:45:40Z)，这个该如何转换呢？</p>
<p>对于这种时间的数据，我们可以根据需求提取出多种属性。比如，如果你想知道某一天的时间段跟其它属性的关系，你可以创建一个数字特征“<strong>Hour_Of_Day</strong>”来帮你建立一个回归模型，或者你可以建立一个序数特征，“Part_Of_Day”,取值“<em>Morning,Midday,Afternoon,Night</em>”来关联你的数据。</p>
<p>此外，你还可以按星期或季度来构建属性，等等等等……</p>
<p>关于特征构建，主要是尽可能的从原始数据中构建特征，而特征选择，经过上面的分析，想必大家也知道了，其实就是达到一个降维的效果。</p>
<p>只要分析能力和实践能力够强，那么特征构建和特征提取对你而言就会显得相对比较简单，所以抓紧时间好好实践吧！</p>
<hr>
<h2 id="Conclusion"><strong>Conclusion</strong></h2><p>恩。说了这么多，大家可能对特征工程、特征选择、特征提取和特征构建有点混乱了，下面来简单的做个总结：</p>
<p>首先来说说这几个术语：</p>
<ul>
<li>特征工程：利用数据领域的相关知识来创建能够使机器学习算法达到最佳性能的特征的过程。</li>
<li>特征构建：是原始数据中人工的构建新的特征。</li>
<li>特征提取：自动地构建新的特征，将原始特征转换为一组具有明显物理意义或者统计意义或核的特征。</li>
<li>特征选择：从特征集合中挑选一组最具统计意义的特征子集，从而达到降维的效果</li>
</ul>
<p>了解这几个术语的意思后，我们来看看他们之间的关系。</p>
<p>在Quora中有人这么说：</p>
<p>Feature engineering is a super-set of  activities which include feature extraction, feature construction and feature selection. Each of the three are important steps and none should be ignored. We could make a generalization of the importance though, from my experience the relative importance of the steps would be feature construction &gt; feature extraction &gt; feature selection.</p>
<p>用中文来说就是：<font color="green"><strong>特征工程是一个超集，它包括特征提取、特征构建和特征选择这三个子模块。在实践当中，每一个子模块都非常重要，忽略不得。根据答主的经验，他将这三个子模块的重要性进行了一个排名，即：特征构建&gt;特征提取&gt;特征选择。</strong></font></p>
<p>事实上，真的是这样，<font color="red"><strong>如果特征构建做的不好，那么它会直接影响特征提取，进而影响了特征选择，最终影响模型的性能</strong></font>。</p>
<p>OK！关于特征工程就到此为止吧，如果有纰漏的地方，还望多多指导！作为一枚行走在ML界的程序员，就让我们快乐的建模，快乐的做特征工程吧^_^！Happy coding, happy modeling！</p>
<h2 id="References"><strong>References</strong></h2><ul>
<li><a href="https://www.quora.com/What-are-some-general-tips-on-feature-selection-and-engineering-that-every-data-scientist-should-know" target="_blank" rel="external">Neglected machine learning ideas</a></li>
<li><a href="http://blog.kaggle.com/2013/04/10/qa-with-xavier-conort/" target="_blank" rel="external">Q&amp;A with Xavier Conort</a></li>
<li><a href="https://www.quora.com/What-is-feature-engineering" target="_blank" rel="external">https://www.quora.com/What-is-feature-engineering</a></li>
<li><a href="https://en.wikipedia.org/wiki/Feature_engineering" target="_blank" rel="external">Feature_engineering-wikipedia</a></li>
<li><a href="http://machinelearningmastery.com/an-introduction-to-feature-selection/" target="_blank" rel="external">An Introduction to Feature Selection</a></li>
<li><a href="http://machinelearningmastery.com/discover-feature-engineering-how-to-engineer-features-and-how-to-get-good-at-it/" target="_blank" rel="external">Discover Feature Engineering, How to Engineer Features and How to Get Good at It</a></li>
<li><a href="https://www.quora.com/How-valuable-do-you-think-feature-selection-is-in-machine-learning-Which-do-you-think-improves-accuracy-more-feature-selection-or-feature-engineering" target="_blank" rel="external">How valuable do you think feature selection is in machine learning? Which do you think improves accuracy more, feature selection or feature engineering?</a></li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>在这个振奋人心的程序员节日里，我决定认真地写一篇文章来纪念一下自己这长达六年程序员史。o(╯□╰)o</p>
<p>本文是一篇关于特征工程的总结类文章，如有不足之处或理解有偏差的地方，还望多多指教。</p>
<p>首先，给一张特征工程的思维导图吧：</p>
<p><img src="http://ww1.sinaimg.cn/large/637f3c58gw1exd7mcjk7yj28k33uwaoe.jpg" alt="特征工程"></p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="特征工程" scheme="http://csuldw.github.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows下使用 git push 命令的无密码设置]]></title>
    <link href="http://csuldw.github.io/2015/10/21/2015-10-21%20Windows%20git%20push%20no%20password/"/>
    <id>http://csuldw.github.io/2015/10/21/2015-10-21 Windows git push no password/</id>
    <published>2015-10-21T08:45:44.000Z</published>
    <updated>2016-03-08T08:52:45.375Z</updated>
    <content type="html"><![CDATA[<p>在使用git时，每次进行git push时都需要输入用户名和密码，简直让人抓狂呀。下面介绍一种方法，可以避免用户名和密码输入，节省大量时间。</p>
<h2 id="1-添加环境变量">1.添加环境变量</h2><p>首先在系统变量中添加一个环境变量HOME，内容为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOME<span class="preprocessor">%</span>USERPROFILE<span class="preprocessor">%</span></span><br></pre></td></tr></table></figure>
<center><br><img src="http://ww4.sinaimg.cn/large/637f3c58gw1exbx3roqvcj20bo0cadgy.jpg" alt="配置环境变量"><br></center>

<a id="more"></a>
<h2 id="2-新建配置文件">2.新建配置文件</h2><p>由于使用的是Windows，所以进入%HOME%目录（如我的:C:\Users\username），新建一个名为”_netrc”的文件，文件中内容格式如下：</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">machine github.com</span><br><span class="line">login your-username</span><br><span class="line"><span class="literal">password</span> your-<span class="literal">password</span></span><br></pre></td></tr></table></figure>
<p>接着，打开git bash后，输入git push 命令就无需再输入用户名和密码了。</p>
<p>爽歪歪啦~</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用git时，每次进行git push时都需要输入用户名和密码，简直让人抓狂呀。下面介绍一种方法，可以避免用户名和密码输入，节省大量时间。</p>
<h2 id="1-添加环境变量">1.添加环境变量</h2><p>首先在系统变量中添加一个环境变量HOME，内容为</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOME<span class="preprocessor">%</span>USERPROFILE<span class="preprocessor">%</span></span><br></pre></td></tr></table></figure>
<center><br><img src="http://ww4.sinaimg.cn/large/637f3c58gw1exbx3roqvcj20bo0cadgy.jpg" alt="配置环境变量"><br></center>]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://csuldw.github.io/tags/GitHub/"/>
    
      <category term="GitHub" scheme="http://csuldw.github.io/categories/GitHub/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习-个人资料整理]]></title>
    <link href="http://csuldw.github.io/2015/09/23/2015-09-23%20Machine%20learning%20materials/"/>
    <id>http://csuldw.github.io/2015/09/23/2015-09-23 Machine learning materials/</id>
    <published>2015-09-23T14:22:22.000Z</published>
    <updated>2016-03-13T05:56:18.860Z</updated>
    <content type="html"><![CDATA[<p>学习Machine Learning也有很长一段时间了，前段时间在paper中应用了GTB（Gradient Tree Boosting）算法。在我的数据集上GTB的performance比Random Forest要稍微强一点，整个experiment做完之后，有许多东西都来不及及时整理，很多都遗忘了。打算接下来的时间里，好好整理下自己的学习资料，这份资料绝对不是一时半会就整理得完的，先开个头吧，以后会间断性更新该blog的。</p>
<p>下面来做个资料整理吧。</p>
<a id="more"></a>
<h2 id="书籍推荐"><strong>书籍推荐</strong></h2><p>机器学习的书籍很多，下面推荐几本本人用过而且觉得还不错的书籍。优于机器学习是一门跨领域的学科，所以在书籍上并非全是机器学习的书籍:</p>
<ul>
<li>1.《机器学习实战》<strong>Machine Learning in Action [美] Peter Harington 著</strong>。该书贯穿了10个最受欢迎的机器学习算法，提供了案例研究问题并用Python代码实例来解决。我本人比较喜欢这本书，因为里面的代码给了我很大的帮助，自己在学习机器学习算法的时候，理论上很多东西不太理解透，通过该书实践之后，在算法层面又有了进一步的提高。</li>
<li>2.《统计学习方法》 李航著。该书比较详细地介绍了算法的原理，只从理论层面来研究算法。通过这本书和《机器学习实战》两本书相结合，一本讲理论，一本着手实践，加在一起会有事半功倍的效果。</li>
<li>3.《数据挖掘概念与技术》 韩家炜著。该书介绍了数据挖掘的常用技术，比较详实，但本人觉得不太适合初学者，当时自己初学的时候看的就是这本书，结果最后很多地方理解的不是很好，后来通过《统计学习方法》和算法实践之后，再回头看《数据挖掘概念与技术》，感觉就轻松多了。</li>
<li>4.《数学之美》 吴军著。本书可以当做业余书籍来看，可以在无聊的时候看看，不过里面讲的东西还是挺有用的。</li>
<li>5.《Python科学计算》该书可以当做Python编程参考书籍，但前提是你喜欢使用Python，并爱上了它，不然这本书还是蛮贵的，我自己也是通过“研究生自由探索项目”才买的这本书，因为可以报销嘛。</li>
</ul>
<h2 id="学习工具"><strong>学习工具</strong></h2><p>机器学习的tools很多，这里只列出几个参考工具。</p>
<ul>
<li><a href="http://scikit-learn.org/stable/user_guide.html" target="_blank" rel="external">Scikit-learn</a>.基于Python语言的<a href="http://scikit-learn.org/stable/user_guide.html" target="_blank" rel="external">scikit-learn</a>库，里面涵盖了分类、聚类、回归的大部分算法，并且有常用的评估指标以及预处理数据的方法，是一个不错的学习库，强力推荐。附一篇博文：<a href="http://www.erogol.com/broad-view-machine-learning-libraries/" target="_blank" rel="external">SOME USEFUL MACHINE LEARNING LIBRARIES</a>.</li>
<li><a href="http://www.r-project.org/" target="_blank" rel="external">R</a>语言，语言就是一门工具，R语言现在在商业界是用的最多的，在统计方面功能强大，而且也有封装好的算法库可以直接使用。附：<a href="https://cran.r-project.org/doc/contrib/Liu-R-refcard.pdf" target="_blank" rel="external">R语言参考卡片</a>.</li>
<li><a href="http://www.cs.waikato.ac.nz/ml/weka/" target="_blank" rel="external">Weka</a>，是一个基于java开发的数据挖掘工具，可以尝试一下。它为用户提供了一系列据挖掘API、命令行和图形化用户接口。你可以准备数据、可视化、建立分类、进行回归分析、建立聚类模型，同时可以通过第三方插件执行其他算法。除了WEKA之外， <a href="http://mahout.apache.org/" target="_blank" rel="external">Mahout</a>是Hadoop中为机器学习提供的一个很好的JAVA框架，你可以自行学习。如果你是机器学习和大数据学习的新手，那么坚持学习WEKA，并且全心全意地学习一个库。</li>
<li>Matlab，里面有很多的工具包，不过本人不怎么用过。参考：<a href="http://www.cad.zju.edu.cn/home/dengcai/Data/data.html" target="_blank" rel="external">Matlab Codes and Datasets for Feature Learning</a>和<a href="http://cn.mathworks.com/products/statistics/" target="_blank" rel="external">Statistics and Machine Learning Toolbox</a>。此外matlab中的<a href="http://www.gnu.org/software/octave/" target="_blank" rel="external">Octave</a>可以很方便地解决线性和非线性问题，比如机器学习算法底层涉及的问题。如果你有工程背景，那么你可以由此入手。</li>
<li><a href="https://bigml.com/" target="_blank" rel="external">BigML</a>:可能你并不想进行编程工作。你完全可以不通过代码，来使用 WEKA那样的工具。你通过使用BigMLS的服务来进行更加深入的工作。BigML通过Web页面，提供了机器学习的接口，因此你可以通过浏览器来建立模型。</li>
<li>如果你使用Python，这里推荐一个IDE，<a href="http://sourceforge.net/projects/winpython/files/WinPython_2.7/2.7.10.1/" target="_blank" rel="external">WinPython</a>,IDE版本就是Python的版本，自行选择！</li>
</ul>
<p>下面给出一个比较图，具体想要学什么，还需自己抉择。</p>
<center><br><img src="http://img.blog.csdn.net/20150918075645450" alt="这里写图片描述"><br></center>


<h2 id="学习视频"><strong>学习视频</strong></h2><p>由于本人比较崇拜Andrew Ng，所以关于视频，首先推荐的便是Andrew Ng的斯坦福大学的机器学习课程。这套视频在网上有两个网址，国外和国内的都有，全程英语教学，内容很好，有时间建议你去听听：</p>
<ul>
<li>一个是国外的Coursera公开课，该课程在机器学习领域很火，是很多入门学者的首选。地址：<a href="https://www.coursera.org/；讲义地址：[Stanford" target="_blank" rel="external">https://www.coursera.org/；讲义地址：[Stanford</a> CS229 course下载讲义和笔记](<a href="http://cs229.stanford.edu/)；" target="_blank" rel="external">http://cs229.stanford.edu/)；</a></li>
<li>一个是国内的网易公开课，链接地址：<a href="http://open.163.com/movie/2008/1/U/O/M6SGF6VB4_M6SGJURUO.html" target="_blank" rel="external">http://open.163.com/movie/2008/1/U/O/M6SGF6VB4_M6SGJURUO.html</a></li>
</ul>
<p>下面是一个机器学习视频库，由加州理工学院（Caltech）出品。</p>
<ul>
<li>机器学习视频库，地址：<a href="http://work.caltech.edu/library/" target="_blank" rel="external">http://work.caltech.edu/library/</a></li>
</ul>
<p>其它的视频库</p>
<ul>
<li><a href="http://videolectures.net/Top/Computer_Science/Machine_Learning/" target="_blank" rel="external">Machine Learning Category on VideoLectures</a>，这个网站的视频比较多。你可以找出比较感兴趣的资源，然后深入学习。</li>
</ul>
<font color="#008B00">机器学习最近在国内比较火，许多培训机构都相应的开了该门课程，如果想要听中文教程的，可以去网上搜索下，这里就不给培训机构打广告了。</font>

<h2 id="博客和文章推荐"><strong>博客和文章推荐</strong></h2><p>大牛们的博客，会让你感到兴奋，让你觉得你不是一个人在奋斗，让你时刻记住你的前方已经有很多的学者正在等着你，你要加油。他们的经验会让我们少走些冤枉路，能让我们在他们的基础上进一步理解。下面推荐几个我所知道的或者说我了解到的几位牛人博客和几篇文章：</p>
<ul>
<li><strong>pluskid</strong>，真名张弛原，一位技术大牛，毕业于浙江大学，后来出国深造。他的博文质量非常高，深入浅出，其SVM三层境界的讲解让人茅塞顿开，应该给了很多人启发吧，很值得学习。现在的博客网址：<a href="http://pluskid.org/about.html" target="_blank" rel="external">Chiyuan Zhang</a>，原博客网址：<a href="http://blog.pluskid.org/" target="_blank" rel="external">Chiyuan Zhang</a></li>
<li><strong>Rachel Zhang</strong>，真名张睿卿，很有气质的一位软妹纸，目前是百度深度学习实验室研发工程师，在CSDN中的博客人气绝对屈指可数，算是IT界的一位女中豪杰。博客网址：<a href="http://blog.csdn.net/abcjennifer" target="_blank" rel="external">CSDN博客-Rachel Zhang</a></li>
<li><strong>July</strong>，对算法研究独具一格，目前是七月在线科技创始人兼CEO。博客网址：<a href="http://blog.csdn.net/v_JULY_v" target="_blank" rel="external">July</a></li>
<li><strong>Jason</strong>，一位国外机器学习爱好者，其博客内容详实，多篇文章被国内机器学习者翻译。博客网址：<a href="http://machinelearningmastery.com/blog/" target="_blank" rel="external">http://machinelearningmastery.com/blog/</a></li>
<li>一个国外很好的机器学习博客，里面介绍了详细的算法知识，很全面，从感知机、神经网络、决策树、SVM、Adaboost到随机森林、Deep Learning.网址：<a href="http://www.erogol.com/machine-learning/" target="_blank" rel="external">A Blog From a Human-engineer-being</a></li>
<li>一篇涵盖许多机器学习资料的文章：<a href="http://www.open-open.com/lib/view/open1428112201271.html" target="_blank" rel="external">机器学习(Machine Learning)&amp;深度学习(Deep Learning)资料</a></li>
<li><strong>Edwin Chen</strong>    ，机器学习爱好者，博客内容涵盖数学、机器学习和数据科学。分享其中一篇博文：<a href="http://blog.echen.me/2011/04/27/choosing-a-machine-learning-classifier/" target="_blank" rel="external">Choosing a Machine Learning Classifier</a>    </li>
<li>一篇以前的博文：<a href="http://conductrics.com/data-science-resources/" target="_blank" rel="external">A List of Data Science and Machine Learning Resources</a>，有时间好好阅读阅读，对你绝对有帮助。</li>
<li><a href="http://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf" target="_blank" rel="external">A Few Useful Things to Know about Machine Learning</a>,一篇很有帮助的机器学习文章，里面包括了特征选择与模型的简化。</li>
<li><a href="http://www.cs.cmu.edu/~tom/pubs/MachineLearning.pdf" target="_blank" rel="external">The Discipline of Machine Learning</a>机器学习规则。该文章比较老，2006年发布的，作者是Tom Mitchell，但很有参考价值，其中定义了机器学习的规则。Mitchell在说服CMU总裁为一个百年内都存在的问题建立一个独立的机器学习部门时，也用到了这本书中的观点。希望能对你也有所帮助。</li>
<li>分享一个网站：<a href="http://www.jianshu.com/" target="_blank" rel="external">简书</a>。</li>
</ul>
<h2 id="国外网站"><strong>国外网站</strong></h2><p>如果你想搜索比较新颖的机器学习资料或是文章，可以到以下网站中搜索，里面不仅包括了机器学习的内容，还有许多其它相关领域内容，如数据科学和云计算等。</p>
<ul>
<li>InfoWord：<a href="http://www.infoworld.com/reviews/" target="_blank" rel="external">http://www.infoworld.com/reviews/</a></li>
<li>Kdnuggets：<a href="http://www.kdnuggets.com" target="_blank" rel="external">http://www.kdnuggets.com</a></li>
<li>Datasciencecentral：<a href="http://www.datasciencecentral.com/" target="_blank" rel="external">http://www.datasciencecentral.com/</a></li>
<li>Datascienceplus：<a href="http://datascienceplus.com" target="_blank" rel="external">http://datascienceplus.com</a></li>
</ul>
<h2 id="数据科学竞赛"><strong>数据科学竞赛</strong></h2><p>关于数据分析的竞赛，国内国外都有，下面推荐几个比较火的竞赛网站 ：</p>
<ul>
<li>Kaggle比赛，网址：<a href="https://www.kaggle.com/" target="_blank" rel="external">https://www.kaggle.com/</a></li>
<li>DataCastle比赛，网站：<a href="http://www.pkbigdata.com/" target="_blank" rel="external">http://www.pkbigdata.com/</a></li>
<li>阿里大数据竞赛，目前没有消息了，2015年有个【2015天池大数据竞赛】</li>
</ul>
<h2 id="ML相关算法参考"><strong>ML相关算法参考</strong></h2><ul>
<li>决策树-参考：<a href="http://blog.csdn.net/dream_angel_z/article/details/45965463" target="_blank" rel="external">decision Tree（Python实现）</a></li>
<li>SVM支持向量机-参考：<a href="http://blog.pluskid.org/?page_id=683" target="_blank" rel="external">pluskid支持向量机三重境界</a></li>
<li>Adaboost-参考：<a href="http://www.csuldw.com/2015/07/05/2015-07-12-Adaboost/" target="_blank" rel="external">组合算法-Adaboost</a></li>
<li>Random Forest-参考：<a href="http://www.cnblogs.com/wentingtu/archive/2011/12/22/2297405.html" target="_blank" rel="external">随机森林算法</a></li>
<li>朴素贝叶斯算法-参考：<a href="http://blog.csdn.net/dream_angel_z/article/details/46120867" target="_blank" rel="external">Naive Bayes算法实现</a></li>
<li>人工神经网络-参考：<a href="http://www.cnblogs.com/luxiaoxun/archive/2012/12/10/2811309.html" target="_blank" rel="external">http://www.cnblogs.com/luxiaoxun/archive/2012/12/10/2811309.html</a></li>
<li>Apriori算法-参考地址：<a href="http://www.csuldw.com/2015/06/04/2015-06-04-Apriori/" target="_blank" rel="external">Apriori关联分析</a></li>
<li>K最近邻算法-参考：<a href="http://blog.csdn.net/dream_angel_z/article/details/45896449" target="_blank" rel="external">KNN从原理到实现</a></li>
<li>梯度树提升GTB算法-参考：<a href="http://blog.csdn.net/dream_angel_z/article/details/48085889" target="_blank" rel="external">Gradient Tree Boosting（或GBRT）</a></li>
<li>K-means聚类-参考：<a href="http://blog.csdn.net/dream_angel_z/article/details/46343597" target="_blank" rel="external">K-means cluster</a></li>
<li>组合算法总结-参考：<a href="http://www.csuldw.com/2015/07/22/2015-07-22%20%20ensemble/" target="_blank" rel="external">Ensemble算法总结</a></li>
<li>EM期望最大算法-参考：<a href="http://blog.csdn.net/zouxy09/article/details/8537620" target="_blank" rel="external">EM算法</a></li>
<li>Logistic回归-参考：<a href="http://blog.csdn.net/wangran51/article/details/8892923" target="_blank" rel="external">逻辑回归</a></li>
<li>HMM隐马尔可夫模型，参考:<a href="http://blog.csdn.net/likelet/article/details/7056068" target="_blank" rel="external">HMM</a></li>
<li>条件随机场，参考：<a href="http://www.tanghuangwhu.com/archives/162" target="_blank" rel="external">CRF</a></li>
<li>随机森林和GBDT，参考：<a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/03/07/1976562.html" target="_blank" rel="external">决策树模型组合之随机森林与GBDT</a></li>
<li>特征选择和特征提取，参考：<a href="http://blog.csdn.net/lanbing510/article/details/40488787" target="_blank" rel="external">特征提取与特征选择</a></li>
<li>梯度下降法，参考:<a href="http://blog.csdn.net/woxincd/article/details/7040944" target="_blank" rel="external">gradient descent</a></li>
<li>牛顿法，参考：<a href="http://blog.csdn.net/luoleicn/article/details/6527049" target="_blank" rel="external">牛顿法</a></li>
<li>线性判别分析，参考：<a href="http://www.cnblogs.com/jerrylead/archive/2011/04/21/2024384.html" target="_blank" rel="external">线性判别</a></li>
<li>深度学习-<a href="http://www.cnblogs.com/xiaowanyer/p/3701944.html" target="_blank" rel="external">深度学习概述：从感知机到深度网络</a></li>
</ul>
<h2 id="个人译文"><strong>个人译文</strong></h2><p>下面是本人在CSDN云计算栏目发布的翻译文章，如有翻译不准确的地方，还望多多包涵，希望能给大家带来点帮助，译文列表如下：</p>
<ul>
<li>2015-09-14 <a href="http://www.csdn.net/article/2015-09-14/2825693" target="_blank" rel="external">LSTM实现详解</a></li>
<li>2015-09-10 <a href="http://www.csdn.net/article/2015-09-08/2825646" target="_blank" rel="external">从零实现来理解机器学习算法：书籍推荐及障碍的克服</a></li>
<li>2015-08-31  <a href="http://www.csdn.net/article/2015-08-27/2825551" target="_blank" rel="external">机器学习开发者的现代化路径：不需要从统计学微积分开始</a></li>
<li>2015-08-27 <a href="http://www.csdn.net/article/2015-08-27/2825549" target="_blank" rel="external">基于Python的卷积神经网络和特征提取</a></li>
<li>2015-08-20 <a href="http://www.csdn.net/article/2015-08-19/2825492" target="_blank" rel="external">你应该掌握的七种回归技术</a></li>
<li>2015-08-11 <a href="http://www.csdn.net/article/2015-08-10/2825430" target="_blank" rel="external">机器学习API Top 10：AT&amp;T Speech、IBM Watson和Google Prediction</a></li>
<li>2015-08-03 <a href="http://www.csdn.net/article/2015-08-01/2825362" target="_blank" rel="external">从Theano到Lasagne：基于Python的深度学习的框架和库</a></li>
<li>2015-07-15 <a href="http://www.csdn.net/article/2015-07-13/2825188" target="_blank" rel="external">Airbnb欺诈预测机器学习模型设计：准确率和召回率的故事</a></li>
<li>2015-07-13 <a href="http://www.csdn.net/article/2015-07-13/2825187" target="_blank" rel="external">开发者成功使用机器学习的十大诀窍</a></li>
</ul>
<p>下面是相关译者的译文，仅供参考：</p>
<ul>
<li>2015-09-16 <a href="http://www.csdn.net/article/2015-09-15/2825714" target="_blank" rel="external">各种编程语言的深度学习库整理</a></li>
<li>2015-09-11 <a href="http://www.csdn.net/article/2015-09-08/2825647" target="_blank" rel="external">机器学习温和指南</a></li>
<li>2015-09-10 <a href="http://www.csdn.net/article/2015-09-10/2825668" target="_blank" rel="external">关于数据科学，书上不曾提及的三点经验</a></li>
</ul>
<hr>
<font color="#CD3333">从这些牛人的博客中，你能学到很多。慢慢地你会体会到，不是你一个人在战斗，还有很多人，所以你不用害怕孤独。</font>

<p>最后，关于机器学习资料的整理，先到此为止吧，如果你有什么好的资料，欢迎在评论中给出推荐或网址链接。</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>学习Machine Learning也有很长一段时间了，前段时间在paper中应用了GTB（Gradient Tree Boosting）算法。在我的数据集上GTB的performance比Random Forest要稍微强一点，整个experiment做完之后，有许多东西都来不及及时整理，很多都遗忘了。打算接下来的时间里，好好整理下自己的学习资料，这份资料绝对不是一时半会就整理得完的，先开个头吧，以后会间断性更新该blog的。</p>
<p>下面来做个资料整理吧。</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gradient Tree Boosting]]></title>
    <link href="http://csuldw.github.io/2015/08/19/2015-08-19%20GBDT/"/>
    <id>http://csuldw.github.io/2015/08/19/2015-08-19 GBDT/</id>
    <published>2015-08-19T02:54:00.000Z</published>
    <updated>2016-03-13T06:04:59.915Z</updated>
    <content type="html"><![CDATA[<h2 id="Introduction"><strong>Introduction</strong></h2><p>决策树这种算法有着很多良好的特性，比如说训练时间复杂度较低，预测的过程比较快速，模型容易展示（容易将得到的决策树做成图片展示出来）等。但是同时，单决策树又有一些不好的地方，比如说容易over-fitting，虽然有一些方法，如剪枝可以减少这种情况，但是还是不太理想。</p>
<p>模型组合（比如说有Boosting，Bagging等）与决策树相关的算法比较多，如randomForest、Adaboost、GBRT等，这些算法最终的结果是生成N(可能会有几百棵以上）棵树，这样可以大大的减少单决策树带来的毛病，有点类似于三个臭皮匠赛过一个诸葛亮的做法，虽然这几百棵决策树中的每一棵都很简单（相对于C4.5这种单决策树而言），但是他们组合起来确是很强大。虽然这些算法都是通过决策树演变过来的，但在处理的过程上有着一些差异，我会在后面对此做一个本质上的比较。下面先来介绍下本文的梯度提升算法。<br><a id="more"></a></p>
<h2 id="Gradient_Tree_Boosting"><strong>Gradient Tree Boosting</strong></h2><p>梯度树提升（Gradient Tree Boosting）是一种组合算法，也叫做梯度提升回归树（gradient boosting regression tree），它的基分类器是决策树，既可以用来回归，也可以用作分类。在分类性能上，能够和随机森林媲美，甚至在有的数据集上表现的有过之而无不及。如今，Gradient Tree Boosting模型已经广泛的运用在Web搜索排行榜以及生态学上。在阿里内部也用的比较多，所以值得我们去花点时间认真学习。</p>
<p>根据scikit-learn官网的介绍，GBRT的优势有：</p>
<ul>
<li>自然而然地处理混合类型的数据</li>
<li>预测能力强</li>
<li>在输出空间对于异常值的鲁棒性强（通过强大的损失函数）</li>
</ul>
<p>然而，GBRT也有劣势：</p>
<ul>
<li>可扩展性方面，由于提升的时序性，不能进行并行处理</li>
</ul>
<p>尽管如此，由于GTB的表现性能很好，所以它仍然受广大业界人士的青睐。下面来介绍下梯度提升树的算法原理。</p>
<h3 id="GTB算法"><strong>GTB算法</strong></h3><p>梯度提升（gradient boosting）算法最初是FreidMan在2000年提出来的，其核心就在于，每棵树是从先前所有树的残差中来学习。利用的是当前模型中损失函数的负梯度值</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%20r_%7Bmi%7D%20%3D%20-%20%5CBigg%20%5B%20%5Cfrac%20%7B%5Cpartial%20L%28y_i%2C%20f%20%28x_i%29%29%7D%7B%5Cpartial%20f%20%28x_i%29%7D%5CBigg%20%5D%20_%7Bf%20%28x%29%20%3D%20f%20_%7Bm-1%7D%28x%29%7D%24%24" alt=""></p>
<p>作为提升树算法中的残差的近似值，进而拟合一棵回归（分类）树。</p>
<p>梯度提升属于Boost算法的一种，也可以说是Boost算法的一种改进，原始的Boost算法是:<font color="#007fff"><strong>在算法开始时，为每一个样本赋上一个相等的权重值，也就是说，最开始的时候，大家都是一样重要的。在每一次训练中得到的模型，会使得数据点的估计有所差异，所以在每一步结束后，我们需要对权重值进行处理，而处理的方式就是通过增加错分类点的权重，同时减少错分类点的权重，这样使得某些点如果老是被分错，那么就会被“严重关注”，也就被赋上一个很高的权重。然后等进行了N次迭代（由用户指定），将会得到N个简单的基分类器（basic learner），最后将它们组合起来，可以对它们进行加权（错误率越大的基分类器权重值越小，错误率越小的基分类器权重值越大）、或者让它们进行投票等得到一个最终的模型</strong></font>。</p>
<p>Gradient Boost与传统的Boost有着很大的区别，<font color="#007fff"><strong>它的每一次计算都是为了减少上一次的残差(residual)，而为了减少这些残差，可以在残差减少的梯度(Gradient)方向上建立一个新模型</strong></font>。所以说，在Gradient Boost中，每个新模型的建立是为了使得先前模型残差往梯度方向减少，与传统的Boost算法对正确、错误的样本进行加权有着极大的区别。</p>
<h4 id="梯度提升算法（以回归为例）"><strong>梯度提升算法（以回归为例）</strong></h4><p>对于给定的输入：训练数据集T={(x1,y1),(x2,y2),…,(xn,yn)},损失函数L(y,f(x));<br>输出结果：一棵回归树$\tilde{f}(x)$</p>
<hr>
<p>（1）首先初始化</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24f_0%28x%29%3D%5Carg%20%5C%20%5Cmin_c%20%5Csum_%7Bi%3D1%7D%5E%7BN%7DL%28y_i%2C%20c%29%24%24" alt="$$f_0(x)=\arg \ \min_c \sum_{i=1}^{N}L(y_i, c)$$"></p>
<p>估计一个使损失函数极小化的常数值，此时它只有一个节点的树；<br>（2）迭代的建立M棵提升树</p>
<p>for m=1 to M:（第一层循环）<br>for i=1 to N：（第二层循环） 计算损失函数的负梯度在当前模型的值，并将它作为残差的估计值。</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%20r_%7Bmi%7D%20%3D%20-%20%5CBigg%20%5B%20%5Cfrac%20%7B%5Cpartial%20L%28y_i%2C%20f%20%28x_i%29%29%7D%7B%5Cpartial%20f%20%28x_i%29%7D%5CBigg%20%5D%20_%7Bf%20%28x%29%20%3D%20f%20_%7Bm-1%7D%28x%29%7D%24%24" alt=""></p>
<p>对于r_mi拟合一棵回归树，得到第m棵树的叶节点区域 $R_{mj} ,j=1,2,…,J$</p>
<p>for j=1 to J：（第二层循环）,计算：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24c_%7Bmj%7D%20%3D%20arg%20min_c%20%5Csum_%7Bx_i%5Cepsilon%20R_%7Bmj%7D%7DL%28y_i%2Cf_%7Bm-1%7D%28x_i%29&plus;c%29%24%24" alt=""></p>
<p>利用线性搜索估计叶节点区域的值，使损失函数极小化；</p>
<p>然后，更新</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24f_%7Bm%7D%28x%29%20%3D%20f_%7Bm-1%7D%28x%29%20&plus;%20%5Csum_%7Bj%3D1%7D%5EJc_%7Bmj%7DI%28x%20%5Cepsilon%20R_%7Bmj%7D%29%24%24" alt=""></p>
<p>（3）最后得到的$f_{m}(x)$就是我们最终的模型</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%5Ctilde%7Bf%7D%28x%29%3Df_M%28x%29%3D%5Csum_%7Bm%3D1%7D%5EM%5Csum_%7Bj%3D1%7D%5EJc_%7Bmj%7DI%28x%20%5Cepsilon%20R_%7Bmj%7D%29%24%24" alt=""></p>
<p>从式子中也可以看出，GBDT算法是一个加和模型，并在推导中结合了前向分步算法。</p>
<hr>
<h4 id="使用scikit-learn中的GTB"><strong>使用scikit-learn中的GTB</strong></h4><p>在scikit-learn中对GTB算法有了很好的封装，对于分类可以选择的损失函数有逻辑回归和指数函数，对于回归的损失函数相对比较多，有最小二乘法、最小绝对偏差函数、huber以及分位数等。具体描述参考下面的图片：<br><img src="file:///C:/Users/liudiwei/Desktop/QQ截图20150829104337.png" alt=""></p>
<p>下面是sklearn中的一个分类原例：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn.datasets import make_hastie_10_2</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn.ensemble import <span class="constant">GradientBoostingClassifier</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X</span>, y = make_hastie_10_2(random_state=<span class="number">0</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X_train</span>, <span class="constant">X_test</span> = <span class="constant">X</span>[<span class="symbol">:</span><span class="number">2000</span>], <span class="constant">X</span>[<span class="number">2000</span><span class="symbol">:</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; y_train, y_test = y[<span class="symbol">:</span><span class="number">2000</span>], y[<span class="number">2000</span><span class="symbol">:</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = <span class="constant">GradientBoostingClassifier</span>(n_estimators=<span class="number">100</span>, learning_rate=<span class="number">1.0</span>,</span><br><span class="line">...     max_depth=<span class="number">1</span>, random_state=<span class="number">0</span>).fit(<span class="constant">X_train</span>, y_train)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf.score(<span class="constant">X_test</span>, y_test)                 </span><br><span class="line"><span class="number">0</span>.<span class="number">913</span>...</span><br></pre></td></tr></table></figure>
<p>其中n_estimators表示弱分类器的个数，learning_rate表示学习率，max_depth表示最大的深度等。GTB的参数比较多，在实际应用中需要自己去调整合适的参数。</p>
<h2 id="基于决策树的组合算法比较"><strong>基于决策树的组合算法比较</strong></h2><p>基于决策树的组合算法常用的有三个，分别是Adaboost、RandomFrest以及本文的GBRT。</p>
<p>Adaboost是通过迭代的学习每一个基分类器，每次迭代中，把上一次错分类的数据权值增大，正确分类的数据权值减小，然后将基分类器的线性组合作为一个强分类器，同时给分类误差率较小的基本分类器以大的权值，给分类误差率较大的基分类器以小的权重值。Adaboost使用的是自适应的方法，其中概率分布式变化的，关注的是难分类的样本。详细内容请参考我之前的文章：<a href="http://blog.csdn.net/dream_angel_z/article/details/46764845" target="_blank" rel="external">机器学习算法-Adaboost</a>。</p>
<p>随机森林RandomForest算法，与adaboost有错区别，可以说一种改进的装袋组合算法。随机森林则(randomForest)，不仅对样本进行抽样，还对变量进行抽样。它通过随机的方式建立一个森林，森林里面有许多棵决策树，并且每一棵树之间是没有联系的。在得到森林之后，当有一个新的输入样本进来的时候，就让森林中的每一棵决策树分别对其进行判断，看这个样本应该属于哪一类（就分类算法而言），然后看看哪一类选择最多，就预测这个样本为该类。在建立每一棵决策树的过程中，有两点需要注意，即<font color="red"><strong>采样</strong></font>与<font color="red"><strong>完全分裂</strong></font>。首先是两个随机采样的过程，RF对输入的数据要进行行采样和列采样。对于行采样，是采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为N个，那么采样的样本也为N个。这样使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现over-fitting过拟合。然后进行列采样，从M个feature特征中，选择m个(m &lt;&lt; M)。之后就是对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面的所有样本的都是指向的同一个类别。一般很多的决策树算法都一个重要的步骤-剪枝，但是这里不这样干，由于之前的两个随机采样的过程保证了随机性，所以就算不剪枝，也不会出现over-fitting。按照这种算法得到的随机森林中的每一棵决策树都是非常弱的，但当它们组合在一起的时候，就相当厉害了。随机森林就好比是：每一棵决策树就是一个精通于某一领域的专家（因为我们从M个feature中选择m个让每一棵决策树进行学习），这样在随机森林中就有了很多个精通不同领域的专家，对一个新的问题（新的输入数据），可以用不同的角度去看待它，最终由各个专家，投票得到结果。随机森林的分类准确率可以与adaboost媲美。它对噪声数据更加鲁棒，运行速度比adaboost也快得多。</p>
<p><font color="#007FFF"><strong>对于梯度提升树，它的每一次计算都是为了减少上一次的残差(residual)，而为了减少这些残差，可以在残差减少的梯度(Gradient)方向上建立一个新模型。</strong></font>这与adaboost和随机森林有很大的区别。</p>
<h3 id="References">References</h3><p>[1] Introduction to Data Mining 数据挖掘概论. Pang-Ning Tan Michael Steinbach Vipin Kumar著<br>[2] 统计学习方法 李航 著<br>[3] scikit-learn官网组合算法 <a href="http://scikit-learn.org/stable/modules/ensemble.html#gradient-boosting" target="_blank" rel="external">点击这里</a></p>
<p>参考文章： <a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/03/07/1976562.html" target="_blank" rel="external">随机森林与GBDT</a></p>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Introduction"><strong>Introduction</strong></h2><p>决策树这种算法有着很多良好的特性，比如说训练时间复杂度较低，预测的过程比较快速，模型容易展示（容易将得到的决策树做成图片展示出来）等。但是同时，单决策树又有一些不好的地方，比如说容易over-fitting，虽然有一些方法，如剪枝可以减少这种情况，但是还是不太理想。</p>
<p>模型组合（比如说有Boosting，Bagging等）与决策树相关的算法比较多，如randomForest、Adaboost、GBRT等，这些算法最终的结果是生成N(可能会有几百棵以上）棵树，这样可以大大的减少单决策树带来的毛病，有点类似于三个臭皮匠赛过一个诸葛亮的做法，虽然这几百棵决策树中的每一棵都很简单（相对于C4.5这种单决策树而言），但是他们组合起来确是很强大。虽然这些算法都是通过决策树演变过来的，但在处理的过程上有着一些差异，我会在后面对此做一个本质上的比较。下面先来介绍下本文的梯度提升算法。<br>]]>
    
    </summary>
    
      <category term="GBDT" scheme="http://csuldw.github.io/tags/GBDT/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="组合算法" scheme="http://csuldw.github.io/tags/%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从Theano到Lasagne：基于Python的深度学习的框架和库（译文）]]></title>
    <link href="http://csuldw.github.io/2015/08/12/2015-08-12-theano-to-lasagne/"/>
    <id>http://csuldw.github.io/2015/08/12/2015-08-12-theano-to-lasagne/</id>
    <published>2015-08-12T12:24:00.000Z</published>
    <updated>2016-03-13T10:22:05.428Z</updated>
    <content type="html"><![CDATA[<p>英文链接：<a href="http://creative-punch.net/2015/07/frameworks-and-libraries-for-deep-learning/" target="_blank" rel="external">http://creative-punch.net/2015/07/frameworks-and-libraries-for-deep-learning/</a></p>
<p>深度学习是机器学习和人工智能的一种形式，利用堆积在彼此顶部的神经网络的多个隐藏层来尝试形成对数据更深层次的“理解”。</p>
<p>最近，深度神经网络以“Deep Dreams”形式在网站中如雨后春笋般出现，或是像谷歌研究原创论文中描述的那样：Inceptionism。</p>
<p>在这篇文章中，我们将讨论几个不同的深度学习框架，库以及工具。</p>
<a id="more"></a>
<h2 id="Python深度学习">Python深度学习</h2><h3 id="Theano">Theano</h3><p>主页：<a href="http://deeplearning.net/software/theano/" target="_blank" rel="external">http://deeplearning.net/software/theano/</a></p>
<p>Github网址：<a href="https://github.com/Theano/Theano" target="_blank" rel="external">https://github.com/Theano/Theano</a></p>
<p>Theano不仅是这篇文章中将要讨论的其他框架的核心库，于其自身而言，它也是一个强大的库，几乎能在任何情况下使用，从简单的logistic回归到建模并生成音乐和弦序列或是使用长短期记忆人工神经网络对电影收视率进行分类。</p>
<p>Theano大部分代码是使用Cython编写，Cython是一个可编译为本地可执行代码的Python方言，与仅仅使用解释性Python语言相比，它能够使运行速度快速提升。最重要的是，很多优化程序已经集成到Theano库中，它能够优化你的计算量并让你的运行时间保持最低。</p>
<p>如果速度的提升还不能满足你，它还内置支持使用CUDA在GPU上执行那些所有耗时的计算。所有的这一切仅仅只需要修改配置文件中的标志位即可。在CPU上运行一个脚本，然后切换到GPU，而对于你的代码，则不需要做任何变化。</p>
<p>同时我们应该注意到，尽管Theano使用Cython和CUDA对其性能大大提升，但你仍然可以仅仅使用Python语言来创建几乎任何类型的神经网络结构。</p>
<h3 id="Pylearn2">Pylearn2</h3><p>主页：<a href="http://deeplearning.net/software/pylearn2/" target="_blank" rel="external">http://deeplearning.net/software/pylearn2/</a></p>
<p>Github网址：<a href="https://github.com/lisa-lab/pylearn2" target="_blank" rel="external">https://github.com/lisa-lab/pylearn2</a></p>
<p>Pylearn2和Theano由同一个开发团队开发，Pylearn2是一个机器学习库，它把深度学习和人工智能研究许多常用的模型以及训练算法封装成一个单一的实验包，如随机梯度下降。</p>
<p>你也可以很轻松的围绕你的类和算法编写一个封装程序，为了能让它在Pylearn2上运行，你需要在一个单独的YAML格式的配置文件中配置你整个神经网络模型的参数。</p>
<p>除此之外，它还有很多数据集及其预编译好的软件包，所以，你现在就可以直接使用MNIST数据集开始做实验了！</p>
<h3 id="Blocks">Blocks</h3><p>Github网址：<a href="https://github.com/mila-udem/blocks" target="_blank" rel="external">https://github.com/mila-udem/blocks</a></p>
<p>Blocks是一个非常模块化的框架，有助于你在Theano上建立神经网络。目前它支持并提供的功能有：</p>
<p>构建参数化Theano运算，称之为“bricks”。<br>在大型模型中使用模式匹配来选择变量以及“bricks”。<br>使用算法优化模型。<br>训练模型的保存和恢复。<br>在训练过程中检测和分析值（训练集以及测试集）。<br>图形变换的应用，如dropout。</p>
<h3 id="Keras">Keras</h3><p>主页：<a href="http://keras.io/" target="_blank" rel="external">http://keras.io/</a></p>
<p>Github网址：<a href="https://github.com/fchollet/keras" target="_blank" rel="external">https://github.com/fchollet/keras</a></p>
<p>Keras是一个简约的、高度模块化的神经网络库，设计参考了Torch，基于Theano和Python语言编写，支持GPU和CPU。它的开发侧重于实现快速试验和创造新的深度学习模型。</p>
<p>如果你需要具有以下功能的深度学习库，采用Keras就恰到好处：</p>
<p>可以很容易地、快速地建立原型（通过总体模块化，极简化并且可扩展化）。<br>支持卷积网络和递归网络，以及两者的组合。<br>支持任意连接方式（包括多输入多输出训练）。<br>Keras库与其他采用Theano库的区别是Keras的编码风格非常简约、清晰。它把所有的要点使用小类封装起来，能够很容易地组合在一起并创造出一种全新的模型。</p>
<h3 id="Lasagne">Lasagne</h3><p>Github网址：<a href="https://github.com/Lasagne/Lasagne" target="_blank" rel="external">https://github.com/Lasagne/Lasagne</a></p>
<p>Lasagne不只是一个美味的意大利菜，也是一个与Blocks和Keras有着相似功能的深度学习库，但其在设计上与它们有些不同。</p>
<p>下面是Lasagne的一些设计目的：</p>
<p>简单化：它应该是易于使用和扩展的机器学习库。每添加一个特征，就应该考虑其对易用性和扩展性的影响。每一个抽象概念的加入都应该仔细检查，以确定增加的复杂性是否合理。<br>小接口：尽可能少的类和方法。尽可能依赖Theano的功能和数据类型，遵循Theano的规定。如果没有严格的必要，不要在类中封装东西。这会使它更容易使用库并且扩展它（不需要有太多的认知）。<br>不碍事：未使用的功能应该是不可见的，用户不会考虑他们不使用的功能。尽可能单独的使用库文件中的组件。<br>透明性：不要试图掩盖Theano，尽量以Python或NumPy数据类型的形式将函数和方法返回给Theano表达式。<br>重点：遵循Unix哲学“做一件事，并把它做好”，重点集中在前馈神经网络。<br>实用主义：使普通用例更易于使用，这要比支持每一个可能的用例更为重要。</p>
<p>译者简介： <a href="https://csuldw.github.io">刘帝伟</a>，中南大学软件学院在读研究生，关注机器学习、数据挖掘及生物信息领域。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>英文链接：<a href="http://creative-punch.net/2015/07/frameworks-and-libraries-for-deep-learning/">http://creative-punch.net/2015/07/frameworks-and-libraries-for-deep-learning/</a></p>
<p>深度学习是机器学习和人工智能的一种形式，利用堆积在彼此顶部的神经网络的多个隐藏层来尝试形成对数据更深层次的“理解”。</p>
<p>最近，深度神经网络以“Deep Dreams”形式在网站中如雨后春笋般出现，或是像谷歌研究原创论文中描述的那样：Inceptionism。</p>
<p>在这篇文章中，我们将讨论几个不同的深度学习框架，库以及工具。</p>]]>
    
    </summary>
    
      <category term="Lasagne" scheme="http://csuldw.github.io/tags/Lasagne/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="Theano" scheme="http://csuldw.github.io/tags/Theano/"/>
    
      <category term="框架&amp;库" scheme="http://csuldw.github.io/tags/%E6%A1%86%E6%9E%B6-%E5%BA%93/"/>
    
      <category term="译文" scheme="http://csuldw.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习-Cross Validation交叉验证Python实现]]></title>
    <link href="http://csuldw.github.io/2015/07/28/2015-07-28%20crossvalidation/"/>
    <id>http://csuldw.github.io/2015/07/28/2015-07-28 crossvalidation/</id>
    <published>2015-07-28T07:40:00.000Z</published>
    <updated>2016-03-13T10:22:17.928Z</updated>
    <content type="html"><![CDATA[<h2 id="1-原理"><strong>1.原理</strong></h2><h3 id="1-1_概念"><strong>1.1 概念</strong></h3><p>交叉验证(Cross-validation)主要用于模型训练或建模应用中，如分类预测、PCR、PLS回归建模等。在给定的样本空间中，拿出大部分样本作为训练集来训练模型，剩余的小部分样本使用刚建立的模型进行预测，并求这小部分样本的预测误差或者预测精度，同时记录它们的加和平均值。这个过程迭代K次，即K折交叉。其中，把每个样本的预测误差平方加和，称为PRESS(predicted Error Sum of Squares)。<br><a id="more"></a></p>
<h3 id="1-2_目的"><strong>1.2 目的</strong></h3><p>用交叉验证的目的是为了得到可靠稳定的模型。在分类，建立PC 或PLS模型时，一个很重要的因素是取多少个主成分的问题。用cross validation校验每个主成分下的PRESS值，选择PRESS值小的主成分数。或PRESS值不再变小时的主成分数。</p>
<p>常用的精度测试方法主要是交叉验证，例如10折交叉验证(10-fold cross validation)，将数据集分成十份，轮流将其中9份做训练1份做验证，10次的结果的均值作为对算法精度的估计，一般还需要进行多次10折交叉验证求均值，例如：10次10折交叉验证，以求更精确一点。<br>交叉验证有时也称为交叉比对，如：10折交叉比对</p>
<h3 id="1-3_常见的交叉验证形式："><strong>1.3 常见的交叉验证形式</strong>：</h3><p><strong>Holdout 验证</strong></p>
<blockquote>
<p>方法：将原始数据随机分为两组,一组做为训练集,一组做为验证集,利用训练集训练分类器,然后利用验证集验证模型,记录最后的分类准确率为此Hold-OutMethod下分类器的性能指标.。Hold-OutMethod相对于K-fold Cross Validation 又称Double cross-validation ，或相对K-CV称 2-fold cross-validation(2-CV)</p>
<p>一般来说，Holdout 验证并非一种交叉验证，因为数据并没有交叉使用。 随机从最初的样本中选出部分，形成交叉验证数据，而剩余的就当做训练数据。 一般来说，少于原本样本三分之一的数据被选做验证数据。</p>
</blockquote>
<ul>
<li>优点：好处的处理简单,只需随机把原始数据分为两组即可</li>
<li>缺点：严格意义来说Hold-Out Method并不能算是CV,因为这种方法没有达到交叉的思想,由于是随机的将原始数据分组,所以最后验证集分类准确率的高低与原始数据的分组有很大的关系,所以这种方法得到的结果其实并不具有说服性.(主要原因是 训练集样本数太少，通常不足以代表母体样本的分布，导致 test 阶段辨识率容易出现明显落差。此外，2-CV 中一分为二的分子集方法的变异度大，往往无法达到「实验过程必须可以被复制」的要求。)</li>
</ul>
<p><strong>K-fold cross-validation</strong></p>
<blockquote>
<p>K折交叉验证，初始采样分割成K个子样本，一个单独的子样本被保留作为验证模型的数据，其他K-1个样本用来训练。交叉验证重复K次，每个子样本验证一次，平均K次的结果或者使用其它结合方式，最终得到一个单一估测。这个方法的优势在于，同时重复运用随机产生的子样本进行训练和验证，每次的结果验证一次，10折交叉验证是最常用的。</p>
</blockquote>
<ul>
<li>优点：K-CV可以有效的避免过学习以及欠学习状态的发生,最后得到的结果也比较具有说服性.  </li>
<li>缺点：K值选取上</li>
</ul>
<p><strong>留一验证</strong></p>
<blockquote>
<p>正如名称所建议， 留一验证（LOOCV）意指只使用原本样本中的一项来当做验证资料， 而剩余的则留下来当做训练资料。 这个步骤一直持续到每个样本都被当做一次验证资料。 事实上，这等同于 K-fold 交叉验证是一样的，其中K为原本样本个数。 在某些情况下是存在有效率的演算法，如使用kernel regression 和Tikhonov regularization。</p>
</blockquote>
<h2 id="2-深入"><strong>2.深入</strong></h2><p>使用交叉验证方法的目的主要有3个： </p>
<ul>
<li>（1）从有限的学习数据中获取尽可能多的有效信息； </li>
<li>（2）交叉验证从多个方向开始学习样本的，可以有效的避免陷入局部最小值； </li>
<li>（3）可以在一定程度上避免过拟合问题。</li>
</ul>
<p>采用交叉验证方法时需要将学习数据样本分为两部分：训练数据样本和验证数据样本。并且为了得到更好的学习效果，无论训练样本还是验证样本都要尽可能参与学习。一般选取10重交叉验证即可达到好的学习效果。下面在上述原则基础上设计算法，主要描述下算法步骤，如下所示。</p>
<h2 id="Algorithm">Algorithm  </h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Step1: 	将学习样本空间 C 分为大小相等的 K 份  </span><br><span class="line">Step2: 	<span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> to K ：</span><br><span class="line">			取第<span class="built_in">i</span>份作为测试集</span><br><span class="line">			<span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> to K:</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">i</span> != <span class="built_in">j</span>:</span><br><span class="line">					将第<span class="built_in">j</span>份加到训练集中，作为训练集的一部分</span><br><span class="line">				<span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">			<span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line">		<span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line">Step3: 	<span class="keyword">for</span> <span class="built_in">i</span> in (K-<span class="number">1</span>训练集)：</span><br><span class="line">			训练第<span class="built_in">i</span>个训练集，得到一个分类模型</span><br><span class="line">			使用该模型在第N个数据集上测试，计算并保存模型评估指标</span><br><span class="line">		<span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line">Step4: 	计算模型的平均性能</span><br><span class="line">Step5: 	用这K个模型在最终验证集的分类准确率平均值作为此K-CV下分类器的性能指标.</span><br></pre></td></tr></table></figure>
<h2 id="3-实现"><strong>3.实现</strong></h2><h3 id="3-1_scikit-learn交叉验证"><strong>3.1 scikit-learn交叉验证</strong></h3><p>在scikit-learn中有CrossValidation的实现代码，地址： <a href="http://scikit-learn.org/dev/modules/cross_validation.html#cross-validation" target="_blank" rel="external">scikit-learn官网crossvalidation文档</a></p>
<p>使用方法：</p>
<p>首先加载数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>iris = datasets.load_iris()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>iris.data.shape, iris.target.shape</span><br><span class="line">((<span class="number">150</span>, <span class="number">4</span>), (<span class="number">150</span>,))</span><br></pre></td></tr></table></figure>
<p>通过上面代码，数据集特征和类标签分别为iris.data, iris.target，接着进行交叉验证</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; X_train, X_test, y_train, y_test = cross_validation.train_test_split(</span><br><span class="line">...     iris<span class="class">.data</span>, iris<span class="class">.target</span>, test_size=<span class="number">0.4</span>, random_state=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; X_train<span class="class">.shape</span>, y_train<span class="class">.shape</span></span><br><span class="line">((<span class="number">90</span>, <span class="number">4</span>), (<span class="number">90</span>,))</span><br><span class="line">&gt;&gt;&gt; X_test<span class="class">.shape</span>, y_test<span class="class">.shape</span></span><br><span class="line">((<span class="number">60</span>, <span class="number">4</span>), (<span class="number">60</span>,))</span><br><span class="line">&gt;&gt;&gt; clf = svm.<span class="function"><span class="title">SVC</span><span class="params">(kernel=<span class="string">'linear'</span>, C=<span class="number">1</span>)</span></span>.<span class="function"><span class="title">fit</span><span class="params">(X_train, y_train)</span></span></span><br><span class="line">&gt;&gt;&gt; clf.<span class="function"><span class="title">score</span><span class="params">(X_test, y_test)</span></span>                           </span><br><span class="line"><span class="number">0.96</span>...</span><br></pre></td></tr></table></figure>
<p>上面的clf是分类器，可以自己替换，比如我可以使用RandomForest</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clf = <span class="function"><span class="title">RandomForestClassifier</span><span class="params">(n_estimators=<span class="number">400</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>一个比较有用的函数是train_test_split。功能是从样本中随机的按比例选取train data和test data。形式为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X<span class="keyword">_t</span>rain, X<span class="keyword">_t</span>est, <span class="keyword">y_t</span>rain, <span class="keyword">y_t</span>est = cross_validation.<span class="keyword">train_t</span>est_split(train_data,<span class="keyword">train_t</span>arget, test_size=<span class="number">0.4</span>, random_state=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>test_size是样本占比。如果是整数的话就是样本的数量。random_state是随机数的种子。</p>
<p>当然，也可以换成别的，具体算法可以参考 <a href="http://scikit-learn.org/dev/supervised_learning.html#supervised-learning" target="_blank" rel="external">scikit-learn官方文档</a></p>
<hr>
<h3 id="3-2_抽样与CV结合"><strong>3.2 抽样与CV结合</strong></h3><blockquote>
<p>由于我跑的实验，数据是非均衡数据，不能直接套用，所以这里自己写了一个交叉验证的代码，仅供参考，如有问题，欢迎交流。</p>
</blockquote>
<p>首先有一个自适应的数据加载函数，主要用于加载本地文本数据，同时文本每行数据以”\t”隔开，最后一列为类标号，数据样例如下：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span><span class="number">1001	708</span>	K	-4	-3	6	2	-13	0	2	-4	-4	-10	-9	1</span><br><span class="line"><span class="keyword">A</span><span class="number">1002	709</span>	L	-4	-4	-1	-2	-11	-1	0	-12	-7	-5	-1	-1</span><br><span class="line"><span class="keyword">A</span><span class="number">1003	710</span>	G	0	-6	-2	-6	-8	-4	-6	-6	-9	-4	0	-1</span><br><span class="line"><span class="keyword">A</span><span class="number">1004	711</span>	R	0	0	1	-3	-10	-1	-3	-4	-6	-9	-6	1</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：前面三个不是特征，所以在加载数据集的时候，特征部分起始位置修改了下，loadDataSet函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    fr = open(fileName)</span><br><span class="line">    dataMat = []; labelMat = []</span><br><span class="line">    <span class="keyword">for</span> eachline <span class="keyword">in</span> fr:</span><br><span class="line">        lineArr = []</span><br><span class="line">        curLine = eachline.strip().split(<span class="string">'\t'</span>) <span class="comment">#remove '\n'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, len(curLine)-<span class="number">1</span>):</span><br><span class="line">            lineArr.append(float(curLine[i])) <span class="comment">#get all feature from inpurfile</span></span><br><span class="line">        dataMat.append(lineArr)</span><br><span class="line">        labelMat.append(int(curLine[-<span class="number">1</span>])) <span class="comment">#last one is class lable</span></span><br><span class="line">    fr.close()</span><br><span class="line">    <span class="keyword">return</span> dataMat,labelMat</span><br></pre></td></tr></table></figure>
<p>返回的dataMat为纯特征矩阵，labelMat为类别标号。</p>
<p>下面的<strong>splitDataSet</strong>用来切分数据集，如果是十折交叉，则split_size取10，filename为整个数据集文件，outdir则是切分的数据集的存放路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(fileName, split_size,outdir)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(outdir): <span class="comment">#if not outdir,makrdir</span></span><br><span class="line">        os.makedirs(outdir)</span><br><span class="line">    fr = open(fileName,<span class="string">'r'</span>)<span class="comment">#open fileName to read</span></span><br><span class="line">    num_line = <span class="number">0</span></span><br><span class="line">    onefile = fr.readlines()</span><br><span class="line">    num_line = len(onefile)        </span><br><span class="line">    arr = np.arange(num_line) <span class="comment">#get a seq and set len=numLine</span></span><br><span class="line">    np.random.shuffle(arr) <span class="comment">#generate a random seq from arr</span></span><br><span class="line">    list_all = arr.tolist()</span><br><span class="line">    each_size = (num_line+<span class="number">1</span>) / split_size <span class="comment">#size of each split sets</span></span><br><span class="line">    split_all = []; each_split = []</span><br><span class="line">    count_num = <span class="number">0</span>; count_split = <span class="number">0</span>  <span class="comment">#count_num 统计每次遍历的当前个数</span></span><br><span class="line">                                    <span class="comment">#count_split 统计切分次数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list_all)): <span class="comment">#遍历整个数字序列</span></span><br><span class="line">        each_split.append(onefile[int(list_all[i])].strip()) </span><br><span class="line">        count_num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count_num == each_size:</span><br><span class="line">            count_split += <span class="number">1</span> </span><br><span class="line">            array_ = np.array(each_split)</span><br><span class="line">            np.savetxt(outdir + <span class="string">"/split_"</span> + str(count_split) + <span class="string">'.txt'</span>,\</span><br><span class="line">                        array_,fmt=<span class="string">"%s"</span>, delimiter=<span class="string">'\t'</span>)  <span class="comment">#输出每一份数据</span></span><br><span class="line">            split_all.append(each_split) <span class="comment">#将每一份数据加入到一个list中</span></span><br><span class="line">            each_split = []</span><br><span class="line">            count_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> split_all</span><br></pre></td></tr></table></figure>
<p>underSample(datafile)方法为抽样函数，强正负样本比例固定为1:1，返回的是一个正负样本比例均等的数据集合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">underSample</span><span class="params">(datafile)</span>:</span> <span class="comment">#只针对一个数据集的下采样</span></span><br><span class="line">    dataMat,labelMat = loadDataSet(datafile) <span class="comment">#加载数据</span></span><br><span class="line">    pos_num = <span class="number">0</span>; pos_indexs = []; neg_indexs = []   </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(labelMat)):<span class="comment">#统计正负样本的下标    </span></span><br><span class="line">        <span class="keyword">if</span> labelMat[i] == <span class="number">1</span>:</span><br><span class="line">            pos_num +=<span class="number">1</span></span><br><span class="line">            pos_indexs.append(i)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        neg_indexs.append(i)</span><br><span class="line">    np.random.shuffle(neg_indexs)</span><br><span class="line">    neg_indexs = neg_indexs[<span class="number">0</span>:pos_num]</span><br><span class="line">    fr = open(datafile, <span class="string">'r'</span>)</span><br><span class="line">    onefile = fr.readlines()</span><br><span class="line">    outfile = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(pos_num):</span><br><span class="line">        pos_line = onefile[pos_indexs[i]]    </span><br><span class="line">        outfile.append(pos_line)</span><br><span class="line">        neg_line= onefile[neg_indexs[i]]      </span><br><span class="line">        outfile.append(neg_line)</span><br><span class="line">    <span class="keyword">return</span> outfile <span class="comment">#输出单个数据集采样结果</span></span><br></pre></td></tr></table></figure>
<p>下面的generateDataset(datadir,outdir)方法是从切分的数据集中留出一份作为测试集（无需抽样），对其余的进行抽样然后合并为一个作为训练集，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateDataset</span><span class="params">(datadir,outdir)</span>:</span> <span class="comment">#从切分的数据集中，对其中九份抽样汇成一个,\</span></span><br><span class="line">    <span class="comment">#剩余一个做为测试集,将最后的结果按照训练集和测试集输出到outdir中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(outdir): <span class="comment">#if not outdir,makrdir</span></span><br><span class="line">        os.makedirs(outdir)</span><br><span class="line">    listfile = os.listdir(datadir)</span><br><span class="line">    train_all = []; test_all = [];cross_now = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> eachfile1 <span class="keyword">in</span> listfile:</span><br><span class="line">        train_sets = []; test_sets = []; </span><br><span class="line">        cross_now += <span class="number">1</span> <span class="comment">#记录当前的交叉次数</span></span><br><span class="line">        <span class="keyword">for</span> eachfile2 <span class="keyword">in</span> listfile:</span><br><span class="line">            <span class="keyword">if</span> eachfile2 != eachfile1:<span class="comment">#对其余九份欠抽样构成训练集</span></span><br><span class="line">                one_sample = underSample(datadir + <span class="string">'/'</span> + eachfile2)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(one_sample)):</span><br><span class="line">                    train_sets.append(one_sample[i])</span><br><span class="line">        <span class="comment">#将训练集和测试集文件单独保存起来</span></span><br><span class="line">        <span class="keyword">with</span> open(outdir +<span class="string">"/test_"</span>+str(cross_now)+<span class="string">".datasets"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> fw_test:</span><br><span class="line">            <span class="keyword">with</span> open(datadir + <span class="string">'/'</span> + eachfile1, <span class="string">'r'</span>) <span class="keyword">as</span> fr_testsets:</span><br><span class="line">                <span class="keyword">for</span> each_testline <span class="keyword">in</span> fr_testsets:                </span><br><span class="line">                    test_sets.append(each_testline) </span><br><span class="line">            <span class="keyword">for</span> oneline_test <span class="keyword">in</span> test_sets:</span><br><span class="line">                fw_test.write(oneline_test) <span class="comment">#输出测试集</span></span><br><span class="line">            test_all.append(test_sets)<span class="comment">#保存训练集</span></span><br><span class="line">        <span class="keyword">with</span> open(outdir+<span class="string">"/train_"</span>+str(cross_now)+<span class="string">".datasets"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> fw_train:</span><br><span class="line">            <span class="keyword">for</span> oneline_train <span class="keyword">in</span> train_sets:   </span><br><span class="line">                oneline_train = oneline_train</span><br><span class="line">                fw_train.write(oneline_train)<span class="comment">#输出训练集</span></span><br><span class="line">            train_all.append(train_sets)<span class="comment">#保存训练集</span></span><br><span class="line">    <span class="keyword">return</span> train_all,test_all</span><br></pre></td></tr></table></figure>
<p>因为需要评估交叉验证，所以我写了一个performance方法根据真实类标签纸和预测值来计算SN和SP，当然如果需要其他的评估标准，继续添加即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">performance</span><span class="params">(labelArr, predictArr)</span>:</span><span class="comment">#类标签为int类型</span></span><br><span class="line">    <span class="comment">#labelArr[i] is actual value,predictArr[i] is predict value</span></span><br><span class="line">    TP = <span class="number">0.</span>; TN = <span class="number">0.</span>; FP = <span class="number">0.</span>; FN = <span class="number">0.</span>   </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(labelArr)):</span><br><span class="line">        <span class="keyword">if</span> labelArr[i] == <span class="number">1</span> <span class="keyword">and</span> predictArr[i] == <span class="number">1</span>:</span><br><span class="line">            TP += <span class="number">1.</span></span><br><span class="line">        <span class="keyword">if</span> labelArr[i] == <span class="number">1</span> <span class="keyword">and</span> predictArr[i] == -<span class="number">1</span>:</span><br><span class="line">            FN += <span class="number">1.</span></span><br><span class="line">        <span class="keyword">if</span> labelArr[i] == -<span class="number">1</span> <span class="keyword">and</span> predictArr[i] == <span class="number">1</span>:</span><br><span class="line">            FP += <span class="number">1.</span></span><br><span class="line">        <span class="keyword">if</span> labelArr[i] == -<span class="number">1</span> <span class="keyword">and</span> predictArr[i] == -<span class="number">1</span>:</span><br><span class="line">            TN += <span class="number">1.</span></span><br><span class="line">    SN = TP/(TP + FN) <span class="comment">#Sensitivity = TP/P  and P = TP + FN </span></span><br><span class="line">    SP = TN/(FP + TN) <span class="comment">#Specificity = TN/N  and N = TN + FP</span></span><br><span class="line">    <span class="comment">#MCC = (TP*TN-FP*FN)/math.sqrt((TP+FP)*(TP+FN)*(TN+FP)*(TN+FN))</span></span><br><span class="line">    <span class="keyword">return</span> SN,SP</span><br></pre></td></tr></table></figure>
<p> classifier(clf,train_X, train_y, test_X, test_y)方法是交叉验证中每次用的分类器训练过程以及测试过程，里面使用的分类器是scikit-learn自带的。该方法会将一些训练结果写入到文件中并保存到本地，同时在最后会返回ACC,SP,SN。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def classifier(clf,train_X, train_y, <span class="built_in">test</span>_X, <span class="built_in">test</span>_y):<span class="comment">#X:训练特征，y:训练标号</span></span><br><span class="line">    <span class="comment"># train with randomForest </span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">" training begin..."</span></span><br><span class="line">    clf = clf.fit(train_X,train_y)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">" training end."</span></span><br><span class="line">    <span class="comment">#==========================================================================</span></span><br><span class="line">    <span class="comment"># test randomForestClassifier with testsets</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">" test begin."</span></span><br><span class="line">    predict_ = clf.predict(<span class="built_in">test</span>_X) <span class="comment">#return type is float64</span></span><br><span class="line">    proba = clf.predict_proba(<span class="built_in">test</span>_X) <span class="comment">#return type is float64</span></span><br><span class="line">    score_ = clf.score(<span class="built_in">test</span>_X,<span class="built_in">test</span>_y)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">" test end."</span></span><br><span class="line">    <span class="comment">#==========================================================================</span></span><br><span class="line">    <span class="comment"># Modeal Evaluation</span></span><br><span class="line">    ACC = accuracy_score(<span class="built_in">test</span>_y, predict_)</span><br><span class="line">    SN,SP = performance(<span class="built_in">test</span>_y, predict_)</span><br><span class="line">    MCC = matthews_corrcoef(<span class="built_in">test</span>_y, predict_)</span><br><span class="line">    <span class="comment">#AUC = roc_auc_score(test_labelMat, proba)</span></span><br><span class="line">    <span class="comment">#==========================================================================</span></span><br><span class="line">    <span class="comment">#save output </span></span><br><span class="line">    <span class="built_in">eval</span>_output = []</span><br><span class="line">    <span class="built_in">eval</span>_output.append(ACC);<span class="built_in">eval</span>_output.append(SN)  <span class="comment">#eval_output.append(AUC)</span></span><br><span class="line">    <span class="built_in">eval</span>_output.append(SP);<span class="built_in">eval</span>_output.append(MCC)</span><br><span class="line">    <span class="built_in">eval</span>_output.append(score_)</span><br><span class="line">    <span class="built_in">eval</span>_output = np.array(<span class="built_in">eval</span>_output,dtype=<span class="built_in">float</span>)</span><br><span class="line">    np.savetxt(<span class="string">"proba.data"</span>,proba,fmt=<span class="string">"%f"</span>,delimiter=<span class="string">"\t"</span>)</span><br><span class="line">    np.savetxt(<span class="string">"test_y.data"</span>,<span class="built_in">test</span>_y,fmt=<span class="string">"%f"</span>,delimiter=<span class="string">"\t"</span>)</span><br><span class="line">    np.savetxt(<span class="string">"predict.data"</span>,predict_,fmt=<span class="string">"%f"</span>,delimiter=<span class="string">"\t"</span>) </span><br><span class="line">    np.savetxt(<span class="string">"eval_output.data"</span>,<span class="built_in">eval</span>_output,fmt=<span class="string">"%f"</span>,delimiter=<span class="string">"\t"</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"Wrote results to output.data...EOF..."</span></span><br><span class="line">    <span class="built_in">return</span> ACC,SN,SP</span><br></pre></td></tr></table></figure>
<p>下面的mean_fun用于求列表list中数值的平均值，主要是求ACC_mean,SP_mean,SN_mean，用来评估模型好坏。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_fun</span><span class="params">(onelist)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> onelist:</span><br><span class="line">        count += i</span><br><span class="line">    <span class="keyword">return</span> float(count/len(onelist))</span><br></pre></td></tr></table></figure>
<p>交叉验证代码</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">def crossValidation<span class="params">(clf, clfname, curdir,train_all, test_all)</span>:</span><br><span class="line">    os.chdir<span class="params">(curdir)</span></span><br><span class="line">    <span class="built_in">#</span>构造出纯数据型样本集</span><br><span class="line">    cur_path = curdir</span><br><span class="line">    ACCs = [];SNs = []; SPs =[]</span><br><span class="line">    <span class="keyword">for</span> i in range<span class="params">(len<span class="params">(train_all)</span>)</span>:</span><br><span class="line">        os.chdir<span class="params">(cur_path)</span></span><br><span class="line">        train_data = train_all[i];train_X = [];train_y = []</span><br><span class="line">        test_data = test_all[i];test_X = [];test_y = []</span><br><span class="line">        <span class="keyword">for</span> eachline_train in train_data:</span><br><span class="line">            one_train = eachline_train.split<span class="params">('\t')</span> </span><br><span class="line">            one_train_format = []</span><br><span class="line">            <span class="keyword">for</span> index in range<span class="params">(<span class="number">3</span>,len<span class="params">(one_train)</span>-<span class="number">1</span>)</span>:</span><br><span class="line">                one_train_format.append<span class="params">(float<span class="params">(one_train[index])</span>)</span></span><br><span class="line">            train_X.append<span class="params">(one_train_format)</span></span><br><span class="line">            train_y.append<span class="params">(int<span class="params">(one_train[-<span class="number">1</span>].strip<span class="params">()</span>)</span>)</span></span><br><span class="line">        <span class="keyword">for</span> eachline_test in test_data:</span><br><span class="line">            one_test = eachline_test.split<span class="params">('\t')</span></span><br><span class="line">            one_test_format = []</span><br><span class="line">            <span class="keyword">for</span> index in range<span class="params">(<span class="number">3</span>,len<span class="params">(one_test)</span>-<span class="number">1</span>)</span>:</span><br><span class="line">                one_test_format.append<span class="params">(float<span class="params">(one_test[index])</span>)</span></span><br><span class="line">            test_X.append<span class="params">(one_test_format)</span></span><br><span class="line">            test_y.append<span class="params">(int<span class="params">(one_test[-<span class="number">1</span>].strip<span class="params">()</span>)</span>)</span></span><br><span class="line">        <span class="built_in">#</span>======================================================================</span><br><span class="line">        <span class="built_in">#</span>classifier start here</span><br><span class="line">        <span class="keyword">if</span> not os.path.exists<span class="params">(clfname)</span>:<span class="built_in">#</span>使用的分类器</span><br><span class="line">            os.mkdir<span class="params">(clfname)</span></span><br><span class="line">        out_path = clfname + <span class="string">"/"</span> + clfname + <span class="string">"_00"</span> + <span class="built_in">str</span><span class="params">(i)</span><span class="built_in">#</span>计算结果文件夹</span><br><span class="line">        <span class="keyword">if</span> not os.path.exists<span class="params">(out_path)</span>:</span><br><span class="line">            os.mkdir<span class="params">(out_path)</span></span><br><span class="line">        os.chdir<span class="params">(out_path)</span></span><br><span class="line">        ACC, SN, SP = classifier<span class="params">(clf, train_X, train_y, test_X, test_y)</span></span><br><span class="line">        ACCs.append<span class="params">(ACC)</span>;SNs.append<span class="params">(SN)</span>;SPs.append<span class="params">(SP)</span></span><br><span class="line">        <span class="built_in">#</span>======================================================================</span><br><span class="line">    ACC_mean = mean_fun<span class="params">(ACCs)</span></span><br><span class="line">    SN_mean = mean_fun<span class="params">(SNs)</span></span><br><span class="line">    SP_mean = mean_fun<span class="params">(SPs)</span></span><br><span class="line">    <span class="built_in">#</span>==========================================================================</span><br><span class="line">    <span class="built_in">#</span>output experiment result</span><br><span class="line">    os.chdir<span class="params">(<span class="string">"../"</span>)</span></span><br><span class="line">    os.system<span class="params">(<span class="string">"echo `date` '"</span> + str<span class="params">(clf)</span> + <span class="string">"' &gt;&gt; log.out"</span>)</span></span><br><span class="line">    os.system<span class="params">(<span class="string">"echo ACC_mean="</span> + str<span class="params">(ACC_mean)</span> + <span class="string">" &gt;&gt; log.out"</span>)</span></span><br><span class="line">    os.system<span class="params">(<span class="string">"echo SN_mean="</span> + str<span class="params">(SN_mean)</span> + <span class="string">" &gt;&gt; log.out"</span>)</span></span><br><span class="line">    os.system<span class="params">(<span class="string">"echo SP_mean="</span> + str<span class="params">(SP_mean)</span> + <span class="string">" &gt;&gt; log.out"</span>)</span></span><br><span class="line">    return ACC_mean, SN_mean, SP_mean</span><br></pre></td></tr></table></figure>
<p><strong>测试：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	os.chdir(<span class="string">"your workhome"</span>) <span class="comment">#你的数据存放目录</span></span><br><span class="line">    datadir = <span class="string">"split10_1"</span> <span class="comment">#切分后的文件输出目录</span></span><br><span class="line">    splitDataSet(<span class="string">'datasets'</span>,<span class="number">10</span>,datadir)<span class="comment">#将数据集datasets切为十个保存到datadir目录中</span></span><br><span class="line">	<span class="comment">#==========================================================================</span></span><br><span class="line">    outdir = <span class="string">"sample_data1"</span>	<span class="comment">#抽样的数据集存放目录</span></span><br><span class="line">    train_all,test_all = generateDataset(datadir,outdir) <span class="comment">#抽样后返回训练集和测试集</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"generateDataset end and cross validation start"</span></span><br><span class="line">    <span class="comment">#==========================================================================</span></span><br><span class="line">    <span class="comment">#分类器部分</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">    clf = RandomForestClassifier(n_estimators=<span class="number">500</span>) <span class="comment">#使用随机森林分类器来训练</span></span><br><span class="line">    clfname = <span class="string">"RF_1"</span></span><br><span class="line">    <span class="comment">#==========================================================================</span></span><br><span class="line">    curdir = <span class="string">"experimentdir"</span> <span class="comment">#工作目录</span></span><br><span class="line">	<span class="comment">#clf:分类器,clfname:分类器名称,curdir:当前路径,train_all:训练集,test_all:测试集</span></span><br><span class="line">    ACC_mean, SN_mean, SP_mean = crossValidation(clf, clfname, curdir, train_all,test_all)</span><br><span class="line">    <span class="keyword">print</span> ACC_mean,SN_mean,SP_mean	<span class="comment">#将ACC均值，SP均值，SN均值都输出到控制台</span></span><br></pre></td></tr></table></figure>
<p>上面的代码主要用于抽样后的十倍交叉验证，该怎么设置参数，还得具体分析。</p>
<p>总之，交叉验证在一定程度上能够避免陷入局部最小值。一般实际操作中使用的是十折交叉验证，单具体情况还得具体分析，并没有一个统一的标准固定十倍交叉的参数或者是算法的选择以及算法参数的选择。不同的数据使用不同的算法往往会的得到不同的最优分类器。So,just try it!Happy coding!</p>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-原理"><strong>1.原理</strong></h2><h3 id="1-1_概念"><strong>1.1 概念</strong></h3><p>交叉验证(Cross-validation)主要用于模型训练或建模应用中，如分类预测、PCR、PLS回归建模等。在给定的样本空间中，拿出大部分样本作为训练集来训练模型，剩余的小部分样本使用刚建立的模型进行预测，并求这小部分样本的预测误差或者预测精度，同时记录它们的加和平均值。这个过程迭代K次，即K折交叉。其中，把每个样本的预测误差平方加和，称为PRESS(predicted Error Sum of Squares)。<br>]]>
    
    </summary>
    
      <category term="Cross-Validation" scheme="http://csuldw.github.io/tags/Cross-Validation/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="交叉验证" scheme="http://csuldw.github.io/tags/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[scikit-klean交叉验证]]></title>
    <link href="http://csuldw.github.io/2015/07/23/2015-07-23%20machine%20learning%20tips/"/>
    <id>http://csuldw.github.io/2015/07/23/2015-07-23 machine learning tips/</id>
    <published>2015-07-23T04:53:00.000Z</published>
    <updated>2016-03-13T10:23:04.957Z</updated>
    <content type="html"><![CDATA[<p><strong>一个Windows操作系统能够使用的pythonIDE</strong></p>
<blockquote>
<p>winPython下载地址：<a href="http://sourceforge.net/projects/winpython/files/WinPython_2.7/2.7.10.1/" target="_blank" rel="external">WinPython_2.7</a></p>
</blockquote>
<p>传统的F-measure或平衡的F-score (F1 score)是精度和召回的调和平均值：</p>
<p>$$F_1 = 2 \times \dfrac{precision \times recall}{precision + recall}$$</p>
<a id="more"></a>
<h3 id="1-Cross_Validation_（交叉验证）"><strong>1.Cross Validation （交叉验证）</strong></h3><p>cross validation大概的意思是：对于原始数据我们要将其一部分分为train_data，一部分分为test_data。train_data用于训练，test_data用于测试准确率。在test_data上测试的结果叫做validation_error。将一个算法作用于一个原始数据，我们不可能只做出随机的划分一次train和test_data，然后得到一个validation_error，就作为衡量这个算法好坏的标准。因为这样存在偶然性。我们必须好多次的随机的划分train_data和test_data，分别在其上面算出各自的validation_error。这样就有一组validation_error，根据这一组validation_error，就可以较好的准确的衡量算法的好坏。</p>
<p>cross validation是在数据量有限的情况下的非常好的一个evaluate performance的方法。而对原始数据划分出train data和test data的方法有很多种，这也就造成了cross validation的方法有很多种。</p>
<p>sklearn中的cross validation模块，最主要的函数是如下函数：<br>sklearn.cross_validation.cross_val_score:他的调用形式是scores = cross_validation.cross_val_score(clf, raw_data, raw_target, cv=5, score_func=None)</p>
<p><strong>参数解释：</strong></p>
<p><strong>clf</strong>:表示的是不同的分类器，可以是任何的分类器。比如支持向量机分类器。clf = svm.SVC(kernel=’linear’, C=1)；<br><strong>raw_data</strong>：原始数据；<br><strong>raw_target</strong>:原始类别标号；<br><strong>cv</strong>：代表的就是不同的cross validation的方法了。引用scikit-learn上的一句话（When the cv argument is an integer, cross<em>val<em>score uses the KFold or StratifiedKFold strategies by default, the latter being used if the estimator derives from ClassifierMixin.）如果cv是一个int数字的话，那么默认使用的是KFold或者StratifiedKFold交叉，如果如果指定了类别标签则使用的是StratifiedKFold。<br>__cross_val_score</em></em>:这个函数的返回值就是对于每次不同的的划分raw_data时，在test_data上得到的分类的<strong>准确率</strong>。至于准确率的算法可以通过score_func参数指定，如果不指定的话，是用clf默认自带的准确率算法。  </p>
<p>scikit-learn的cross-validation交叉验证代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn import cross_validation</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn import svm</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = svm.<span class="constant">SVC</span>(kernel=<span class="string">'linear'</span>, <span class="constant">C</span>=<span class="number">1</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; scores = cross_validation.cross_val_score(clf, iris.data, iris.target, cv=<span class="number">5</span>)<span class="comment">#5-fold cv</span></span><br><span class="line"><span class="comment"># change metrics</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn import metrics</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; cross_validation.cross_val_score(clf, iris.data, iris.target, cv=<span class="number">5</span>, score_func=metrics.f1_score)</span><br><span class="line"><span class="comment">#f1 score: http://en.wikipedia.org/wiki/F1_score</span></span><br></pre></td></tr></table></figure>
<p>Note: if using LR, clf = LogisticRegression().</p>
<p><strong>生成一个数据集做为交叉验证</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.cross_validation</span> import train_test_split</span><br><span class="line">&gt;&gt;&gt; X, y = np.<span class="function"><span class="title">arange</span><span class="params">(<span class="number">10</span>)</span></span>.<span class="function"><span class="title">reshape</span><span class="params">((<span class="number">5</span>, <span class="number">2</span>)</span></span>), <span class="function"><span class="title">range</span><span class="params">(<span class="number">5</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; X</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">       [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">list</span><span class="params">(y)</span></span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><strong>将数据切分为训练集和测试集</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X_train</span>, <span class="constant">X_test</span>, y_train, y_test = train_test_split(</span><br><span class="line">...     <span class="constant">X</span>, y, test_size=<span class="number">0</span>.<span class="number">33</span>, random_state=<span class="number">42</span>)</span><br><span class="line">...</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X_train</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; y_train</span><br><span class="line">[<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X_test</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; y_test</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><strong>交叉验证的使用</strong></p>
<p>下面是手动划分训练集和测试集，控制台中输入下列代码进行测试：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; from sklearn import cross_validation</span><br><span class="line">&gt;&gt;&gt; from sklearn import datasets</span><br><span class="line">&gt;&gt;&gt; from sklearn import svm</span><br><span class="line">&gt;&gt;&gt; iris = datasets.<span class="function"><span class="title">load_iris</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; iris<span class="class">.data</span><span class="class">.shape</span>, iris<span class="class">.target</span><span class="class">.shape</span></span><br><span class="line">((<span class="number">150</span>, <span class="number">4</span>), (<span class="number">150</span>,))</span><br><span class="line">&gt;&gt;&gt; X_train, X_test, y_train, y_test = cross_validation.train_test_split(</span><br><span class="line">...     iris<span class="class">.data</span>, iris<span class="class">.target</span>, test_size=<span class="number">0.4</span>, random_state=<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; X_train<span class="class">.shape</span>, y_train<span class="class">.shape</span></span><br><span class="line">((<span class="number">90</span>, <span class="number">4</span>), (<span class="number">90</span>,))</span><br><span class="line">&gt;&gt;&gt; X_test<span class="class">.shape</span>, y_test<span class="class">.shape</span></span><br><span class="line">((<span class="number">60</span>, <span class="number">4</span>), (<span class="number">60</span>,))</span><br><span class="line">&gt;&gt;&gt; clf = svm.<span class="function"><span class="title">SVC</span><span class="params">(kernel=<span class="string">'linear'</span>, C=<span class="number">1</span>)</span></span>.<span class="function"><span class="title">fit</span><span class="params">(X_train, y_train)</span></span></span><br><span class="line">&gt;&gt;&gt; clf.<span class="function"><span class="title">score</span><span class="params">(X_test, y_test)</span></span>                           </span><br><span class="line"><span class="number">0.96</span>...</span><br></pre></td></tr></table></figure>
<p>下面是交叉验证的实例：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; clf = svm.<span class="function"><span class="title">SVC</span><span class="params">(kernel=<span class="string">'linear'</span>, C=<span class="number">1</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; scores = cross_validation.cross_val_score(</span><br><span class="line">...    clf, iris<span class="class">.data</span>, iris<span class="class">.target</span>, cv=<span class="number">5</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; scores                                              </span><br><span class="line"><span class="function"><span class="title">array</span><span class="params">([ <span class="number">0.96</span>...,  <span class="number">1</span>.  ...,  <span class="number">0.96</span>...,  <span class="number">0.96</span>...,  <span class="number">1</span>.        ])</span></span></span><br></pre></td></tr></table></figure>
<p>通过cross_validation，设置cv=5，进行5倍交叉验证，最后得到一个scores的预测准确率数组，表示每次交叉验证得到的准确率。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print<span class="params">(<span class="string">"Accuracy: %0.2f (+/- %0.2f)"</span> % <span class="params">(scores.mean<span class="params">()</span>, scores.std<span class="params">()</span> * <span class="number">2</span>)</span>)</span></span><br><span class="line">Accuracy: <span class="number">0.98</span> <span class="params">(+/- <span class="number">0.03</span>)</span></span><br></pre></td></tr></table></figure>
<p>通过scores.mean()求出平均值，得到平均精度。还可以通过指定scoring来设置准确率算法</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="subst">&gt;&gt;&gt;</span> from sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="subst">&gt;&gt;&gt;</span> scores <span class="subst">=</span> cross_validation<span class="built_in">.</span>cross_val_score(clf, iris<span class="built_in">.</span><span class="built_in">data</span>, iris<span class="built_in">.</span>target,</span><br><span class="line"><span class="attribute">...</span>     cv<span class="subst">=</span><span class="number">5</span>, scoring<span class="subst">=</span><span class="string">'f1_weighted'</span>)</span><br><span class="line"><span class="subst">&gt;&gt;&gt;</span> scores                                              </span><br><span class="line"><span class="built_in">array</span>(<span class="preprocessor">[</span> <span class="number">0.96</span><span class="attribute">...</span>,  <span class="number">1.</span>  <span class="attribute">...</span>,  <span class="number">0.96</span><span class="attribute">...</span>,  <span class="number">0.96</span><span class="attribute">...</span>,  <span class="number">1.</span>        <span class="preprocessor">]</span><span class="markup">)</span></span><br></pre></td></tr></table></figure>
<p><strong>libsvm格式的数据导入：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.datasets</span> import load_svmlight_file</span><br><span class="line">&gt;&gt;&gt; X_train, y_train = <span class="function"><span class="title">load_svmlight_file</span><span class="params">(<span class="string">"/path/to/train_dataset.txt"</span>)</span></span></span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;X_train.<span class="function"><span class="title">todense</span><span class="params">()</span></span>#将稀疏矩阵转化为完整特征矩阵</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-处理非均衡问题"><strong>2.处理非均衡问题</strong></h3><p>对于正负样本比例相差较大的非均衡问题，一种调节分类器的方法就是对分类器的训练数据进行改造。一种是<strong>欠抽样</strong>，一种是<strong>过抽样</strong>。过抽样意味着赋值样例，而欠抽样意味着删除样例。对于过抽样，最后可能导致过拟合问题；而对于欠抽样，则删掉的样本中可能包含某些重要的信息，会导致欠拟合。对于正例样本较少的情况下，通常采取的方式是<strong>使用反例类别的欠抽样和正例类别的过抽样相混合的方法</strong></p>
<hr>
<h3 id="3-scikit-learn学习SVM"><strong>3.scikit-learn学习SVM</strong></h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn import datasets</span><br><span class="line">&gt;&gt;&gt; iris = datasets.<span class="function"><span class="title">load_iris</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; digits = datasets.<span class="function"><span class="title">load_digits</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; print digits<span class="class">.data</span></span><br><span class="line">[[  <span class="number">0</span>.   <span class="number">0</span>.   <span class="number">5</span>. ...,   <span class="number">0</span>.   <span class="number">0</span>.   <span class="number">0</span>.]</span><br><span class="line"> [  <span class="number">0</span>.   <span class="number">0</span>.   <span class="number">0</span>. ...,  <span class="number">10</span>.   <span class="number">0</span>.   <span class="number">0</span>.]</span><br><span class="line"> [  <span class="number">0</span>.   <span class="number">0</span>.   <span class="number">0</span>. ...,  <span class="number">16</span>.   <span class="number">9</span>.   <span class="number">0</span>.]</span><br><span class="line"> ..., </span><br><span class="line"> [  <span class="number">0</span>.   <span class="number">0</span>.   <span class="number">1</span>. ...,   <span class="number">6</span>.   <span class="number">0</span>.   <span class="number">0</span>.]</span><br><span class="line"> [  <span class="number">0</span>.   <span class="number">0</span>.   <span class="number">2</span>. ...,  <span class="number">12</span>.   <span class="number">0</span>.   <span class="number">0</span>.]</span><br><span class="line"> [  <span class="number">0</span>.   <span class="number">0</span>.  <span class="number">10</span>. ...,  <span class="number">12</span>.   <span class="number">1</span>.   <span class="number">0</span>.]]</span><br><span class="line">&gt;&gt;&gt; digits<span class="class">.target</span></span><br><span class="line"><span class="function"><span class="title">array</span><span class="params">([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, ..., <span class="number">8</span>, <span class="number">9</span>, <span class="number">8</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; digits<span class="class">.images</span>[<span class="number">0</span>]</span><br><span class="line">array([[  <span class="number">0</span>.,   <span class="number">0</span>.,   <span class="number">5</span>.,  <span class="number">13</span>.,   <span class="number">9</span>.,   <span class="number">1</span>.,   <span class="number">0</span>.,   <span class="number">0</span>.],</span><br><span class="line">       [  <span class="number">0</span>.,   <span class="number">0</span>.,  <span class="number">13</span>.,  <span class="number">15</span>.,  <span class="number">10</span>.,  <span class="number">15</span>.,   <span class="number">5</span>.,   <span class="number">0</span>.],</span><br><span class="line">       [  <span class="number">0</span>.,   <span class="number">3</span>.,  <span class="number">15</span>.,   <span class="number">2</span>.,   <span class="number">0</span>.,  <span class="number">11</span>.,   <span class="number">8</span>.,   <span class="number">0</span>.],</span><br><span class="line">       [  <span class="number">0</span>.,   <span class="number">4</span>.,  <span class="number">12</span>.,   <span class="number">0</span>.,   <span class="number">0</span>.,   <span class="number">8</span>.,   <span class="number">8</span>.,   <span class="number">0</span>.],</span><br><span class="line">       [  <span class="number">0</span>.,   <span class="number">5</span>.,   <span class="number">8</span>.,   <span class="number">0</span>.,   <span class="number">0</span>.,   <span class="number">9</span>.,   <span class="number">8</span>.,   <span class="number">0</span>.],</span><br><span class="line">       [  <span class="number">0</span>.,   <span class="number">4</span>.,  <span class="number">11</span>.,   <span class="number">0</span>.,   <span class="number">1</span>.,  <span class="number">12</span>.,   <span class="number">7</span>.,   <span class="number">0</span>.],</span><br><span class="line">       [  <span class="number">0</span>.,   <span class="number">2</span>.,  <span class="number">14</span>.,   <span class="number">5</span>.,  <span class="number">10</span>.,  <span class="number">12</span>.,   <span class="number">0</span>.,   <span class="number">0</span>.],</span><br><span class="line">       [  <span class="number">0</span>.,   <span class="number">0</span>.,   <span class="number">6</span>.,  <span class="number">13</span>.,  <span class="number">10</span>.,   <span class="number">0</span>.,   <span class="number">0</span>.,   <span class="number">0</span>.]])</span><br><span class="line">&gt;&gt;&gt; from sklearn import svm</span><br><span class="line">&gt;&gt;&gt; clf = svm.<span class="function"><span class="title">SVC</span><span class="params">(gamma=<span class="number">0.001</span>, C=<span class="number">100</span>.)</span></span></span><br><span class="line">&gt;&gt;&gt; clf.<span class="function"><span class="title">fit</span><span class="params">(digits.data[:-<span class="number">1</span>],digits.target[:-<span class="number">1</span>])</span></span></span><br><span class="line">SVC(C=<span class="number">100.0</span>, cache_size=<span class="number">200</span>, class_weight=None, coef0=<span class="number">0.0</span>, degree=<span class="number">3</span>,</span><br><span class="line">  gamma=<span class="number">0.001</span>, kernel=<span class="string">'rbf'</span>, max_iter=-<span class="number">1</span>, probability=False,</span><br><span class="line">  random_state=None, shrinking=True, tol=<span class="number">0.001</span>, verbose=False)</span><br><span class="line">&gt;&gt;&gt; clf.<span class="function"><span class="title">predict</span><span class="params">(digits.data[-<span class="number">1</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">array</span><span class="params">([<span class="number">8</span>])</span></span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-scikit-learn学习RandomForest"><strong>4.scikit-learn学习RandomForest</strong></h3><p>使用例子</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn.ensemble import <span class="constant">RandomForestClassifier</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X</span> = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">Y</span> = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = <span class="constant">RandomForestClassifier</span>(n_estimators=<span class="number">10</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = clf.fit(<span class="constant">X</span>, <span class="constant">Y</span>)</span><br></pre></td></tr></table></figure>
<p><strong>Method</strong></p>
<p><img src="/assets/articleImg/2015-07-21 randomForest分类器的方法png.png" alt=""></p>
<p>randomForestClassifier分类器的初始值</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,</span><br><span class="line">	 <span class="variable">n_estimators=</span><span class="number">10</span>,</span><br><span class="line">	 <span class="variable">criterion=</span><span class="string">"gini"</span>,</span><br><span class="line">	 <span class="variable">max_depth=</span>None,</span><br><span class="line">	 <span class="variable">min_samples_split=</span><span class="number">2</span>,</span><br><span class="line">	 <span class="variable">min_samples_leaf=</span><span class="number">1</span>,</span><br><span class="line">	 <span class="variable">min_weight_fraction_leaf=</span><span class="number">0</span>.,</span><br><span class="line">	 <span class="variable">max_features=</span><span class="string">"auto"</span>,</span><br><span class="line">	 <span class="variable">max_leaf_nodes=</span>None,</span><br><span class="line">	 <span class="variable">bootstrap=</span>True,</span><br><span class="line">	 <span class="variable">oob_score=</span>False,</span><br><span class="line">	 <span class="variable">n_jobs=</span><span class="number">1</span>,</span><br><span class="line">	 <span class="variable">random_state=</span>None,</span><br><span class="line">	 <span class="variable">verbose=</span><span class="number">0</span>,</span><br><span class="line">	 <span class="variable">warm_start=</span>False,</span><br><span class="line">	 <span class="variable">class_weight=</span>None):</span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>一个Windows操作系统能够使用的pythonIDE</strong></p>
<blockquote>
<p>winPython下载地址：<a href="http://sourceforge.net/projects/winpython/files/WinPython_2.7/2.7.10.1/">WinPython_2.7</a></p>
</blockquote>
<p>传统的F-measure或平衡的F-score (F1 score)是精度和召回的调和平均值：</p>
<p>$$F_1 = 2 \times \dfrac{precision \times recall}{precision + recall}$$</p>]]>
    
    </summary>
    
      <category term="Cross-Validation" scheme="http://csuldw.github.io/tags/Cross-Validation/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="交叉验证" scheme="http://csuldw.github.io/tags/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习-组合算法总结]]></title>
    <link href="http://csuldw.github.io/2015/07/22/2015-07-22%20%20ensemble/"/>
    <id>http://csuldw.github.io/2015/07/22/2015-07-22  ensemble/</id>
    <published>2015-07-21T22:53:00.000Z</published>
    <updated>2016-03-13T05:58:30.693Z</updated>
    <content type="html"><![CDATA[<h2 id="组合模型"><strong>组合模型</strong></h2><p>下面简单的介绍下Bootstraping, Bagging, Boosting, AdaBoost, RandomForest 和Gradient boosting这些组合型算法.</p>
<h3 id="1-Bootstraping"><strong>1.Bootstraping</strong></h3><p><strong>Bootstraping</strong>: 名字来自成语“pull up by your own bootstraps”，意思就是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统计中一种重要的估计统计量方差进而进行区间估计的统计方法。其核心思想和基本步骤如下：<br> <a id="more"></a></p>
<blockquote>
<p>（1）采用重抽样技术从原始样本中抽取一定数量（自己给定）的样本，此过程允许重复抽样。<br>（2）根据抽出的样本计算给定的统计量T。<br>（3）重复上述N次（一般大于1000），得到N个统计量T。<br>（4）计算上述N个统计量T的样本方差，得到统计量的方差。 </p>
</blockquote>
<p>应该说Bootstrap是现代统计学较为流行的一种统计方法，在小样本时效果很好。通过方差的估计可以构造置信区间等，其运用范围得到进一步延伸。</p>
<hr>
<h3 id="2-装袋bagging"><strong>2.装袋bagging</strong></h3><p>装袋算法相当于多个专家投票表决，对于多次测试，每个样本返回的是多次预测结果较多的那个。</p>
<p>装袋算法描述</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">模型生成</span><br><span class="line">	令<span class="keyword">n</span>为训练数据的实例数量</span><br><span class="line">	对于t次循环中的每一次</span><br><span class="line">		从训练数据中采样<span class="keyword">n</span>个实例</span><br><span class="line">		将学习应用于所采样本</span><br><span class="line">		保存结果模型</span><br><span class="line">分类</span><br><span class="line">	对于t个模型的每一个</span><br><span class="line">		使用模型对实例进行预测</span><br><span class="line">	返回被预测次数最多的一个</span><br></pre></td></tr></table></figure>
<p>bagging：bootstrap aggregating的缩写。让该学习算法训练多轮，每轮的训练集由从初始的训练集中随机取出的n个训练样本组成，某个初始训练样本在某轮训练集中可以出现多次或根本不出现，训练之后可得到一个预测函数序列</p>
<p>$$h_1，⋯ ⋯h_n$$ </p>
<p>最终的预测函数H对分类问题采用<strong>投票方式</strong>，对回归问题采用<strong>简单平均方法</strong>对新示例进行判别。</p>
<p>[训练R个分类器f_i，分类器之间其他相同就是参数不同。其中f_i是通过从训练集合中(N篇文档)随机取(取后放回)N次文档构成的训练集合训练得到的。对于新文档d，用这R个分类器去分类，得到的最多的那个类别作为d的最终类别。]</p>
<p>使用scikit-learn测试bagging方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bagging = BaggingClassifier(KNeighborsClassifier(),</span><br><span class="line"><span class="prompt">... </span>                            max_samples=<span class="number">0.5</span>, max_features=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-提升Boosting与Adaboost"><strong>3.提升Boosting与Adaboost</strong></h3><p><strong>提升算法描述</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">模型生成</span><br><span class="line">	赋予每个训练实例相同的权值</span><br><span class="line">	t次循环中的每一次：</span><br><span class="line">		将学习算法应用于加了权的数据集上并保存结果模型</span><br><span class="line">		计算模型在加了权的数据上的误差<span class="keyword">e</span>并保存这个误差</span><br><span class="line">		结果<span class="keyword">e</span>等于0或者大于等于0.5：</span><br><span class="line">			终止模型</span><br><span class="line">		对于数据集中的每个实例：</span><br><span class="line">			如果模型将实例正确分类</span><br><span class="line">				将实例的权值乘以<span class="keyword">e</span>/(1-<span class="keyword">e</span>)</span><br><span class="line">		将所有的实例权重进行正常化</span><br><span class="line">分类</span><br><span class="line">	赋予所有类权重为0</span><br><span class="line">	对于t（或小于t）个模型中的每一个：</span><br><span class="line">		给模型预测的类加权 -<span class="literal">log</span>(<span class="keyword">e</span>/(1-<span class="keyword">e</span>))</span><br><span class="line">	返回权重最高的类</span><br></pre></td></tr></table></figure>
<p>这个模型提供了一种巧妙的方法生成一系列互补型的专家。</p>
<p><strong>boosting</strong>: 其中主要的是<strong>AdaBoost</strong>（Adaptive boosting，自适应boosting）。初始化时对每一个训练例赋相等的权重1／N，然后用该学算法对训练集训练t轮，每次训练后，对训练失败的训练例赋以较大的权重，也就是让学习算法在后续的学习中集中对比较难的训练例进行学习，从而得到一个预测函数序列$h_1,⋯, h_m$ , 其中h_i也有一定的权重，预测效果好的预测函数权重较大，反之较小。最终的预测函数H对分类问题采用有权重的投票方式，对回归问题采用加权平均的方法对新示例进行判别。</p>
<p>提升算法理想状态是这些模型对于其他模型来说是一个补充，每个模型是这个领域的一个专家，而其他模型在这部分却不能表现很好，就像执行官一样要寻觅那些技能和经验互补的顾问，而不是重复的。这与装袋算法有所区分。</p>
<p>Adaboost算法描述</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">模型生成</span><br><span class="line">	训练数据中的每个样本，并赋予一个权重，构成权重向量<span class="keyword">D</span>，初始值为1/<span class="keyword">N</span></span><br><span class="line">	t次循环中的每一次：</span><br><span class="line">		在训练数据上训练弱分类器并计算分类器的错误率<span class="literal">e</span></span><br><span class="line">		如果<span class="keyword">e</span>等于0或者大于等于用户指定的阈值：</span><br><span class="line">			终止模型，<span class="keyword">break</span></span><br><span class="line">		重新调整每个样本的权重，其中<span class="keyword">alpha</span>=0.5*<span class="literal">ln</span>((1-<span class="keyword">e</span>)/<span class="keyword">e</span>)</span><br><span class="line">		对权重向量<span class="keyword">D</span>进行更新，正确分类的样本的权重降低而错误分类的样本权重值升高</span><br><span class="line">		对于数据集中的每个样例：</span><br><span class="line">			如果某个样本正确分类：</span><br><span class="line">				权重改为<span class="keyword">D</span>^(t+1)_i = <span class="keyword">D</span>^(t)_i * <span class="keyword">e</span>^(-a)/<span class="literal">Sum</span>(<span class="keyword">D</span>)</span><br><span class="line">			如果某个样本错误分类：</span><br><span class="line">				权重改为<span class="keyword">D</span>^(t+1)_i = <span class="keyword">D</span>^(t)_i * <span class="keyword">e</span>^(a)/<span class="literal">Sum</span>(<span class="keyword">D</span>)</span><br><span class="line">分类</span><br><span class="line">	赋予所有类权重为0</span><br><span class="line">	对于t（或小于t）个模型（基分类器）中的每一个：</span><br><span class="line">		给模型预测的类加权 -<span class="literal">log</span>(<span class="keyword">e</span>/(1-<span class="keyword">e</span>))</span><br><span class="line">	返回权重最高的类</span><br></pre></td></tr></table></figure>
<p>（类似Bagging方法，但是训练是串行进行的，第k个分类器训练时关注对前k-1分类器中错分的文档，即不是随机取，而是加大取这些文档的概率。)</p>
<p><strong>bagging与boosting的区别</strong>：</p>
<p>二者的主要区别是<strong>取样方式不同</strong>。bagging采用<strong>均匀取样</strong>，而Boosting根据<strong>错误率来取样</strong>，因此boosting的分类精度要优于Bagging。bagging的训练集的选择是随机的，各轮训练集之间相互独立，而boostlng的各轮训练集的选择与前面各轮的学习结果有关；bagging的各个预测函数没有权重，而boosting是有权重的；bagging的各个预测函数可以并行生成，而boosting的各个预测函数只能顺序生成。对于象神经网络这样极为耗时的学习方法。bagging可通过并行训练节省大量时间开销。</p>
<p>bagging和boosting都可以有效地提高分类的准确性。在大多数数据集中，boosting的准确性比bagging高。在有些数据集中，boosting会引起退化—- Overfit。  </p>
<p>Boosting思想的一种改进型AdaBoost方法在邮件过滤、文本分类方面都有很好的性能。 </p>
<p><strong>Gradient boosting（又叫Mart, Treenet)</strong>：Boosting是一种思想，Gradient Boosting是一种实现Boosting的方法，它主要的思想是，每一次建立模型是在之前建立模型<strong>损失函数的梯度下降方向</strong>。<strong>损失函数(loss function)描述的是模型的不靠谱程度，损失函数越大，则说明模型越容易出错。</strong>如果我们的模型能够让损失函数持续的下降，则说明我们的模型在不停的改进，而最好的方式就是<strong>让损失函数在其梯度（Gradient)的方向上下降</strong>。  </p>
<p>使用scikit-learn测试adaboost算法</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.cross_validation</span> import cross_val_score</span><br><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.datasets</span> import load_iris</span><br><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.ensemble</span> import AdaBoostClassifier</span><br><span class="line">&gt;&gt;&gt; iris = <span class="function"><span class="title">load_iris</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; clf = <span class="function"><span class="title">AdaBoostClassifier</span><span class="params">(n_estimators=<span class="number">100</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; scores = <span class="function"><span class="title">cross_val_score</span><span class="params">(clf, iris.data, iris.target)</span></span></span><br><span class="line">&gt;&gt;&gt; scores.<span class="function"><span class="title">mean</span><span class="params">()</span></span>                             </span><br><span class="line"><span class="number">0.9</span>...</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-Random_Forest"><strong>4.Random Forest</strong></h3><p><strong>Random Forest</strong>： 随机森林，顾名思义，是用随机的方式建立一个森林，森林里面有很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。在得到森林之后，当有一个新的输入样本进入的时候，就让森林中的每一棵决策树分别进行一下判断，看看这个样本应该属于哪一类（对于分类算法），然后看看哪一类被选择最多，就预测这个样本为那一类。 在建立每一棵决策树的过程中，有两点需要注意——<strong>采样</strong>与<strong>完全分裂</strong>。首先是两个随机采样的过程，random forest对输入的数据要进行行和列的采样。对于行采样，采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为N个，那么采样的样本也为N个。这样使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现over-fitting。然后进行列采样，从M个feature中，选择m个(m &lt;&lt; M)。之后就是对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面的所有样本的都是指向的同一个分类。<strong>一般很多的决策树算法都一个重要的步骤——剪枝，但随机森林不这样做，由于之前的两个随机采样的过程保证了随机性，所以就算不剪枝，也不会出现over-fitting。</strong> 按这种算法得到的随机森林中的每一棵都是很弱的，但是大家组合起来就很厉害了。可以这样比喻随机森林算法：每一棵决策树就是一个精通于某一个窄领域的专家（因为我们从M个feature中选择m让每一棵决策树进行学习），这样在随机森林中就有了很多个精通不同领域的专家，对一个新的问题（新的输入数据），可以用不同的角度去看待它，最终由各个专家，投票得到结果。  </p>
<p><strong>Random forest与bagging的区别</strong>：</p>
<p>(1)Random forest是选与输入样本的数目相同多的次数（可能一个样本会被选取多次，同时也会造成一些样本不会被选取到），而bagging一般选取比输入样本的数目少的样本；<br>(2)bagging是用全部特征来得到分类器，而Random forest是需要从全部特征中选取其中的一部分来训练得到分类器； <strong>一般Random forest效果比bagging效果好！</strong></p>
<p>使用scikit-learn测试随机森林算法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn.ensemble import <span class="constant">RandomForestClassifier</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X</span> = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">Y</span> = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = <span class="constant">RandomForestClassifier</span>(n_estimators=<span class="number">10</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = clf.fit(<span class="constant">X</span>, <span class="constant">Y</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-Gradient_boosting"><strong>5.Gradient boosting</strong></h3><p>梯度提升树或者梯度提升回归树(GBRT)是任意一个不同损失函数的泛化。GBRT是一个灵敏的并且高效程序，可以用在回归和分类中。梯度提升树模型在许多领域中都有使用，如web搜索排行榜和社会生态学中。它主要的思想是，每一次建立模型是在之前建立模型损失函数的梯度下降方向。这句话有一点拗口，损失函数(loss function)描述的是模型的不靠谱程度，损失函数越大，则说明模型越容易出错（其实这里有一个方差、偏差均衡的问题，但是这里就假设损失函数越大，模型越容易出错）。如果我们的模型能够让损失函数持续的下降，则说明我们的模型在不停的改进，而最好的方式就是让损失函数在其梯度（Gradient)的方向上下降。</p>
<p>GRBT的优势：</p>
<ul>
<li>混合数据类型的自然处理</li>
<li>预测力强</li>
<li>健壮的输出空间</li>
</ul>
<p>Boosting主要是一种思想，表示“知错就改”。而Gradient Boosting是在这个思想下的一种函数（也可以说是模型）的优化的方法，首先将函数分解为可加的形式（其实所有的函数都是可加的，只是是否好放在这个框架中，以及最终的效果如何）。然后进行m次迭代，通过使得损失函数在梯度方向上减少，最终得到一个优秀的模型。值得一提的是，每次模型在梯度方向上的减少的部分，可以认为是一个“小”的或者“弱”的模型，最终我们会通过加权(也就是每次在梯度方向上下降的距离）的方式将这些“弱”的模型合并起来，形成一个更好的模型。</p>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="组合模型"><strong>组合模型</strong></h2><p>下面简单的介绍下Bootstraping, Bagging, Boosting, AdaBoost, RandomForest 和Gradient boosting这些组合型算法.</p>
<h3 id="1-Bootstraping"><strong>1.Bootstraping</strong></h3><p><strong>Bootstraping</strong>: 名字来自成语“pull up by your own bootstraps”，意思就是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统计中一种重要的估计统计量方差进而进行区间估计的统计方法。其核心思想和基本步骤如下：<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="ensemble" scheme="http://csuldw.github.io/tags/ensemble/"/>
    
      <category term="组合算法" scheme="http://csuldw.github.io/tags/%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习scikit-learn入门教程（译）]]></title>
    <link href="http://csuldw.github.io/2015/07/21/2015-07-21-An-introduction-to-machine-learning-with-scikit-learn/"/>
    <id>http://csuldw.github.io/2015/07/21/2015-07-21-An-introduction-to-machine-learning-with-scikit-learn/</id>
    <published>2015-07-21T13:31:00.000Z</published>
    <updated>2016-03-08T08:57:49.910Z</updated>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://scikit-learn.github.io/dev/tutorial/basic/tutorial.html" target="_blank" rel="external">http://scikit-learn.github.io/dev/tutorial/basic/tutorial.html</a></p>
<p><strong>章节内容</strong></p>
<p>在这个章节中，我们主要介绍关于scikit-learn机器学习词库，并且将给出一个学习样例。</p>
<h2 id="机器学习：问题设置"><strong>机器学习：问题设置</strong></h2><p>通常，一个学习问题是通过一系列的n个样本数据来学习然后尝试预测未知数据的属性。如果每一个样本超过一个单一的数值，例如多维输入（也叫做多维数据），那么它就拥有了多个特征。<br><a id="more"></a><br>我们可以把学习问题划分为几个大的来别：</p>
<ul>
<li>监督学习: 在监督学习中，这些数据自带了我们想要预测的附加属性（<a href="http://scikit-learn.github.io/dev/supervised_learning.html#supervised-learning" target="_blank" rel="external">scikit-learn监督学习链接</a>），这个问题包括：<ul>
<li>分类：样本属于属于两类或者多类，我们想从已经被标记的数据中来预测未知数据的类别。一个分类问题的例子就是手写字识别。这个例子的目的是从有些的类别中识别出输入向量的类别。对于分类的另一种想法是作为监督学习的一种分离的表格(不是连续的)，在这个表格中，一个是被限制的类别数量，而且对于每个类别都有N个样例被提供；一个是尝试用正确的类别或者类来标记他们。</li>
<li>回归：如果期望的输出是由一个或者更多的连续的变量组成，那么就叫做回归。回归问题的例子将通过一条鲑鱼的年龄和重量预测它的长度。</li>
</ul>
</li>
<li>无监督学习：在无监督学习里面，训练数据是由一组没有任何类别标签值的一系列输入向量组成。这种问题的目的是可能可以在这些数据里发现相似的样例组，这些相似的样例被称作聚类。或者在输入空间里决定数据分布，称之为密度估算；或者将数据从高维空间映射到二维或三维空间中，称之为数据可视化问题。（<a href="http://scikit-learn.github.io/dev/unsupervised_learning.html#unsupervised-learning" target="_blank" rel="external">无监督学习链接</a>）</li>
</ul>
<p><strong>训练集和测试集</strong></p>
<p>机器学习是关于学习数据集的一些属性然后将它们应用到新的数据上。这就是为什么在机器学习中评价一个算法的通常惯例是把数据集切分为两个数据集，其中一个叫做训练集，用来学习数据的属性；另一个叫做测试集，在测试集上测试那些属性。</p>
<h2 id="加载样本数据集"><strong>加载样本数据集</strong></h2><p>scikit-learn带有一些标准的数据集，例如用于分类的<a href="http://en.wikipedia.org/wiki/Iris_flower_data_set" target="_blank" rel="external">iris</a>和<a href="http://archive.ics.uci.edu/ml/datasets/Pen-Based+Recognition+of+Handwritten+Digits" target="_blank" rel="external">digit</a>数据集和用于回归的<a href="http://archive.ics.uci.edu/ml/datasets/Housing" target="_blank" rel="external"> boston house prices dataset </a>.</p>
<p>下面，我们打开Python编译器，然后载入<strong>iris</strong>和digits数据集。我们的符号’$’表示shell提示，’&gt;&gt;&gt;’表示Python编译器提示</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn import datasets</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; iris = datasets.load_iris()</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; digits = datasets.load_digits()</span><br></pre></td></tr></table></figure>
<p> 数据集是一个类似字典的对象，包含所有的数据和一些和数据有关的元数据。数据存储在.data中，是个n_samples,n_features的数组。在监督问题的情况下，一个或多个类别变量存储在.target成员中。更多有关的不同数据集的细节可以在<a href="http://scikit-learn.github.io/dev/datasets/index.html#datasets" target="_blank" rel="external">dedicated section</a>查找。</p>
<p> 例如，在digits数据集情况下，digits.data 提供了可用于分类数字样本。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">print</span>(<span class="tag">digits</span><span class="class">.data</span>)  </span><br><span class="line"><span class="attr_selector">[[  0.   0.   5. ...,   0.   0.   0.]</span></span><br><span class="line"> <span class="attr_selector">[  0.   0.   0. ...,  10.   0.   0.]</span></span><br><span class="line"> <span class="attr_selector">[  0.   0.   0. ...,  16.   9.   0.]</span></span><br><span class="line"> ...,</span><br><span class="line"> <span class="attr_selector">[  0.   0.   1. ...,   6.   0.   0.]</span></span><br><span class="line"> <span class="attr_selector">[  0.   0.   2. ...,  12.   0.   0.]</span></span><br><span class="line"> <span class="attr_selector">[  0.   0.  10. ...,  12.   1.   0.]</span>]</span><br></pre></td></tr></table></figure>
<p>并且digits.target给出了digit数据集的真实结果，这些数字是和我们正在学习的每个数字图像相关的数字。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; digits<span class="class">.target</span></span><br><span class="line"><span class="function"><span class="title">array</span><span class="params">([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, ..., <span class="number">8</span>, <span class="number">9</span>, <span class="number">8</span>])</span></span></span><br></pre></td></tr></table></figure>
<p><strong>数组的形状</strong></p>
<p>数据总是一些2D数组，shape(n_samples,n_features),尽管原始数据也许有一个不同的形状，就这个digits而言，每一个原始样例是一个shape(8,8)的图像，并且能被访问使用:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">digits</span><span class="class">.images</span><span class="attr_selector">[0]</span></span><br><span class="line"><span class="tag">array</span>(<span class="attr_selector">[[  0.,   0.,   5.,  13.,   9.,   1.,   0.,   0.]</span>,</span><br><span class="line">       <span class="attr_selector">[  0.,   0.,  13.,  15.,  10.,  15.,   5.,   0.]</span>,</span><br><span class="line">       <span class="attr_selector">[  0.,   3.,  15.,   2.,   0.,  11.,   8.,   0.]</span>,</span><br><span class="line">       <span class="attr_selector">[  0.,   4.,  12.,   0.,   0.,   8.,   8.,   0.]</span>,</span><br><span class="line">       <span class="attr_selector">[  0.,   5.,   8.,   0.,   0.,   9.,   8.,   0.]</span>,</span><br><span class="line">       <span class="attr_selector">[  0.,   4.,  11.,   0.,   1.,  12.,   7.,   0.]</span>,</span><br><span class="line">       <span class="attr_selector">[  0.,   2.,  14.,   5.,  10.,  12.,   0.,   0.]</span>,</span><br><span class="line">       <span class="attr_selector">[  0.,   0.,   6.,  13.,  10.,   0.,   0.,   0.]</span>])</span><br></pre></td></tr></table></figure>
<p><a href="http://scikit-learn.github.io/dev/auto_examples/classification/plot_digits_classification.html#example-classification-plot-digits-classification-py" target="_blank" rel="external">simple example on this dataset </a>这个数据集表明了在scikit-learn中怎样从原始问题开始着手制作数据。</p>
<h2 id="学习和预测"><strong>学习和预测</strong></h2><p>在digits数据集中，给定一幅手写数字的数字图像，任务是预测结果。我们给定的样本有10种类别（是数字0到9），基于此我们建立一个估计方法能够预测我们没有见过的样本属于哪一类。</p>
<p>在scikit-learn中，用于分类的估计模型是一个实现了fit(x,y)方法和predict(T)方法的Python对象。</p>
<p>估计模型的例子是在实现了<a href="http://en.wikipedia.org/wiki/Support_vector_machine" target="_blank" rel="external">support vector classification支持向量机</a>的类 sklearn.svm.SVC。估计模型的构造函数带有模型参数，但是目前，我们将估计模型当做一个黑盒子。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn import svm  </span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = svm.<span class="constant">SVC</span>(gamma=<span class="number">0</span>.<span class="number">001</span>, <span class="constant">C</span>=<span class="number">100</span>.)</span><br></pre></td></tr></table></figure>
<p><strong>选择模型参数</strong></p>
<p>在这个例子中，我们这设定了gamma值。可以通过使用<a href="http://scikit-learn.github.io/dev/modules/grid_search.html#grid-search" target="_blank" rel="external">网格搜索</a>和<a href="http://scikit-learn.github.io/dev/modules/cross_validation.html#cross-validation" target="_blank" rel="external">交叉验证</a>自动的找出最好的参数值</p>
<p>我们把我们的评估模型命名为clf，作为一个分类器，它现在必须拟合这个模型，也就是它必须从这个模型学习。我们通过将数据集传递给fit函数完成。作为训练集，除了最后一个样本，我们选择其余的所有样本。通过python语句[:-1]选择样本，这条语句将从digits.data中产生一个除了最后一个样本的新数组。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clf.fit(digits.data[:-<span class="number">1</span>], digits.target[:-<span class="number">1</span>])    </span><br><span class="line">SVC(<span class="variable">C=</span><span class="number">100.0</span>, <span class="variable">cache_size=</span><span class="number">200</span>, <span class="variable">class_weight=</span>None, <span class="variable">coef0=</span><span class="number">0.0</span>, <span class="variable">degree=</span><span class="number">3</span>,  </span><br><span class="line">  <span class="variable">gamma=</span><span class="number">0.001</span>, <span class="variable">kernel=</span>'rbf', <span class="variable">max_iter=</span>-<span class="number">1</span>, <span class="variable">probability=</span>False,  </span><br><span class="line">  <span class="variable">random_state=</span>None, <span class="variable">shrinking=</span>True, <span class="variable">tol=</span><span class="number">0.001</span>, <span class="variable">verbose=</span>False)</span><br></pre></td></tr></table></figure>
<p>现在，我们可以预测新值，尤其是我们可以问分类器在digits数据集中的用来训练分类器时没有使用的最后一个数据是数字几：</p>
<p>相应的图像如下所示:</p>
<center><br><img src="http://img.blog.csdn.net/20150720185355481" alt="这里写图片描述"><br></center>

<p>正如你看到的，这是一个具有挑战性的任务：图象的分辨率很低。你认同这个分类器吗？</p>
<p>一个完整的分类问题实例可以通过下面的链接下载，用来作为你运行并且学习的例子 <a href="http://scikit-learn.github.io/dev/auto_examples/classification/plot_digits_classification.html#example-classification-plot-digits-classification-py" target="_blank" rel="external">Recognizing hand-written digits</a></p>
<h2 id="模型持久化"><strong>模型持久化</strong></h2><p>可以通过使用python的built-in持久化模型在scikit中保存一个模型，命名<a href="http://docs.python.org/library/pickle.html" target="_blank" rel="external">pickle</a>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn import svm</span><br><span class="line">&gt;&gt;&gt; from sklearn import datasets</span><br><span class="line">&gt;&gt;&gt; clf = svm.<span class="function"><span class="title">SVC</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; iris = datasets.<span class="function"><span class="title">load_iris</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; X, y = iris<span class="class">.data</span>, iris<span class="class">.target</span></span><br><span class="line">&gt;&gt;&gt; clf.<span class="function"><span class="title">fit</span><span class="params">(X, y)</span></span>  </span><br><span class="line">SVC(C=<span class="number">1.0</span>, cache_size=<span class="number">200</span>, class_weight=None, coef0=<span class="number">0.0</span>,</span><br><span class="line">  decision_function_shape=None, degree=<span class="number">3</span>, gamma=<span class="string">'auto'</span>, kernel=<span class="string">'rbf'</span>,</span><br><span class="line">  max_iter=-<span class="number">1</span>, probability=False, random_state=None, shrinking=True,</span><br><span class="line">  tol=<span class="number">0.001</span>, verbose=False)</span><br><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line">&gt;&gt;&gt; s = pickle.<span class="function"><span class="title">dumps</span><span class="params">(clf)</span></span></span><br><span class="line">&gt;&gt;&gt; clf2 = pickle.<span class="function"><span class="title">loads</span><span class="params">(s)</span></span></span><br><span class="line">&gt;&gt;&gt; clf2.<span class="function"><span class="title">predict</span><span class="params">(X[<span class="number">0</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">array</span><span class="params">([<span class="number">0</span>])</span></span></span><br><span class="line">&gt;&gt;&gt; y[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在scikit的特别情况下，使用joblib替换pickle(joblib.dump &amp; joblib.load)会更有趣,它在大数据上是更有效的，但是仅仅只能存入的是字典而不是字符串。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.externals</span> import joblib</span><br><span class="line">&gt;&gt;&gt; joblib.<span class="function"><span class="title">dump</span><span class="params">(clf, <span class="string">'filename.pkl'</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>然后你就可以读取上面的pickled模型使用了（通常是在其它的Python程序中）：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; clf = joblib.<span class="function"><span class="title">load</span><span class="params">(<span class="string">'filename.pkl'</span>)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="惯例"><strong>惯例</strong></h2><p>scikit-learn估计量有一些特定的规则是的分类器更具有预测性</p>
<p><strong>Type casting 类型转换</strong></p>
<p>除非特别指定，否则输入格式是float64</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import numpy as np</span><br><span class="line">&gt;&gt;&gt; from sklearn import random_projection</span><br><span class="line">&gt;&gt;&gt; rng = np<span class="class">.random</span><span class="class">.RandomState</span>(<span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; X = rng.<span class="function"><span class="title">rand</span><span class="params">(<span class="number">10</span>, <span class="number">2000</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; X = np.<span class="function"><span class="title">array</span><span class="params">(X, dtype=<span class="string">'float32'</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; X<span class="class">.dtype</span></span><br><span class="line"><span class="function"><span class="title">dtype</span><span class="params">(<span class="string">'float32'</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; transformer = random_projection.<span class="function"><span class="title">GaussianRandomProjection</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; X_new = transformer.<span class="function"><span class="title">fit_transform</span><span class="params">(X)</span></span></span><br><span class="line">&gt;&gt;&gt; X_new<span class="class">.dtype</span></span><br><span class="line"><span class="function"><span class="title">dtype</span><span class="params">(<span class="string">'float64'</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，X是float32，通过fit_transform(X)把它转为float64</p>
<p>回归的输出值是float64，分类的也是：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn <span class="built_in">import</span> datasets</span><br><span class="line">&gt;&gt;&gt; from sklearn.svm <span class="built_in">import</span> SVC</span><br><span class="line">&gt;&gt;&gt; <span class="variable">iris =</span> datasets.load_iris()</span><br><span class="line">&gt;&gt;&gt; <span class="variable">clf =</span> SVC()</span><br><span class="line">&gt;&gt;&gt; clf.fit(iris.data, iris.target)  </span><br><span class="line">SVC(<span class="variable">C=</span><span class="number">1.0</span>, <span class="variable">cache_size=</span><span class="number">200</span>, <span class="variable">class_weight=</span>None, <span class="variable">coef0=</span><span class="number">0.0</span>,</span><br><span class="line">  <span class="variable">decision_function_shape=</span>None, <span class="variable">degree=</span><span class="number">3</span>, <span class="variable">gamma=</span>'auto', <span class="variable">kernel=</span>'rbf',</span><br><span class="line">  <span class="variable">max_iter=</span>-<span class="number">1</span>, <span class="variable">probability=</span>False, <span class="variable">random_state=</span>None, <span class="variable">shrinking=</span>True,</span><br><span class="line">  <span class="variable">tol=</span><span class="number">0.001</span>, <span class="variable">verbose=</span>False)</span><br><span class="line">&gt;&gt;&gt; list(clf.predict(iris.data[:<span class="number">3</span>]))</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">&gt;&gt;&gt; clf.fit(iris.data, iris.target_names[iris.target])  </span><br><span class="line">SVC(<span class="variable">C=</span><span class="number">1.0</span>, <span class="variable">cache_size=</span><span class="number">200</span>, <span class="variable">class_weight=</span>None, <span class="variable">coef0=</span><span class="number">0.0</span>,</span><br><span class="line">  <span class="variable">decision_function_shape=</span>None, <span class="variable">degree=</span><span class="number">3</span>, <span class="variable">gamma=</span>'auto', <span class="variable">kernel=</span>'rbf',</span><br><span class="line">  <span class="variable">max_iter=</span>-<span class="number">1</span>, <span class="variable">probability=</span>False, <span class="variable">random_state=</span>None, <span class="variable">shrinking=</span>True,</span><br><span class="line">  <span class="variable">tol=</span><span class="number">0.001</span>, <span class="variable">verbose=</span>False)</span><br><span class="line">&gt;&gt;&gt; list(clf.predict(iris.data[:<span class="number">3</span>]))  </span><br><span class="line">['setosa', 'setosa', 'setosa']</span><br></pre></td></tr></table></figure>
<p>这里，第一次predict()返回的是一个整数数组，因为在拟合中用到了iris.target（一个整数数组），第二个predict返回的是一个字符串数组，因为用来拟合的是iris.target_names。</p>
<h2 id="Supplementary">Supplementary</h2><p>推介一个好用的python IDE：</p>
<blockquote>
<p>winPython下载地址：<a href="http://sourceforge.net/projects/winpython/files/WinPython_2.7/2.7.10.1/" target="_blank" rel="external">WinPython_2.7</a></p>
</blockquote>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>原文链接：<a href="http://scikit-learn.github.io/dev/tutorial/basic/tutorial.html">http://scikit-learn.github.io/dev/tutorial/basic/tutorial.html</a></p>
<p><strong>章节内容</strong></p>
<p>在这个章节中，我们主要介绍关于scikit-learn机器学习词库，并且将给出一个学习样例。</p>
<h2 id="机器学习：问题设置"><strong>机器学习：问题设置</strong></h2><p>通常，一个学习问题是通过一系列的n个样本数据来学习然后尝试预测未知数据的属性。如果每一个样本超过一个单一的数值，例如多维输入（也叫做多维数据），那么它就拥有了多个特征。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="scikit-learn" scheme="http://csuldw.github.io/tags/scikit-learn/"/>
    
      <category term="译文" scheme="http://csuldw.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Airbnb欺诈预测机器学习模型设计：准确率和召回率的故事（译）]]></title>
    <link href="http://csuldw.github.io/2015/07/18/2015-07-18-a%20precision-and-recall/"/>
    <id>http://csuldw.github.io/2015/07/18/2015-07-18-a precision-and-recall/</id>
    <published>2015-07-18T04:30:00.000Z</published>
    <updated>2016-03-08T08:44:23.384Z</updated>
    <content type="html"><![CDATA[<div style="text-align:right;padding-bottom:7px;">译者：<a href="http://blog.csdn.net/dream_angel_z" target="_blank" rel="external">刘帝伟</a>   审校：刘翔宇 朱正贵   责编：周建丁</div>


<p>Airbnb网站基于允许任何人将闲置的房屋进行长期或短期出租构建商业模式，来自房客或房东的欺诈风险是必须解决的问题。Airbnb信任和安全小组通过构建机器学习模型进行欺诈预测，本文介绍了其设计思想。假想模型是预测某些虚拟人物是否为“反面人物”，基本步骤：构建模型预期，构建训练集和测试集，特征学习，模型性能评估。其中特征转换倾向于采用条件概率编码（CP-coding），评估度量是准确率（Precision）和召回率（Recall），通常偏向于高召回率。<br><a id="more"></a><br><strong>以下为全文内容：</strong></p>
<p>在Airbnb网站上，我们专注于创造一个这样的地方：一个人可以属于任何地方。部分归属感来自于我们用户之间的信任，同时认识到他们的安全是我们最关心的。</p>
<p>虽然我们绝大多数的社区是由友好和可靠的房东和房客组成，但仍然有一小部分用户，他们试图从我们的网站中（非法）获利。这些都是非常罕见的，尽管如此，信任和安全小组还是因此而产生。</p>
<p>信任和安全小组主要是解决任何可能会发生在我们平台的欺诈行为。我们最主要目的是试图保护我们的用户和公司免于不同类型的风险。例如：退款风险——一个绝大多数电子商务企业都熟悉的风险问题。为了减少此类欺诈行为，信任和安全小组的数据科学家构建了不同种类的机器学习模型，用来帮助识别不同类型的风险。想要获得我们模型背后更多的体系结构信息，请参考以前的文章 <a href="http://nerds.airbnb.com/architecting-machine-learning-system-risk/" target="_blank" rel="external">机器学习风险系统的设计</a>。</p>
<p>在这篇文章中，我对机器学习的模型建立给了一个简短的思维过程概述。当然，每个模型都有所不同，但希望它能够给读者在关于机器学习中我们如何使用数据来帮助保护我们的用户以及如何改善模型的不同处理方法上带来一个全新的认识。在这篇文章中，我们假设想要构建一个这样的模型：预测某些虚构的角色是否是反面人物。</p>
<h3 id="试图预测的是什么？">试图预测的是什么？</h3><p>在模型建立中最基本的问题就是明确你想要用这个模型来预测什么。我知道这个听起来似乎很愚蠢，但很多时候，通过这个问题可以引发出其它更深层的问题。</p>
<p>即使是一个看似简单的角色分类模型，随着我们逐步深入地思考，也可以提出许多更深层的问题。例如，我们想要怎样来给这个模型评分：仅仅是给当前新介绍的角色还是给所有角色？如果是前者，我们想要评分的角色和人物介绍中的角色评分相差多远？如果是后者，我们又该多长时间给这些角色评分呢？</p>
<p>第一个想法可能是根据人物介绍中给每个角色的评分来建立模型。然而，这种模型，我们可能不能随着时间的推移动态地追踪人物的评分。此外，我们可能会因为在介绍时的一些“好”的特征而忽略了潜在的反面人物。</p>
<p>相反，我们还可以建立这样一个模型，只要他/她出现在情节里面就评分一次。这将让我们在每个时间段都会有人物评分并检测出任何异常情况。但是，考虑到在每个角色单独出现的情况下可能没有任何的角色类别发展，所以这可能也不是最实际的方法。</p>
<p>深思熟虑之后，我们决定把模型设计成介于这两种想法之间的模型。例如，建立这样一种模型，在每次有意义的事情发生的时候对角色进行评分，比如结交新盟友，龙族领地占领等等。在这种方式下，我们仍然可以随着时间的变化来跟踪人物的评分，同时，对没有最新进展的角色也不会多加评分。</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a2b74a98e.jpg" alt=""></p>
<h3 id="如何模拟得分？">如何模拟得分？</h3><p>因为我们的目的是分析每个时期的得分，所以我们的训练集要能反映出某段时间某个角色的类别行为，最后的训练数据集类似于下图：</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a2e11dabc_middle.jpg?_=23712" alt=""></p>
<p>与每个角色相关的时间不一定是连续的，因为我们关心的是那些有着重要事件发展的时间。</p>
<p>在这个实例当中，Jarden在3个不同的场合有着重要的角色发展并且在一段时间内持续扩充他的军队。相比之下，Dineas 在5个不同的场合有着重要的角色发展并且主管着4个龙族中心基地。</p>
<h3 id="采样">采样</h3><p>在机器学习模型中，从观测数据中下采样是有必要的。采样过程本身很简单，一旦有了所需要的训练数据集，就可以在数据集上做一个基于行的采样。</p>
<p>然而，由于这里描述的模型是处理每个角色多个时期的样本，基于行采样可能会导致这样一种情况，即在建立模型的数据和用来验证的数据之间，场景附加的人物角色被分离开。如下表所示：</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a304d75b7.jpg" alt=""></p>
<p>显然这并不是理想的采样，因为我们没有得到每个角色的整体描述，并且这些缺失的观测数据可能对建立一个好的模型至关重要。</p>
<p>出于这个原因，我们需要做基于角色的采样。这样做能确保在模型数据建立中包含所有场合附加的角色，或者什么都没有。</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a31c8bc17.jpg" alt=""></p>
<p>此外，当我们将我们的数据集切分为训练集和测试集时，通常这样的逻辑也适用。</p>
<h3 id="特征设计">特征设计</h3><p>特征设计是机器学习不可或缺的一部分，通常情况下，在特征种类的选择上，对数据的充分理解有助于形成一个更好的模型设计思路。特征设计的实例包括特征规范化和分类特征处理。</p>
<p>特征规范化是标准化特征的一种方式，允许更合理的对比。如下表所示：</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a34d3dd90.jpg" alt=""></p>
<p>从上表可知，每个人物都有10,000个士兵。然而，Serion掌权长达5年，而Dineas仅仅掌权2年。通过这些人物比较绝对的士兵数量可能并不是非常有效的。但是，通过人物掌权的年份来标准化他们可能会提供更好的见解，并且产生更有预测力的特征。</p>
<p>在分类特征的特征设计上值得单独的写一篇博客文章，因为有很多方式可以去处理它们。特别是对于缺失值的插补，请看一看以前的博客文章—— <a href="http://nerds.airbnb.com/overcoming-missing-values-in-a-rfc/" target="_blank" rel="external">使用随机森林分类器处理缺失值</a>。</p>
<p>转换分类特征最常见的方法就是矢量化（也称作one-hot encoding）。然而，在处理有许多不同级别的分类特征时，使用条件概率编码（CP-coding）则更为实用。</p>
<p>CP-coding的基本思想就是在给定的分类级别上，计算出某个特征值发生的概率。这种方法使得我们能够将所有级别的分类特征转化为一个单一的数值型变量。</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a3b87ef92.jpg" alt=""></p>
<p>然而，这种类型转换可能会因为没有充分描述的类别而造成噪音数据。在上面的例子中，我们只有一个来自House 为 “Tallight”的观测样本。结果相应的概率就是0或1。为了避免这种问题的发生并且降低噪声数据，通常情况下，可以通过考虑加权平均值，全局概率或者引入一个平滑的超系数来调整如何计算概率。</p>
<p>那么，哪一种方法最好呢？这取决于分类特征的数量和级别。CP-coding是个不错的选择，因为他降低了特征的维数，但是这样会牺牲掉特征与特征之间的互信息，这种方法称之为矢量化保留。此外，我们可以整合这两种方法，即组合相似的类别特征，然后使用CP-coding处理整合的特征。</p>
<h3 id="模型性能评估">模型性能评估</h3><p>当谈及到评估模型性能的时候，我们需要留意正面角色和反面角色的比例。在我们的例子模型中，数据最后的统计格式为[character*period]（下表左）。然而，模型评估应该以角色类别测量（下表右）。</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a3fb5a353.jpg" alt=""></p>
<p>结果，在模型的构建数据和模型的评估数据之间的正面人物和反面人物的比例有着明显的差异。当评估模型准确率和召回率的时候分配合适的权重值是相当重要的。</p>
<p>此外，因为我们可能会使用下采样以减少观测样本的数量，所以我们还需要调整模型占采样过程的准确率和召回率。</p>
<h3 id="评估准确率和召回率">评估准确率和召回率</h3><p>对于模型评估的两种主要的评估度量是准确率（Precision）和召回率（Recall）。在我们的例子当中，准确率是预测结果为反面角色中被正确预测为反面角色的比例。它在给定的阈值下衡量模型的准确度。另外，召回率是模型从原本为反面角色当中能够正确检测出为反面角色的比例。它在一个给定的阈值下以识别反面人物来衡量模型的综合指标。这两个变量很容易混淆，所以通过下表会更加的直观看出两者的不同。</p>
<p><img src="http://img.ptcms.csdn.net/article/201507/13/55a2a428441f6.jpg" alt=""></p>
<p>通常将最后的数据划分为四个不同的部分：</p>
<p>True Positives（TP）：角色是反面人物，模型预测为反面人物；<br>False Positives（FP）：角色是正面人物，模型预测为反面人物；<br>True Negatives（TN）：角色是正面人物，模型预测为正面人物；<br>False Negatives（FN）：角色是反面人物，模型预测为正面人物；<br>准确率计算：在所有被预测为反面人物中，模型正确预测的比例，即TP /（TP + FP）。</p>
<p>召回率计算：在所有原本就是反面人物中，模型正确预测的比例，即TP / (TP + FN）。</p>
<p>通过观察可以看出，尽管准确率和召回率的分子是相同的，但分母不同。</p>
<p>通常在选择高准确率和高召回率之间总有一种权衡。这要取决于构建模型的最终目的，对于某些情况而言，高准确率的选择可能会优于高召回率。然而，对于欺诈预测模型，通常要偏向于高召回率，即使会牺牲掉一些准确率。</p>
<p>有许多的方式可以用来改善模型的准确度和召回率。其中包括添加更好的特征，优化决策树剪枝或者建立一个更大的森林等等。不过，鉴于讨论广泛，我打算将其单独地放在一篇文章当中。</p>
<h3 id="结束语">结束语</h3><p>希望这篇文章能让读者了解到什么是构建机器学习模型所需要的。遗憾的是，没有放之四海而皆准的解决方案来构建一种好的模型，充分了解数据的上下文是关键，因为通过它我们能够从中提取出更多更好的预测特征，从而建立出更优化的模型。</p>
<p>最后，虽然将角色分为正面和反面是主观的，但类别标签的确是机器学习的一个非常重要的部分，而不好的类别标签通常会导致一个糟糕的模型。祝建模快乐!</p>
<p>注：这个模型确保每个角色都是正面角色或者是反面角色，即如果他们生来就是反面角色，那么在他们的整个生命当中都是反面角色。如果我们假设角色可以跨越类别标签作为中立人物，那么模型的设计将会完全不同。</p>
<p>英文原文： <a href="http://nerds.airbnb.com/designing-machine-learning-models/" target="_blank" rel="external">Designing Machine Learning Models: A Tale of Precision and Recall</a>（译者/刘帝伟 审校/刘翔宇、朱正贵 责编/周建丁）</p>
<p>关于译者： <a href="http://my.csdn.net/Dream_angel_Z" target="_blank" rel="external">刘帝伟</a>，中南大学在读研究生，关注机器学习、数据挖掘及生物信息领域。 </p>
<hr>
<p>本文为CSDN编译整理，未经允许不得转载，如需转载请联系market#csdn.net(#换成@)</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<div style="text-align:right;padding-bottom:7px;">译者：<a href="http://blog.csdn.net/dream_angel_z">刘帝伟</a>   审校：刘翔宇 朱正贵   责编：周建丁</div>


<p>Airbnb网站基于允许任何人将闲置的房屋进行长期或短期出租构建商业模式，来自房客或房东的欺诈风险是必须解决的问题。Airbnb信任和安全小组通过构建机器学习模型进行欺诈预测，本文介绍了其设计思想。假想模型是预测某些虚拟人物是否为“反面人物”，基本步骤：构建模型预期，构建训练集和测试集，特征学习，模型性能评估。其中特征转换倾向于采用条件概率编码（CP-coding），评估度量是准确率（Precision）和召回率（Recall），通常偏向于高召回率。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="Precision" scheme="http://csuldw.github.io/tags/Precision/"/>
    
      <category term="Recall" scheme="http://csuldw.github.io/tags/Recall/"/>
    
      <category term="译文" scheme="http://csuldw.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个简单的Python函数运行时间计时器]]></title>
    <link href="http://csuldw.github.io/2015/07/16/2015-07-16%20Python%20timer/"/>
    <id>http://csuldw.github.io/2015/07/16/2015-07-16 Python timer/</id>
    <published>2015-07-16T12:24:25.000Z</published>
    <updated>2016-03-13T05:58:45.846Z</updated>
    <content type="html"><![CDATA[<p>在实际开发中，往往想要计算一段代码运行多长时间，下面我将该功能写入到一个函数里面，只要在每个函数前面调用该函数即可，见下面代码：</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_timer</span><span class="params">(function)</span>:</span></span><br><span class="line">    <span class="decorator">@wraps(function)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">function_timer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = function(*args, **kwargs)</span><br><span class="line">        t1 = time.time()</span><br><span class="line">        os.system(<span class="string">" echo Total time running %s: %s seconds"</span> % (function.func_name, str(t1-t0)) + <span class="string">" &gt;&gt; timecount.log"</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> function_timer</span><br><span class="line"><span class="comment">#-----------------------------------</span></span><br></pre></td></tr></table></figure>
<p>说明：<font color="green"><strong>一个记时器，只要在函数前面写上@fun_timer即可</strong></font>.</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>在实际开发中，往往想要计算一段代码运行多长时间，下面我将该功能写入到一个函数里面，只要在每个函数前面调用该函数即可，见下面代码：</p>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="计时器" scheme="http://csuldw.github.io/tags/%E8%AE%A1%E6%97%B6%E5%99%A8/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开发者成功使用机器学习的十大诀窍(译)]]></title>
    <link href="http://csuldw.github.io/2015/07/13/2015-07-13-10%20keys%20to%20successful%20machine%20learning%20for%20developers/"/>
    <id>http://csuldw.github.io/2015/07/13/2015-07-13-10 keys to successful machine learning for developers/</id>
    <published>2015-07-13T13:53:12.000Z</published>
    <updated>2016-03-13T05:58:58.804Z</updated>
    <content type="html"><![CDATA[<div style="text-align:right;padding-bottom:7px;">译者：<a href="http://blog.csdn.net/dream_angel_z" target="_blank" rel="external">刘帝伟</a>   审校：刘翔宇 朱正贵   责编：周建丁</div>

<p>在提供发现埋藏数据深层的模式的能力上，机器学习有着潜在的能力使得应用程序更加的强大并且更能响应用户的需求。精心调校好的算法能够从巨大的并且互不相同的数据源中提取价值，同时没有人类思考和分析的限制。对于开发者而言，机器学习为应用业务的关键分析提供了希望，从而实现从改善客户体验到提供产品推荐上升至超个性化内容服务的任何应用程序。<br><a id="more"></a><br>像Amazon和Micorosoft这样的云供应商提供云功能的机器学习解决方案，承诺为开发者提供一个简单的方法，使得机器学习的能力能够融入到他们的应用程序当中，这也算是最近的头条新闻了。承诺似乎很好，但开发者还需谨慎。</p>
<p>对于开发人员而言，基于云的机器学习工具带来了使用机器学习创造和提供新的功能的可能性。然而，当我们使用不当时，这些工具会输出不好的结果，用户可能会因此而感到不安。测试过<a href="http://how-old.net/" target="_blank" rel="external">微软年龄检测机器学习工具</a>的人都会发现，伴随即插即用的易用性而来的是主要的精度问题——对于关键应用程序或者是重大决策，它应该不值得信赖。</p>
<p>想要在应用程序中成功地融入机器学习的开发者，需要注意以下的一些关键要点：</p>
<p><strong>1.算法使用的数据越多，它的精度会更加准确，所以如果可能要尽量避免抽样。</strong>机器学习理论在预测误差上有着非常直观的描述。简而言之，在机器学习模型和最优预测（在理论上达到最佳可能的误差）之间的预测误差的差距可以被分解为三个部分：</p>
<ul>
<li>由于没有找到正确函数形式的模型的误差</li>
<li>由于没有找到最佳参数的模型的误差</li>
<li>由于没用使用足够数据的模型的误差</li>
<li>如果训练集有限，它可能无法支撑解决这个问题所需的模型复杂性。统计学的基本规律告诉我们，如果我们可以的话，应该利用所有的数据而不是抽样。</li>
</ul>
<p><strong>2.对给定的问题选择效果最好的机器学习算法是决定成败的关键。</strong>例如，梯度提升树（GBT）是一个非常受欢迎的监督学习算法，由于其精度而被业内开发人员广泛使用。然而，尽管其高度受欢迎，我们也不能盲目的把这种算法应用于任何问题上。相反，我们使用的算法应该是能够最佳地拟合数据特征同时能够保证精度的算法。</p>
<p>为了证明这个观点，尝试做这样一个实验，在数据集 <a href="http://www.daviddlewis.com/resources/testcollections/rcv1/" target="_blank" rel="external">the popular text categorization dataset rcv1</a>上测试GBT算法和线性支持向量机（SVM）算法，并比较两者的精度。我们观察到在这个问题上，就错误率而言，线性SVM要优于GBT算法。这是因为在文本领域当中，数据通常是高维的。一个线性分类器能够在N-1维当中完美的分离出N个样本，所以，一个样本模型在这种数据上通常表现的更好。此外，模型越简单，通过利用有限的训练样本来避免过拟合的方式学习参数，并且提供一个精确的模型，产生的问题也会随之越少。</p>
<p>另一方面，GBT是高度非线性的并且更加强大，但是在这种环境中却更难学习并且更容易发生过拟合，往往结果精度也较低。</p>
<p><strong>3.为了得到一个更好的模型，必须选择最佳的的算法和相关的参数。</strong>这对于非数据科学家而言可能不容易。现代的机器学习算法有许多的参数可以调整。例如，对于流行的GBT算法单独的就有十二个参数可以设置，其中包括如何控制树的大小，学习率，行或列的采样方法，损失函数，正则化选项等等。一个特有的项目需要在给定的数据集上为每一个参数找到其最优值并且达到最精准的精度，这确实不是一件容易的事。但是为了得到最佳的结果，数据科学家需要训练大量的模型，而直觉和经验会帮助他们根据交叉验证的得分，然后决定使用什么参数再次尝试。</p>
<p><strong>4.机器学习模型会随着好的数据而变得更好，错误的数据收集和数据处理会降低你建立预测和归纳的机器学习模型的能力。</strong>根据经验，建议仔细审查与主题相关的数据，从而深入了解数据和幕后数据的生成过程。通常这个过程可以识别与记录、特征、值或采样相关的数据质量问题。</p>
<p><strong>5.理解数据特征并改进它们（通过创造新的特征或者去掉某个特征）对预测能力有着高度的影响。</strong>机器学习的一个基本任务就是找到能够被机器学习算法充分利用的丰富特征空间来替代原始数据。例如，特征转换是一种流行的方法，可以通过在原始数据的基础上使用数学上的转换提取新的特征来实现。最后的特征空间（也就是最后用来描述数据的特征）要能更好的捕获数据的多复杂性（如非线性和多种特征之间的相互作用），这对于成功的学习过程至关重要。</p>
<p><strong>6.在应用中，选择合适的灵感来自商业价值的目标函数/损失函数对于最后的成功至关重要。</strong>几乎所有的机器学习算法最后都被当成是一种优化问题。根据业务的性质，合理设置或调整优化的目标函数，是机器学习成功的关键。</p>
<p>以支持向量机为例，通过假设所有错误类型的权重相等，对一个二分类问题的泛化误差进行了优化。这对损失敏感的问题并不合适，如故障检测，其中某些类型的错误比重可能比其它类型的要高。在这种情况下，建议通过在特定的错误类型上，增加更多的惩罚来解释它们的权重，从而调整SVM的损失函数。</p>
<p><strong>7.确保正确地处理训练数据和测试数据，如此当在生产中部署该模型时，测试数据能够模拟输入数据。</strong>例如，我们可以看到，这对于时间依赖性数据是多么的重要。在这种情况下，使用标准的交叉验证方法进行训练，调整，那么测试模型的结果可能会有偏差，甚至会不准确。这是因为在实施平台上它不能准确的模拟输入数据的性质。为了纠正这一点，在部署时我们必须仿照模型来部署使用。我们应该使用一个基于时间的交叉验证，用时间较新的数据来验证训练模型。</p>
<p><strong>8.部署前理解模型的泛化误差。泛化误差衡量模型在未知数据上的性能好坏。</strong>因为一个模型在训练数据上的性能好并不意味着它在未知的数据上的表现也好。一个精心设计的模拟实际部署使用的模型评估过程，是估计模型泛化误差所需要的。</p>
<p>一不留心就很容易违反交叉验证的规则，并且也没有一种显而易见的方法来表现交叉验证的非正确性，通常在你试图寻找快捷方式计算时发生。在任何模型部署之前，有必要仔细注意交叉验证的正确性，以获得部署性能的科学评估。</p>
<p><strong>9.知道如何处理非结构化和半结构化数据，如文本、时间序列、空间、图形或者图像数据。</strong>大多数机器学习算法在处理特征空间中的数据时，一个特征集代表一个对象，特征集的每一个元素都描述对象的一个特点。在实际当中，数据引进时并不是这种格式化的形式，往往来自于最原始的格式，并且最后都必须被改造成机器学习算法能够识别的理想格式。比如，我们必须知道如何使用各种计算机视觉技术从图像中提取特征或者如何将自然语言处理技术应用于影片文本。</p>
<p><strong>10.学会将商业问题转换成机器学习算法。</strong>一些重要的商业问题，比如欺诈检测、产品推荐、广告精准投放，都有“标准”的机器学习表达形式并且在实践当中取得了合理的成就。即使对于这些众所周知的问题，也还有鲜为人知但功能更强大的表达形式，从而带来更高的预测精度。对于一般在博客和论坛中讨论的小实例的商业问题，适当的机器学习方法则不太明显。</p>
<p>如果你是一个开发者，学习这十个通往成功的诀窍可能似乎是一个艰难的任务，但是不要气馁。事实上，开发者不是数据科学家。认为开发人员可以充分利用所有的机学习工具是不公平的。但是这并不意味着开发人员没有机会去学习一些有水准的数据科学从而改进他们的应用。随着适当的企业解决方案和自动化程度的提高，开发人员可以做模型构建到实施部署的一切事情，使用机器学习最佳实践来保持高精度。</p>
<p>自动化是在应用程序中扩展机器学习的关键。即使你能够供得起一批小的数据科学家团队和开发者携手合作，也没有足够的人才。像Skytree的AutoModel（自动化模型）能够帮助开发者自动地确定最佳的参数并且使得算法得到最大的模型精度。一个易于使用的接口可以引导开发人员通过训练加工，调整并且测试模型来防止统计上的错误。</p>
<p>自动化机器学习过程，有许多方式，包括数据科学家或开发者的人工智能原理，允许算法去思考，学习并且承受更多的建模重任。也就是说，认为数据科学家能够从机器学习中解耦是错误的，特别是在关键任务模型上。谨防这种能够简单使用机器学习功能的承诺，即能够在不需要正确复杂的思考下或者可扩展的应用技术下就使用机器学习——这通常并不会得到高预测精度和机器学习提供的高商业价值结果。更糟糕的是，在应用程序中使用不好的模型实际上可能会适得其反，并迅速在其用户之间建立不信任的产品或服务。</p>
<p>英文原文： <a href="http://www.infoworld.com/article/2943862/application-development/what-developers-need-to-know-about-machine-learning.html" target="_blank" rel="external">10 keys to successful machine learning for developers</a> （译者/<a href="http://blog.csdn.net/dream_angel_z" target="_blank" rel="external">刘帝伟</a> 审校/刘翔宇、朱正贵 责编/周建丁）</p>
<p>作者简介：Alexander Gray，Skytree首席技术官，佐治亚理工学院计算机学院副教授，主要致力于大规模数据集的机器学习算法技术研发，1993年开始在NASA喷气推进实验室机器学习系统小组从事大规模科学数据的工作。</p>
<p>译者简介： <a href="http://blog.csdn.net/dream_angel_z" target="_blank" rel="external">刘帝伟</a>，中南大学软件学院在读研究生，关注机器学习、数据挖掘及生物信息领域。</p>
<p>【预告】<a href="http://ccai2015.csdn.net/" target="_blank" rel="external">首届中国人工智能大会（CCAI 2015）</a>将于7月26-27日在北京友谊宾馆召开。机器学习与模式识别、大数据的机遇与挑战、人工智能与认知科学、智能机器人四个主题专家云集。人工智能产品库将同步上线，预约咨询：QQ：1192936057。欢迎关注。</p>
<p>本文为CSDN编译整理，未经允许不得转载，如需转载请联系market#csdn.net(#换成@)</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<div style="text-align:right;padding-bottom:7px;">译者：<a href="http://blog.csdn.net/dream_angel_z">刘帝伟</a>   审校：刘翔宇 朱正贵   责编：周建丁</div>

<p>在提供发现埋藏数据深层的模式的能力上，机器学习有着潜在的能力使得应用程序更加的强大并且更能响应用户的需求。精心调校好的算法能够从巨大的并且互不相同的数据源中提取价值，同时没有人类思考和分析的限制。对于开发者而言，机器学习为应用业务的关键分析提供了希望，从而实现从改善客户体验到提供产品推荐上升至超个性化内容服务的任何应用程序。<br>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="译文" scheme="http://csuldw.github.io/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据预处理-PDB文件]]></title>
    <link href="http://csuldw.github.io/2015/07/07/2015-07-07-PDB/"/>
    <id>http://csuldw.github.io/2015/07/07/2015-07-07-PDB/</id>
    <published>2015-07-07T15:23:23.000Z</published>
    <updated>2016-03-08T08:48:57.705Z</updated>
    <content type="html"><![CDATA[<p>以下代码为个人原创，python实现，是处理PDB文件的部分常用代码，仅供参考！</p>
<h3 id="1-下载PDB文件">1.下载PDB文件</h3><p>下面是一个下载PDB文件的函数，传入的参数是一个写有pdb名字的namefile文件，函数的核心部分是三个系统命令，先通过wget下载，然后解压，最后替换名字。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadpdb</span><span class="params">(namefile)</span>:</span></span><br><span class="line">    inputfile = open(namefile, <span class="string">'r'</span>)</span><br><span class="line">    <span class="keyword">for</span> eachline <span class="keyword">in</span> inputfile:</span><br><span class="line">        pdbname = eachline.lower().strip()</span><br><span class="line">        os.system(<span class="string">"wget http://ftp.wwpdb.org/pub/pdb/data/structures/all/pdb/pdb"</span> + pdbname + <span class="string">".ent.gz"</span>)</span><br><span class="line">        os.system(<span class="string">"gzip -d pdb"</span> + pdbname + <span class="string">'.ent.gz'</span>)</span><br><span class="line">        os.system(<span class="string">"mv pdb"</span> + pdbname + <span class="string">".ent "</span> + pdbname.upper() + <span class="string">'.pdb'</span>)</span><br></pre></td></tr></table></figure>
<p>测试用例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">'/ifs/home/liudiwei/datasets/RPdatas'</span>)</span><br><span class="line">downloadpdb(<span class="string">'protein.name'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-PDB转DSSP">2.PDB转DSSP</h3><p>将下载的PDB文件转成DSSP文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理一行dssp数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatdsspline</span><span class="params">(dsspline)</span>:</span></span><br><span class="line">    eachline  = dsspline</span><br><span class="line">    col = <span class="string">'\t'</span> + eachline[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">5</span>:<span class="number">10</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">10</span>:<span class="number">12</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">12</span>:<span class="number">15</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">15</span>:<span class="number">25</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">25</span>:<span class="number">39</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">29</span>:<span class="number">34</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">34</span>:<span class="number">38</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">38</span>:<span class="number">50</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">50</span>:<span class="number">61</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">61</span>:<span class="number">72</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">72</span>:<span class="number">83</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">83</span>:<span class="number">92</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">92</span>:<span class="number">97</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">97</span>:<span class="number">103</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">103</span>:<span class="number">109</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">109</span>:<span class="number">115</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">115</span>:<span class="number">122</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">122</span>:<span class="number">129</span>]</span><br><span class="line">    col += <span class="string">'\t'</span> + eachline[<span class="number">129</span>:<span class="number">136</span>]</span><br><span class="line">    <span class="keyword">return</span> col</span><br></pre></td></tr></table></figure>
<p>PDB转DSSP格式，需要DSSP软件</p>
<p>参数：</p>
<ul>
<li>pdbdir: pdb文件目录   </li>
<li>dsspdir: 生成的dssp文件目录（需创建）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pdbToDSSP</span><span class="params">(pdbnamefile,pdbdir, dsspdir)</span>:</span>    </span><br><span class="line">    pdbfiles = os.listdir(pdbdir)</span><br><span class="line">    <span class="comment">#对于每个pdb文件，生成对应的dssp文件，并保存在dssp目录下</span></span><br><span class="line">    <span class="keyword">for</span> pdb_file <span class="keyword">in</span> pdbfiles:</span><br><span class="line">        pdb_name = pdb_file.split(<span class="string">'.'</span>)[<span class="number">0</span>].upper()</span><br><span class="line">        command = <span class="string">'DSSPCMBI.EXE -x '</span> + pdbdir +<span class="string">'/'</span>+ pdb_file + <span class="string">'  '</span>+ dsspdir +<span class="string">"/"</span>+ pdb_name +<span class="string">'.dssp'</span></span><br><span class="line">        os.system(command) </span><br><span class="line">    dsspfiles = os.listdir(dsspdir)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(dsspdir + <span class="string">"/DSSP"</span>):      <span class="comment">#判断DSSP文件是否存在，存在则删除</span></span><br><span class="line">        dsspfiles.remove(<span class="string">"DSSP"</span>)</span><br><span class="line">    output=open(dsspdir + <span class="string">'/DSSP'</span>,<span class="string">'w'</span>)</span><br><span class="line">    <span class="comment">#循环读取dssp文件，将其合并成一个整的DSSP</span></span><br><span class="line">    <span class="keyword">with</span> open(pdbnamefile, <span class="string">'r'</span>) <span class="keyword">as</span> namefile:</span><br><span class="line">        <span class="keyword">for</span> eachline <span class="keyword">in</span> namefile:</span><br><span class="line">            pdb_name = eachline.strip() </span><br><span class="line">            dssp_file = pdb_name + <span class="string">'.dssp'</span></span><br><span class="line">        <span class="comment">#for dssp_file in dsspfiles:</span></span><br><span class="line">            <span class="comment">#pdb_name = dssp_file.split('.')[0]</span></span><br><span class="line">            <span class="keyword">with</span> open(dsspdir + <span class="string">'/'</span> + dssp_file,<span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dsspdir + <span class="string">'/format'</span>):</span><br><span class="line">                    os.mkdir(dsspdir + <span class="string">'/format'</span>)</span><br><span class="line">                <span class="keyword">with</span> open(dsspdir + <span class="string">'/format/'</span> + pdb_name + <span class="string">'.dssp.format'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> singleOut:</span><br><span class="line">                    count = <span class="number">0</span>; preRes=[]</span><br><span class="line">                    sets = set(<span class="string">''</span>);content=<span class="string">''</span>   </span><br><span class="line">                    <span class="keyword">for</span> eachline <span class="keyword">in</span> f.readlines():</span><br><span class="line">                        list1=[];oneline=[]</span><br><span class="line">                        count+=<span class="number">1</span></span><br><span class="line">                        list1.append(pdb_name)                             </span><br><span class="line">                        <span class="keyword">if</span> count &gt;= <span class="number">29</span>:</span><br><span class="line">                            eachline = formatdsspline(eachline)</span><br><span class="line">                            oneline = eachline.split(<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> oneline[<span class="number">3</span>].strip():</span><br><span class="line">                                preRes = oneline[<span class="number">3</span>].strip()                        </span><br><span class="line">                            </span><br><span class="line">                            list1.append(eachline)</span><br><span class="line">                            content += <span class="string">""</span>.join(list1)+<span class="string">'\n'</span>                            </span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span> <span class="string">'!'</span> == oneline[<span class="number">4</span>].strip():</span><br><span class="line">                                <span class="keyword">continue</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="keyword">if</span> <span class="string">'!*'</span> <span class="keyword">in</span> eachline <span class="keyword">or</span> <span class="keyword">not</span> oneline[<span class="number">3</span>].strip():</span><br><span class="line">                                <span class="keyword">if</span> preRes <span class="keyword">in</span> sets <span class="keyword">and</span> len(sets):</span><br><span class="line">                                    content=<span class="string">''</span></span><br><span class="line">                                    preRes=[]</span><br><span class="line">                                    <span class="keyword">continue</span></span><br><span class="line">                                sets.add(preRes)</span><br><span class="line">                                output.write(content)</span><br><span class="line">                                singleOut.write(content)</span><br><span class="line">                                content=<span class="string">''</span></span><br><span class="line">                    <span class="keyword">if</span> preRes <span class="keyword">and</span> preRes <span class="keyword">not</span> <span class="keyword">in</span> sets:</span><br><span class="line">                        output.write(content)</span><br><span class="line">                        singleOut.write(content)</span><br><span class="line">    output.close()</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#test</span></span><br><span class="line">pdbdir = <span class="string">'z:/datasets/protein/pdb'</span></span><br><span class="line">dsspdir = <span class="string">'Z:/datasets/protein/DSSPdir'</span> </span><br><span class="line">proname = <span class="string">'Z:/datasets/protein/protein.name'</span></span><br><span class="line">pdbToDSSP(proname,pdbdir, dsspdir)</span><br></pre></td></tr></table></figure>
<h3 id="3-DSSP抽取序列">3.DSSP抽取序列</h3><p>从一个整合的DSSP文件中抽取序列文件 </p>
<p>从格式化后的dssp文件获取序列信息</p>
<p>参数：dsspfile为格式过的DSSP文件,seqfile为输出的序列文件,同时输出序列文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSeqFromDSSP</span><span class="params">(dsspfile, seqfile, minLen)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(dsspfile, <span class="string">'r'</span>) <span class="keyword">as</span> inputfile:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> seqfile.strip():</span><br><span class="line">            seqfile = <span class="string">'protein'</span>+minLen + <span class="string">'.dssp.seq'</span></span><br><span class="line">        outchain = open(<span class="string">'protein40.chain.all'</span>, <span class="string">'w'</span>)</span><br><span class="line">        <span class="keyword">with</span> open(seqfile, <span class="string">'w'</span>) <span class="keyword">as</span> outputfile:</span><br><span class="line">            residue=[];Ntype=[]</span><br><span class="line">            preType=[];preRes=[]</span><br><span class="line">            firstline=[];secondline=[];content=<span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> eachline <span class="keyword">in</span> inputfile:</span><br><span class="line">                oneline = eachline.split(<span class="string">'\t'</span>)</span><br><span class="line">                residue = oneline[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> residue.strip(): </span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                Ntype = oneline[<span class="number">3</span>].strip()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> Ntype.strip():</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> preRes!=residue:</span><br><span class="line">                    content = <span class="string">''</span>.join(firstline)+<span class="string">'\n'</span> + <span class="string">''</span>.join(secondline) +<span class="string">'\n'</span></span><br><span class="line">                    <span class="keyword">if</span> len(secondline) &gt;=minLen <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">'X'</span> <span class="keyword">in</span> secondline:</span><br><span class="line">                        outchain.write(<span class="string">''</span>.join(firstline) + <span class="string">'\n'</span>)</span><br><span class="line">                        outputfile.write(content)</span><br><span class="line">                    firstline=[]</span><br><span class="line">                    firstline.append(<span class="string">'&gt;'</span> + residue + <span class="string">':'</span> + Ntype)</span><br><span class="line">                    secondline=[];secondline.append(oneline[<span class="number">4</span>].strip())</span><br><span class="line">                    preRes = residue;preType = Ntype</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> Ntype != preType:</span><br><span class="line">                    content = <span class="string">''</span>.join(firstline)+<span class="string">'\n'</span> + <span class="string">''</span>.join(secondline) +<span class="string">'\n'</span></span><br><span class="line">                    <span class="keyword">if</span> len(secondline) &gt;=minLen <span class="keyword">and</span>  <span class="keyword">not</span> <span class="string">'X'</span> <span class="keyword">in</span> secondline:</span><br><span class="line">                        outchain.write(<span class="string">''</span>.join(firstline) + <span class="string">'\n'</span>)</span><br><span class="line">                        outputfile.write(content)</span><br><span class="line">                    firstline=[]</span><br><span class="line">                    firstline.append(<span class="string">'&gt;'</span> + residue + <span class="string">':'</span> + Ntype)</span><br><span class="line">                    secondline=[];secondline.append(oneline[<span class="number">4</span>].strip())</span><br><span class="line">                    preRes = residue;preType = Ntype</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment">#如果Ntype不为空，且等于preType</span></span><br><span class="line">                    secondline.append(oneline[<span class="number">4</span>].strip())</span><br><span class="line">            content = <span class="string">''</span>.join(firstline)+<span class="string">'\n'</span> + <span class="string">''</span>.join(secondline) +<span class="string">'\n'</span></span><br><span class="line">            <span class="keyword">if</span> len(secondline) &gt;=minLen <span class="keyword">and</span> <span class="keyword">not</span> <span class="string">'X'</span> <span class="keyword">in</span> secondline:  <span class="comment">#选择长度大于40</span></span><br><span class="line">                outchain.write(<span class="string">''</span>.join(firstline) + <span class="string">'\n'</span>)</span><br><span class="line">                outputfile.write(content)</span><br><span class="line">        outchain.close()</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">r"E:\3-CSU\Academic\_Oriented\analysis\experiment\Datasets\ptest.dssp"</span>)</span><br><span class="line">pdbfile = <span class="string">'DSSP'</span></span><br><span class="line">outfile = <span class="string">'protein.seq'</span></span><br><span class="line">getSeqFromDSSP(pdbfile,outfile)</span><br></pre></td></tr></table></figure>
<h3 id="4-对序列做blast聚类">4.对序列做blast聚类</h3><p>设置相应的参数，在服务器上跑blast，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifs/share/lib/cd-hit-v4.5.4/cd-hit -i /ifs/home/liudiwei/datasets/protein40.seq -o /ifs/home/liudiwei/experiment/cdhit/fasta.40 -c <span class="number">0.4</span> -n <span class="number">2</span> -M <span class="number">2000</span></span><br></pre></td></tr></table></figure>
<h3 id="5-生成聚类后的DSSP，得到protein-name、protein-seq、protein-chain三个文件">5.生成聚类后的DSSP，得到protein.name、protein.seq、protein.chain三个文件</h3><p>从原来的DSSP文件中，根据聚类后的链名抽取新的DSSP文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># extract dssp from old dssp file</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractDSSP</span><span class="params">(dsspfile, chainname, outfile)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(outfile, <span class="string">'w'</span>) <span class="keyword">as</span> outdssp:</span><br><span class="line">        <span class="keyword">with</span> open(dsspfile, <span class="string">'r'</span>) <span class="keyword">as</span> inputdssp:</span><br><span class="line">            <span class="keyword">for</span> eachline <span class="keyword">in</span> inputdssp:</span><br><span class="line">                oneline = eachline.split(<span class="string">'\t'</span>)</span><br><span class="line">                <span class="comment">#preNum = oneline[2].strip()     </span></span><br><span class="line">                <span class="keyword">with</span> open(chainname,<span class="string">'r'</span>) <span class="keyword">as</span> chainfile:       </span><br><span class="line">                    <span class="keyword">for</span> eachchain <span class="keyword">in</span> chainfile:</span><br><span class="line">                        protein_ame = eachchain[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line">                        chain_id = eachchain[<span class="number">6</span>:<span class="number">7</span>]</span><br><span class="line">                        <span class="keyword">if</span> oneline[<span class="number">0</span>].strip() == protein_ame <span class="keyword">and</span> oneline[<span class="number">3</span>].strip() == chain_id:</span><br><span class="line">                            outdssp.write(eachline)</span><br><span class="line">                            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>测试实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dsspfile = <span class="string">'/ifs/home/liudiwei/datasets/832.protein/DSSPdir1/DSSP'</span></span><br><span class="line">chainname = <span class="string">'/ifs/home/liudiwei/experiment/step1/832p.cluster/cdhit/protein.chain'</span></span><br><span class="line">outfile = <span class="string">'/ifs/home/liudiwei/experiment/step1/832p.cluster/cdhit/DSSP'</span></span><br><span class="line">extractDSSP(dsspfile, chainname, outfile )</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下代码为个人原创，python实现，是处理PDB文件的部分常用代码，仅供参考！</p>
<h3 id="1-下载PDB文件">1.下载PDB文件</h3><p>下面是一个下载PDB文件的函数，传入的参数是一个写有pdb名字的namefile文件，函数的核心部分是三个系统命令，先通过wget下载，然后解压，最后替换名字。</p>]]>
    
    </summary>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/tags/BioInfo/"/>
    
      <category term="PDB" scheme="http://csuldw.github.io/tags/PDB/"/>
    
      <category term="预处理" scheme="http://csuldw.github.io/tags/%E9%A2%84%E5%A4%84%E7%90%86/"/>
    
      <category term="BioInfo" scheme="http://csuldw.github.io/categories/BioInfo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法-Adaboost]]></title>
    <link href="http://csuldw.github.io/2015/07/05/2015-07-05-ML-algorithm-Adaboost/"/>
    <id>http://csuldw.github.io/2015/07/05/2015-07-05-ML-algorithm-Adaboost/</id>
    <published>2015-07-05T14:53:12.000Z</published>
    <updated>2016-03-13T05:59:28.639Z</updated>
    <content type="html"><![CDATA[<p>Github源码实现:<a href="https://github.com/csuldw/MachineLearning/tree/master/Adaboost" target="_blank" rel="external">链接</a></p>
<h2 id="本章内容"><strong>本章内容</strong></h2><ul>
<li>组合算法</li>
<li>AdaBoost算法的使用</li>
<li>非均衡数据集分类</li>
</ul>
<a id="more"></a>
<h2 id="主题："><strong>主题：</strong></h2><p>本文主要介绍的是Adaboost算法，<strong>利用AdaBoost元算法来提高分类器的性能</strong>，主要参考《机器学习实战》来学习Adaboost，同时结合Wikipedia以及网上各位童鞋的资料分享等等。希望通过总结达到学习效果。</p>
<h2 id="1-基于数据集多重抽样的分类器">1.基于数据集多重抽样的分类器</h2><p>先来看看Adaboost的优缺点。</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>AdaBoost</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>泛化错误率低，易编码，可以应用在大部分分类器上，无需参数调整</td>
</tr>
<tr>
<td>缺点</td>
<td>对离群点敏感</td>
</tr>
<tr>
<td>数据</td>
<td>数值型和标称型数据</td>
</tr>
</tbody>
</table>
<p>再来看看bagging和boosting的不同：</p>
<ul>
<li>bagging: 基于数据随机重抽样的分类器构建方法</li>
</ul>
<p>自举汇聚法(bootstrap aggregating),也叫做bagging方法，是从原始数据集选择S次（有放回的抽取）后得到S个新数据集的一种技术。新数据集和原始数据集的大小相等（<font color="#007FFF"><strong>维数和列数都相等</strong></font>）。每个数据集都是通过在原始数据集中随机选择一个来进行替换而得到的。</p>
<p>在S个数据集建好之后，将某个机器学习算法分别作用域每个数据集就可以得到S个分类器。当我们对新数据进行分类时，就可以应用S个分类器进行分类。与此同时，选择分类器<font color="#007fff"><strong>投票结果最多的类别作为最后的分类结果</strong></font>。</p>
<p>目前，有一种改进的bagging方法，如<strong>随机森林</strong>（RF,随机森林不同的是，它对列也进行采样），它在一定程度上可以防止过拟合，也是对决策树的一种改进。</p>
<p>boosting是一种与bagging很类似的技术。不论是boosting还是bagging当中，当使用的多个分类器的类型都是一致的。但是在前者当中，不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练出的分类器的性能来进行训练。boosting是通过训练集中关注被已有分类器错分的那些数据来获得新的分类器。</p>
<p>boosting方法有多个版本，当前最流行便属于<font color="#007fff"><strong>AdaBoost</strong></font>。</p>
<p><strong>AdaBoost的一般流程</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">收集数据：可以使用任何方法；  </span><br><span class="line">准备数据：依赖于所使用的若分类器类型；  </span><br><span class="line">分析数据：可以使用任意方法  </span><br><span class="line">训练算法：AdaBoost的大部分时间都用在训练上，分类器将多次在同一数据集上训练若分类器；  </span><br><span class="line">测试算法：计算分类的错误率；  </span><br><span class="line">使用算法：同SVM一样，AdaBoost预测的两个类别中的一个，如果是多类，与其SVM一样。</span><br></pre></td></tr></table></figure>
<h2 id="2-训练算法：基于错误提升分类器的性能">2.训练算法：基于错误提升分类器的性能</h2><p>AdaBoost是adaptive boosting（自适应boosting）的缩写，其运行过程：训练集中的每个样本，赋予其一个权重，这些权重构成向量D。一开始，这些权重都初试化成相等值。首先在训练数据上训练处一个若分类器并计算该分类器的错误率，然后在同一数据集上再次训练若分类器。在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分队的样本的权重值将会降低，而第一次分错的样本的权重将会提高。为了从所有分类器中得到最终的分类结果，AdaBoost为每个分类器都分配了一个权重值alpha，这些alpha值是基于每个分类器的错误率进行计算的。其中错误率定义为</p>
<p>$$\epsilon=\dfrac{为正确分类的样本数目}{所有样本数目}$$</p>
<p>alpha计算公式</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24%5Calpha%3D%5Cdfrac%7B1%7D%7B2%7Dln%28%5Cdfrac%7B1-%5Cepsilon%7D%7B%5Cepsilon%7D%29%24%24" alt="$$\alpha=\dfrac{1}{2}ln(\dfrac{1-\epsilon}{\epsilon})$$"></p>
<p>从上式可以看出，$\alpha$和$\epsilon$是成反比的（你可以求导试试），所以当$\epsilon$越大，$\alpha$就越小，也就是说建立的这个模型应该赋予更少的权值。计算出alpha值之后，可以对权重向量D进行更新，使得正确分类的样本的权重值降低而分错的样本权重值升高，D的计算方法如下<br>如果某个样本被正确分类，更新该样本权重值为：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24D%5E%7B%28t&plus;1%29%7D_i%3D%5Cdfrac%7BD_i%5E%7B%28t%29%7D%20e%5E%7B-%5Calpha%7D%7D%7BSum%28D%29%7D%24%24" alt="$$D^{(t+1)}_i=\dfrac{D_i^{(t)} e^{-\alpha}}{Sum(D)}$$"></p>
<p>如果某个样本被错误分类，更新该样本的权重值为：</p>
<p><img src="http://latex.codecogs.com/gif.latex?%24%24D%5E%7B%28t&plus;1%29%7D_i%3D%5Cdfrac%7BD_i%5E%7B%28t%29%7D%20e%5E%7B%5Calpha%7D%7D%7BSum%28D%29%7D%24%24" alt="$$D^{(t+1)}_i=\dfrac{D_i^{(t)} e^{\alpha}}{Sum(D)}$$"></p>
<p>计算出D后，AdaBoost接着开始下一轮的迭代。AdaBoost算法会不断地重复训练和调整权重的过程，知道训练错误率为0或者若分类器的数目达到用户指定值为止。</p>
<p>因此，Adaboost算法是一种加和模型，最终的到的分类器可以表示成这样：</p>
<p><img src="https://upload.wikimedia.org/math/5/4/a/54a5bff707b9188fd81d1a725d63643a.png" alt=""></p>
<p>在建立完整的AdaBoost算法之前，需要通过一些代码建立若分类器及保存数据集的权重。</p>
<h2 id="3-基于单层决策树构建若分类器">3.基于单层决策树构建若分类器</h2><p>单层决策树是一种简单的决策树。首先构建一个简单的数据集,建立一个adaboost.py文件并加入下列代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadSimpData</span><span class="params">()</span>:</span></span><br><span class="line">    datMat = matrix([[ <span class="number">1.</span> ,  <span class="number">2.1</span>],</span><br><span class="line">        [ <span class="number">2.</span> ,  <span class="number">1.1</span>],</span><br><span class="line">        [ <span class="number">1.3</span>,  <span class="number">1.</span> ],</span><br><span class="line">        [ <span class="number">1.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">        [ <span class="number">2.</span> ,  <span class="number">1.</span> ]])</span><br><span class="line">    classLabels = [<span class="number">1.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>]</span><br><span class="line">    <span class="keyword">return</span> datMat,classLabels</span><br></pre></td></tr></table></figure>
<p>导入数据</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import adaboost</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; datMat,classLabels=adaboost.loadSimpData()</span><br></pre></td></tr></table></figure>
<p>下面两个函数，一个用于测试是否某个值小于或者大于我们正在测试的阈值，一个会在一个加权数据集中循环，并找到具有最低错误率的单层决策树。</p>
<p>伪代码如下：<br></p>
<pre><code>将最小错误率<span class="keyword">min</span>Error设为无穷大
对数据及中的每一个特征（第一层循环）：
    对每个步长（第二层循环）：
        对每个不等号（第三层循环）：
            建立一颗单层决策树并利用加权数据集对它进行测试
            如果错误率低于<span class="keyword">min</span>Error，则将当前单层决策树设置为最佳单层决策树
返回最佳单层决策树
</code></pre><p>单层决策树生成函数代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stumpClassify</span><span class="params">(dataMatrix,dimen,threshVal,threshIneq)</span>:</span><span class="comment">#just classify the data</span></span><br><span class="line">    retArray = ones((shape(dataMatrix)[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">if</span> threshIneq == <span class="string">'lt'</span>:</span><br><span class="line">        retArray[dataMatrix[:,dimen] &lt;= threshVal] = -<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        retArray[dataMatrix[:,dimen] &gt; threshVal] = -<span class="number">1.0</span></span><br><span class="line">    <span class="keyword">return</span> retArray</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildStump</span><span class="params">(dataArr,classLabels,D)</span>:</span></span><br><span class="line">    dataMatrix = mat(dataArr); labelMat = mat(classLabels).T</span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    numSteps = <span class="number">10.0</span>; bestStump = &#123;&#125;; bestClasEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    minError = inf <span class="comment">#init error sum, to +infinity</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):<span class="comment">#loop over all dimensions</span></span><br><span class="line">        rangeMin = dataMatrix[:,i].min(); rangeMax = dataMatrix[:,i].max();</span><br><span class="line">        stepSize = (rangeMax-rangeMin)/numSteps</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(-<span class="number">1</span>,int(numSteps)+<span class="number">1</span>):<span class="comment">#loop over all range in current dimension</span></span><br><span class="line">            <span class="keyword">for</span> inequal <span class="keyword">in</span> [<span class="string">'lt'</span>, <span class="string">'gt'</span>]: <span class="comment">#go over less than and greater than</span></span><br><span class="line">                threshVal = (rangeMin + float(j) * stepSize)</span><br><span class="line">                predictedVals = stumpClassify(dataMatrix,i,threshVal,inequal)<span class="comment">#call stump classify with i, j, lessThan</span></span><br><span class="line">                errArr = mat(ones((m,<span class="number">1</span>)))</span><br><span class="line">                errArr[predictedVals == labelMat] = <span class="number">0</span></span><br><span class="line">                weightedError = D.T*errArr  <span class="comment">#calc total error multiplied by D</span></span><br><span class="line">                <span class="comment">#print "split: dim %d, thresh %.2f, thresh ineqal: %s, the weighted error is %.3f" % (i, threshVal, inequal, weightedError)</span></span><br><span class="line">                <span class="keyword">if</span> weightedError &lt; minError:</span><br><span class="line">                    minError = weightedError</span><br><span class="line">                    bestClasEst = predictedVals.copy()</span><br><span class="line">                    bestStump[<span class="string">'dim'</span>] = i</span><br><span class="line">                    bestStump[<span class="string">'thresh'</span>] = threshVal</span><br><span class="line">                    bestStump[<span class="string">'ineq'</span>] = inequal</span><br><span class="line">    <span class="keyword">return</span> bestStump,minError,bestClasEst</span><br></pre></td></tr></table></figure>
<h2 id="4-AdaBoost算法的实现">4.AdaBoost算法的实现</h2><p>整个实现的伪代码如下：</p>
<pre><code>对每次迭代：
    利用<span class="function"><span class="title">buildStump</span><span class="params">()</span></span>函数找到最佳的单层决策树
    将最佳单层决策树加入到单层决策树数据中
    计算alpha
    计算心的权重向量D
    更新累计类别估计值
    如果错误率低于<span class="number">0.0</span> 则退出循环
</code></pre><p>基于单层决策树的AdaBoost训练过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaBoostTrainDS</span><span class="params">(dataArr,classLabels,numIt=<span class="number">40</span>)</span>:</span></span><br><span class="line">    weakClassArr = []</span><br><span class="line">    m = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">    D = mat(ones((m,<span class="number">1</span>))/m)   <span class="comment">#init D to all equal</span></span><br><span class="line">    aggClassEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numIt):</span><br><span class="line">        bestStump,error,classEst = buildStump(dataArr,classLabels,D)<span class="comment">#build Stump</span></span><br><span class="line">        <span class="comment">#print "D:",D.T</span></span><br><span class="line">        alpha = float(<span class="number">0.5</span>*log((<span class="number">1.0</span>-error)/max(error,<span class="number">1e-16</span>)))<span class="comment">#calc alpha, throw in max(error,eps) to account for error=0</span></span><br><span class="line">        bestStump[<span class="string">'alpha'</span>] = alpha  </span><br><span class="line">        weakClassArr.append(bestStump)                  <span class="comment">#store Stump Params in Array</span></span><br><span class="line">        <span class="comment">#print "classEst: ",classEst.T</span></span><br><span class="line">        expon = multiply(-<span class="number">1</span>*alpha*mat(classLabels).T,classEst) <span class="comment">#exponent for D calc, getting messy</span></span><br><span class="line">        D = multiply(D,exp(expon))                              <span class="comment">#Calc New D for next iteration</span></span><br><span class="line">        D = D/D.sum()</span><br><span class="line">        <span class="comment">#calc training error of all classifiers, if this is 0 quit for loop early (use break)</span></span><br><span class="line">        aggClassEst += alpha*classEst</span><br><span class="line">        <span class="comment">#print "aggClassEst: ",aggClassEst.T</span></span><br><span class="line">        aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T,ones((m,<span class="number">1</span>)))</span><br><span class="line">        errorRate = aggErrors.sum()/m</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"total error: "</span>,errorRate</span><br><span class="line">        <span class="keyword">if</span> errorRate == <span class="number">0.0</span>: <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> weakClassArr,aggClassEst</span><br></pre></td></tr></table></figure>
<h2 id="5-测试算法">5.测试算法</h2><p>拥有了多个若分类器以及其对应的alpha值，进行测试就方便了。</p>
<p>AdaBoost分类函数:利用训练处的多个若分类器进行分类的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaClassify</span><span class="params">(datToClass,classifierArr)</span>:</span></span><br><span class="line">    dataMatrix = mat(datToClass)<span class="comment">#do stuff similar to last aggClassEst in adaBoostTrainDS</span></span><br><span class="line">    m = shape(dataMatrix)[<span class="number">0</span>]</span><br><span class="line">    aggClassEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(classifierArr)):</span><br><span class="line">        classEst = stumpClassify(dataMatrix,classifierArr[i][<span class="string">'dim'</span>],\</span><br><span class="line">                                 classifierArr[i][<span class="string">'thresh'</span>],\</span><br><span class="line">                                 classifierArr[i][<span class="string">'ineq'</span>])<span class="comment">#call stump classify</span></span><br><span class="line">        aggClassEst += classifierArr[i][<span class="string">'alpha'</span>]*classEst</span><br><span class="line">        <span class="keyword">print</span> aggClassEst</span><br><span class="line">    <span class="keyword">return</span> sign(aggClassEst)</span><br></pre></td></tr></table></figure>
<p>OK，文章简单粗略的讲解了下Adaboost，主要从实现中讲解，如果要知道原理，请看文献二，Wikipedia中讲解的比较清楚，由于能力有限，以后再回头补充吧。</p>
<h2 id="References">References</h2><p>[1] Machine Learning in Action 机器学习实战 第七章<br>[2] <a href="https://en.wikipedia.org/wiki/AdaBoost" target="_blank" rel="external">AdaBoost</a></p>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Github源码实现:<a href="https://github.com/csuldw/MachineLearning/tree/master/Adaboost">链接</a></p>
<h2 id="本章内容"><strong>本章内容</strong></h2><ul>
<li>组合算法</li>
<li>AdaBoost算法的使用</li>
<li>非均衡数据集分类</li>
</ul>]]>
    
    </summary>
    
      <category term="Adaboost" scheme="http://csuldw.github.io/tags/Adaboost/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="组合算法" scheme="http://csuldw.github.io/tags/%E7%BB%84%E5%90%88%E7%AE%97%E6%B3%95/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python模拟ls命令]]></title>
    <link href="http://csuldw.github.io/2015/06/10/2015-06-10%20Python-simulate-command/"/>
    <id>http://csuldw.github.io/2015/06/10/2015-06-10 Python-simulate-command/</id>
    <published>2015-06-10T12:03:00.000Z</published>
    <updated>2016-03-13T06:41:14.831Z</updated>
    <content type="html"><![CDATA[<p>模拟控制台命令</p>
<p>写一个程序 lsrm 要求如下:</p>
<pre><code>模拟linux的命令<span class="keyword">ls</span>部分功能
当使用命令
lsrm -<span class="keyword">ll</span>
显示目录下所有 <span class="keyword">py</span> 结尾的文件
增加难度 (<span class="number">1</span>.使用递归 显示所有目录里的 <span class="keyword">py</span> 结尾文件)
</code></pre><a id="more"></a>
<hr>
<p>首先定义一个outputFile函数，参数只设置一个infile，表示的是文件名或者目录名，然后进行判断，如果是文件，而且以py结尾，则输出；否则，如果是目录，则循环遍历每个每个文件。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span><br><span class="line">Created on Wed Oct 28 19:25:20 2015</span><br><span class="line"></span><br><span class="line">@author: liudiwei</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outputFile</span><span class="params">(infile)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(infile):</span><br><span class="line">        filelist = getFileList(infile)</span><br><span class="line">        <span class="keyword">for</span> eachfile <span class="keyword">in</span> filelist:</span><br><span class="line">            os.chdir(infile)</span><br><span class="line">            outputFile(eachfile)</span><br><span class="line">            os.chdir(<span class="string">".."</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">".py"</span> <span class="keyword">in</span> infile:</span><br><span class="line">            <span class="keyword">print</span> infile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    filepath = <span class="string">r"F:\CSU\Academic\analysis\experiment\code"</span>; </span><br><span class="line">    filelist = getFileList(filepath)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        command = raw_input(<span class="string">'# '</span> )</span><br><span class="line">        <span class="keyword">if</span> command == <span class="string">'lsrm -ll'</span>:    </span><br><span class="line">            outputFile(filepath)</span><br><span class="line">        <span class="keyword">elif</span> command == <span class="string">"stop"</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<center><br><img src="/assets/images/20151029094653.png" alt="output"><br></center>


<p>注意：在寻找子目录的文件时，需将工作目切换到子目录，档子目录遍历完毕后，再前换到上一层目录os.chdir(“..”).</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>模拟控制台命令</p>
<p>写一个程序 lsrm 要求如下:</p>
<pre><code>模拟linux的命令<span class="keyword">ls</span>部分功能
当使用命令
lsrm -<span class="keyword">ll</span>
显示目录下所有 <span class="keyword">py</span> 结尾的文件
增加难度 (<span class="number">1</span>.使用递归 显示所有目录里的 <span class="keyword">py</span> 结尾文件)
</code></pre>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法-Apriori关联分析]]></title>
    <link href="http://csuldw.github.io/2015/06/04/2015-06-04-Apriori/"/>
    <id>http://csuldw.github.io/2015/06/04/2015-06-04-Apriori/</id>
    <published>2015-06-04T13:53:12.000Z</published>
    <updated>2016-03-13T05:59:48.624Z</updated>
    <content type="html"><![CDATA[<p><strong>引文：</strong> 学习一个算法，我们最关心的并不是算法本身，而是一个算法能够干什么，能应用到什么地方。很多的时候，我们都需要从大量数据中提取出有用的信息，从大规模数据中寻找物品间的隐含关系叫做关联分析(association analysis)或者关联规则学习(association rule learning)。比如在平时的购物中，那些商品一起捆绑购买销量会比较好，又比如购物商城中的那些推荐信息，都是根据用户平时的搜索或者是购买情况来生成的。如果是蛮力搜索的话代价太高了，所以Apriori就出现了，就是为了解决这类问题的。</p>
<a id="more"></a>
<p><strong>内容纲要</strong></p>
<ul>
<li>关联分析</li>
<li>Apriori算法理论</li>
<li><p>Apriori实现</p>
<ul>
<li>频繁项集生成</li>
<li>关联规则生成</li>
</ul>
</li>
<li><p>reference</p>
</li>
</ul>
<p><strong>Apriori算法</strong></p>
<ul>
<li>优点：易编码实现</li>
<li>缺点：在大数据集上可能较慢</li>
<li>适合数据类型：数值型或者标称型数据</li>
</ul>
<h3 id="1_关联分析"><strong>1 关联分析</strong></h3><p>说到关联分析，顾名思义的就可以联想到，所谓关联就是两个东西之间存在的某种联系。关联分析最有名的例子是“尿布和啤酒”，以前在美国西部的一家连锁店，店家发现男人们在周四购买尿布后还会购买啤酒。于是他便得出一个推理，尿布和啤酒存在某种关联。但是具体怎么来评判呢？</p>
<p>那么，这里用的是<strong>支持度</strong>和<strong>可信度</strong>来评判!</p>
<p>一个项集的支持度（support）被定义为数据集中包含该数据集的记录所占的比例。可信度或置信度（confidence）是正对一条关联规则来定义的，比如{尿布}-&gt;{啤酒}，这条规则的可信度定义为“支持度{尿布，啤酒}/支持度{尿布}”</p>
<p>比如有规则X=&gt;Y，它的<strong>支持度</strong>可以计算为包含XUY所有商品的交易量相对所有交易量的比例（也就是X和Y同时出现一次交易的概率）。<strong>可信度</strong>定义为包含XUY所有物品的交易量相对仅包含X的交易量的比值，也就是说可信度对应给定X时的条件概率。关联规则挖掘，其目的是自动发起这样的规则，同时计算这些规则的质量。</p>
<p>计算公式如下：</p>
<p>$$支持度=\frac{交易量包含XUY}{交易量}$$</p>
<p>$$可信度=\frac{交易量包含XUY}{交易量包含X}$$</p>
<p>支持度和可信度是用来量化关联分析是否成功的方法。关联分析的目的包括两个：发现频繁项集和发现关联规则。首先我们要找到频繁项集，然后根据频繁项集找出关联规则。下面使用apriori算法来发现频繁项集。</p>
<h3 id="2_Apriori理论"><strong>2 Apriori理论</strong></h3><p><strong>算法的一般过程：</strong></p>
<ul>
<li>收集数据：使用任何方法</li>
<li>准备数据：任意数据类型都可以，因为我们只保存集合</li>
<li>分析数据：使用任何方法</li>
<li>训练算法：使用Apriori算法来找到频繁项集</li>
<li>测试算法：不需要测试过程</li>
<li>使用算法：用于发现频繁项集以及物品之间的关联规则</li>
</ul>
<p><strong>使用Apriori算法，首先计算出单个元素的支持度，然后选出单个元素置信度大于我们要求的数值，比如0.5或是0.7等。然后增加单个元素组合的个数，只要组合项的支持度大于我们要求的数值就把它加到我们的频繁项集中，依次递归。</strong></p>
<p>然后根据计算的支持度选出来的频繁项集来生成关联规则。</p>
<h3 id="3_Apriori实现"><strong>3 Apriori实现</strong></h3><p>首先定义一些算法的辅助函数<br>加载数据集的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    list = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">5</span>]]</span><br><span class="line">    <span class="keyword">return</span> list</span><br></pre></td></tr></table></figure>
<p>根据数据集构建集合C1，该集合是大小为1的所有候选集的集合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createC1</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    C1 = [] <span class="comment">#C1是大小为1的所有候选项集的集合</span></span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> dataSet:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> transaction:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> [item] <span class="keyword">in</span> C1:</span><br><span class="line">                C1.append([item])             </span><br><span class="line">    C1.sort()</span><br><span class="line">    <span class="keyword">return</span> map(frozenset, C1)<span class="comment">#use frozen set so we can use it as a key in a dict</span></span><br></pre></td></tr></table></figure>
<p>根据构建出来的频繁项集，选出满足我们需要的大于我们给定的支持度的项集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#D表示数据集，CK表示候选项集，minSupport表示最小的支持度，自己设定</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scanD</span><span class="params">(D, Ck, minSupport)</span>:</span></span><br><span class="line">    ssCnt = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tid <span class="keyword">in</span> D:</span><br><span class="line">        <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">            <span class="keyword">if</span> can.issubset(tid):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ssCnt.has_key(can): ssCnt[can]=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: ssCnt[can] += <span class="number">1</span></span><br><span class="line">    numItems = float(len(D))</span><br><span class="line">    retList = [] <span class="comment">#存储满足最小支持度要求的项集</span></span><br><span class="line">    supportData = &#123;&#125; <span class="comment">#每个项集的支持度字典</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> ssCnt:  <span class="comment">#计算所有项集的支持度</span></span><br><span class="line">        support = ssCnt[key]/numItems</span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            retList.insert(<span class="number">0</span>,key)</span><br><span class="line">        supportData[key] = support</span><br><span class="line">    <span class="keyword">return</span> retList, supportData</span><br></pre></td></tr></table></figure>
<h4 id="3-1_频繁项集"><strong>3.1 频繁项集</strong></h4><p>关于频繁项集的产生，我们单独的抽取出来<br>首先需要一个生成合并项集的函数，将两个子集合并的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#LK是频繁项集列表，K表示接下来合并的项集中的单个想的个数&#123;1,2,3&#125;表示k=3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprioriGen</span><span class="params">(Lk, k)</span>:</span> <span class="comment">#creates Ck</span></span><br><span class="line">    retList = []</span><br><span class="line">    lenLk = len(Lk)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenLk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, lenLk): </span><br><span class="line">            L1 = list(Lk[i])[:k-<span class="number">2</span>]; L2 = list(Lk[j])[:k-<span class="number">2</span>] <span class="comment">#前k-2个项相同时，将两个集合合并</span></span><br><span class="line">            L1.sort(); L2.sort()</span><br><span class="line">            <span class="keyword">if</span> L1==L2: <span class="comment">#if first k-2 elements are equal</span></span><br><span class="line">                retList.append(Lk[i] | Lk[j]) <span class="comment">#set union</span></span><br><span class="line">    <span class="keyword">return</span> retList</span><br></pre></td></tr></table></figure>
<p>接着定义生成频繁项集的函数</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#只需要输入数据集和支持度即可</span><br><span class="line">def <span class="function"><span class="title">apriori</span><span class="params">(dataSet, minSupport = <span class="number">0.5</span>)</span></span>:</span><br><span class="line">    C1 = <span class="function"><span class="title">createC1</span><span class="params">(dataSet)</span></span></span><br><span class="line">    D = <span class="function"><span class="title">map</span><span class="params">(set, dataSet)</span></span></span><br><span class="line">    L1, supportData = <span class="function"><span class="title">scanD</span><span class="params">(D, C1, minSupport)</span></span></span><br><span class="line">    L = [L1]</span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    while (<span class="function"><span class="title">len</span><span class="params">(L[k-<span class="number">2</span>])</span></span> &gt; <span class="number">0</span>):</span><br><span class="line">        Ck = <span class="function"><span class="title">aprioriGen</span><span class="params">(L[k-<span class="number">2</span>], k)</span></span></span><br><span class="line">        Lk, supK = <span class="function"><span class="title">scanD</span><span class="params">(D, Ck, minSupport)</span></span><span class="id">#scan</span> DB to get Lk</span><br><span class="line">        supportData.<span class="function"><span class="title">update</span><span class="params">(supK)</span></span></span><br><span class="line">        L.<span class="function"><span class="title">append</span><span class="params">(Lk)</span></span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    return L, supportData#返回频繁项集和每个项集的支持度值</span><br></pre></td></tr></table></figure>
<h4 id="3-2_关联规则生成"><strong>3.2 关联规则生成</strong></h4><p>通过频繁项集，我们可以得到相应的规则，但是具体规则怎么得出来的呢？下面给出一个规则生成函数，具体原理参考注释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入的参数分别为：频繁项集、支持度数据字典、自定义的最小支持度，返回的是可信度规则列表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateRules</span><span class="params">(L, supportData, minConf=<span class="number">0.7</span>)</span>:</span>  <span class="comment">#支持度是通过scanD得到的字典</span></span><br><span class="line">    bigRuleList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L)):<span class="comment">#只去频繁项集中元素个数大于2的子集，如&#123;1,2&#125;&#123;1,2,3&#125;，不取&#123;2&#125;&#123;3&#125;,etc...</span></span><br><span class="line">        <span class="keyword">for</span> freqSet <span class="keyword">in</span> L[i]:</span><br><span class="line">            H1 = [frozenset([item]) <span class="keyword">for</span> item <span class="keyword">in</span> freqSet]</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>):</span><br><span class="line">                rulesFromConseq(freqSet, H1, supportData, bigRuleList, minConf)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                calcConf(freqSet, H1, supportData, bigRuleList, minConf)</span><br><span class="line">    <span class="keyword">return</span> bigRuleList</span><br></pre></td></tr></table></figure>
<p>下面定义一个用来计算置信度的函数，通过该函数抽取出符合我们要求的规则，如freqSet为{1,2}，H为{1}，{2}，可以计算出{1}—&gt;{2}和{2}—&gt;{1}的质心度，即下面的conf变量，然后用if语句判断是否符合我们的要求。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#计算可信度，找到满足最小可信度的要求规则</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcConf</span><span class="params">(freqSet, H, supportData, brl, minConf=<span class="number">0.7</span>)</span>:</span></span><br><span class="line">    prunedH = [] <span class="comment">#create new list to return</span></span><br><span class="line">    <span class="keyword">for</span> conseq <span class="keyword">in</span> H:</span><br><span class="line">        conf = supportData[freqSet]/supportData[freqSet-conseq] <span class="comment">#calc confidence</span></span><br><span class="line">        <span class="keyword">if</span> conf &gt;= minConf: </span><br><span class="line">            <span class="keyword">print</span> freqSet-conseq,<span class="string">'--&gt;'</span>,conseq,<span class="string">'conf:'</span>,conf</span><br><span class="line">            brl.append((freqSet-conseq, conseq, conf))</span><br><span class="line">            prunedH.append(conseq)</span><br><span class="line">    <span class="keyword">return</span> prunedH</span><br></pre></td></tr></table></figure>
<p>下面的函数是用来合并子集的，比如我现在的频繁项集是{2,3,5},它的构造元素是{2},{3},{5}，所以需要将{2},{3},{5}两两合并然后再根据上面的calcConf函数计算置信度。代码如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#从最初的项集中生成更多的规则</span><br><span class="line">def <span class="function"><span class="title">rulesFromConseq</span><span class="params">(freqSet, H, supportData, brl, minConf=<span class="number">0.7</span>)</span></span>:</span><br><span class="line">    m = <span class="function"><span class="title">len</span><span class="params">(H[<span class="number">0</span>])</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="function"><span class="title">len</span><span class="params">(freqSet)</span></span> &gt; (m + <span class="number">1</span>)): #进一步合并项集</span><br><span class="line">        Hmp1 = <span class="function"><span class="title">aprioriGen</span><span class="params">(H, m+<span class="number">1</span>)</span></span><span class="id">#create</span> Hm+<span class="number">1</span> new candidates</span><br><span class="line">        Hmp1 = <span class="function"><span class="title">calcConf</span><span class="params">(freqSet, Hmp1, supportData, brl, minConf)</span></span></span><br><span class="line">        <span class="keyword">if</span> (<span class="function"><span class="title">len</span><span class="params">(Hmp1)</span></span> &gt; <span class="number">1</span>):    <span class="id">#need</span> at least two sets to merge</span><br><span class="line">            <span class="function"><span class="title">rulesFromConseq</span><span class="params">(freqSet, Hmp1, supportData, brl, minConf)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-3_测试"><strong>3.3 测试</strong></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataSet = <span class="function"><span class="title">loadDataSet</span><span class="params">()</span></span>			 	#加载数据集</span><br><span class="line">L,suppoData = <span class="function"><span class="title">apriori</span><span class="params">(dataSet)</span></span>		#计算频繁项集</span><br><span class="line">rules = <span class="function"><span class="title">generateRules</span><span class="params">(L,suppoData,minConf=<span class="number">0.7</span>)</span></span> #抽取规则</span><br></pre></td></tr></table></figure>
<p>得到的结果为：<br><img src="http://img.blog.csdn.net/20150604094036589" alt="这里写图片描述"></p>
<p>L表示的是符合条件的频繁项集，rules表示最后抽取出来的符合条件的规则；还可以查看各个项集的支持度，如下所示。<br><img src="http://img.blog.csdn.net/20150604094213762" alt="这里写图片描述"></p>
<h3 id="Reference"><strong>Reference</strong></h3><p>[1]<strong>《机器学习实战》</strong>书籍第11章</p>
<p><br></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>引文：</strong> 学习一个算法，我们最关心的并不是算法本身，而是一个算法能够干什么，能应用到什么地方。很多的时候，我们都需要从大量数据中提取出有用的信息，从大规模数据中寻找物品间的隐含关系叫做关联分析(association analysis)或者关联规则学习(association rule learning)。比如在平时的购物中，那些商品一起捆绑购买销量会比较好，又比如购物商城中的那些推荐信息，都是根据用户平时的搜索或者是购买情况来生成的。如果是蛮力搜索的话代价太高了，所以Apriori就出现了，就是为了解决这类问题的。</p>]]>
    
    </summary>
    
      <category term="Apriori" scheme="http://csuldw.github.io/tags/Apriori/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="关联分析" scheme="http://csuldw.github.io/tags/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法-K-means聚类]]></title>
    <link href="http://csuldw.github.io/2015/06/03/2015-06-03-ml-algorithm-K-means/"/>
    <id>http://csuldw.github.io/2015/06/03/2015-06-03-ml-algorithm-K-means/</id>
    <published>2015-06-03T04:30:00.000Z</published>
    <updated>2016-03-13T06:00:13.840Z</updated>
    <content type="html"><![CDATA[<p><strong>引文：</strong> k均值算法是一种聚类算法，所谓聚类，他是一种无监督学习，将相似的对象归到同一个蔟中。蔟内的对象越相似，聚类的效果越好。聚类和分类最大的不同在于，分类的目标事先已知，而聚类则不一样。因为其产生的结果和分类相同，而只是类别没有预先定义。</p>
<p>Github源码实现:<a href="https://github.com/csuldw/MachineLearning/tree/master/Kmeans" target="_blank" rel="external">链接</a></p>
<a id="more"></a>
<p><strong>算法的目的：</strong> 使各个样本与所在类均值的<strong>误差平方和达到最小</strong>（这也是评价K-means算法最后聚类效果的评价标准）</p>
<center><strong>K-均值聚类</strong></center>

<ul>
<li>优点：容易实现</li>
<li>缺点：可能收敛到局部最小值，在大规模数据上收敛较慢</li>
<li>适合数据类型：数值型数据</li>
</ul>
<h3 id="伪代码"><strong>伪代码</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建k个点作为起始质心（经常随机选择）</span></span><br><span class="line"><span class="comment">#当任意一个点的蔟分配结果发生变化时</span></span><br><span class="line">	<span class="comment">#对数据集中的每个数据点</span></span><br><span class="line">		<span class="comment">#对每个质心</span></span><br><span class="line">			<span class="comment">#计算质心到数据点之间的距离</span></span><br><span class="line">		<span class="comment">#将数据点分配到距其最近的蔟</span></span><br><span class="line">	<span class="comment">#对每个蔟，计算蔟中所有点的均值并将均值作为质心</span></span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><strong>代码实现</strong></h3><p>因为我们用到的是数值类型的数据，这里编写一个加载数据集的函数，返回值是一个矩阵形式。<br>下面代码应写在一个py文件里，我这里写在kMeans.py文件中。</p>
<p>文件的头部引入numpy<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></p>
<p><strong>数据集加载代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载数据集文件，没有返回类标号的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span></span><br><span class="line">    dataMat = []</span><br><span class="line">    openfile = open(fileName)    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> openfile.readlines():</span><br><span class="line">        curLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">        floatLine = map(float,curLine)</span><br><span class="line">        dataMat.append(floatLine)</span><br><span class="line">    <span class="keyword">return</span> dataMat</span><br></pre></td></tr></table></figure>
<p>因为在k均值算法中要计算点到质心的距离，所以这里将距离计算写成一个函数，计算欧几里得距离公式：</p>
<p>$$d=\sqrt{(x_2-x_1)^2+…+(z_2-z_1)^2}$$</p>
<p><strong>函数代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算两个向量的欧氏距离</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distEclud</span><span class="params">(vecA,vecB)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sqrt(sum(power(vecA-vecB,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>
<p><strong>接下来初始化k个蔟的质心函数centroid</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入的数据时numpy的矩阵格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randCent</span><span class="params">(dataMat, k)</span>:</span></span><br><span class="line">    n = shape(dataMat)[<span class="number">1</span>]</span><br><span class="line">    centroids = mat(zeros((k,n)))  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        minJ = min(dataMat[:,j]) <span class="comment"># 找出矩阵dataMat第j列最小值</span></span><br><span class="line">        rangeJ = float(max(dataMat[:,j]) - minJ) <span class="comment">#计算第j列最大值和最小值的差</span></span><br><span class="line">        <span class="comment">#赋予一个随机质心，它的值在整个数据集的边界之内</span></span><br><span class="line">        centroids[:,j] = minJ + rangeJ * random.rand(k,<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">return</span> centroids <span class="comment">#返回一个随机的质心矩阵</span></span><br></pre></td></tr></table></figure>
<p><strong>K-means算法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#k-均值算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kMeans</span><span class="params">(dataMat,k,distE = distEclud , createCent=randCent)</span>:</span></span><br><span class="line">    m = shape(dataMat)[<span class="number">0</span>]    <span class="comment"># 获得行数m</span></span><br><span class="line">    clusterAssment = mat(zeros((m,<span class="number">2</span>))) <span class="comment"># 初试化一个矩阵，用来记录簇索引和存储误差                               </span></span><br><span class="line">    centroids = createCent(dataMat,k) <span class="comment"># 随机的得到一个质心矩阵蔟</span></span><br><span class="line">    clusterChanged = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">while</span> clusterChanged:</span><br><span class="line">        clusterChanged = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):    <span class="comment">#对每个数据点寻找最近的质心</span></span><br><span class="line">            minDist = inf; minIndex = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(k): <span class="comment"># 遍历质心蔟，寻找最近的质心    </span></span><br><span class="line">                distJ1 = distE(centroids[j,:],dataMat[i,:]) <span class="comment">#计算数据点和质心的欧式距离</span></span><br><span class="line">                <span class="keyword">if</span> distJ1 &lt; minDist: </span><br><span class="line">                    minDist = distJ1; minIndex = j</span><br><span class="line">            <span class="keyword">if</span> clusterAssment[i,<span class="number">0</span>] != minIndex:</span><br><span class="line">                clusterChanged = <span class="keyword">True</span></span><br><span class="line">            clusterAssment[i,:] = minIndex,minDist**<span class="number">2</span></span><br><span class="line">        <span class="keyword">print</span> centroids</span><br><span class="line">        <span class="keyword">for</span> cent <span class="keyword">in</span> range(k):    <span class="comment">#更新质心的位置</span></span><br><span class="line">            ptsInClust = dataMat[nonzero(clusterAssment[:,<span class="number">0</span>].A==cent)[<span class="number">0</span>]]    </span><br><span class="line">            centroids[cent,:] = mean(ptsInClust, axis=<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> centroids, clusterAssment</span><br></pre></td></tr></table></figure>
<p><strong>测试：</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataMat = <span class="function"><span class="title">mat</span><span class="params">(loadDataSet(<span class="string">'testSet.txt'</span>)</span></span>)</span><br><span class="line"><span class="function"><span class="title">kMeans</span><span class="params">(dataMat,<span class="number">4</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>输出结果：</strong></p>
<p>===================</p>
<p>[[-3.66087851  2.30869657]<br> [ 3.24377288  3.04700412]<br> [ 2.52577861 -3.12485493]<br> [-2.79672694  3.19201596]]<br>[[-3.78710372 -1.66790611]<br> [ 2.6265299   3.10868015]<br> [ 1.62908469 -2.92689085]<br> [-2.18799937  3.01824781]]<br>[[-3.53973889 -2.89384326]<br> [ 2.6265299   3.10868015]<br> [ 2.65077367 -2.79019029]<br> [-2.46154315  2.78737555]]</p>
<p>===================</p>
<p>上面的结果给出了四个质心。可以看出，经过3次迭代之后K-均值算法收敛。质心会保存在第一个返回值中，第二个是每个点的簇分布情况。</p>
<p><strong>附件：</strong></p>
<p>上面测试的数据集为：</p>
<pre><code class="markdown">
1.658985    4.285136
-3.453687    3.424321
4.838138    -1.151539
-5.379713    -3.362104
0.972564    2.924086
-3.567919    1.531611
0.450614    -3.302219
-3.487105    -1.724432
2.668759    1.594842
-3.156485    3.191137
3.165506    -3.999838
-2.786837    -3.099354
4.208187    2.984927
-2.123337    2.943366
0.704199    -0.479481
-0.392370    -3.963704
2.831667    1.574018
-0.790153    3.343144
2.943496    -3.357075
-3.195883    -2.283926
2.336445    2.875106
-1.786345    2.554248
2.190101    -1.906020
-3.403367    -2.778288
1.778124    3.880832
-1.688346    2.230267
2.592976    -2.054368
-4.007257    -3.207066
2.257734    3.387564
-2.679011    0.785119
0.939512    -4.023563
-3.674424    -2.261084
2.046259    2.735279
-3.189470    1.780269
4.372646    -0.822248
-2.579316    -3.497576
1.889034    5.190400
-0.798747    2.185588
2.836520    -2.658556
-3.837877    -3.253815
2.096701    3.886007
-2.709034    2.923887
3.367037    -3.184789
-2.121479    -4.232586
2.329546    3.179764
-3.284816    3.273099
3.091414    -3.815232
-3.762093    -2.432191
3.542056    2.778832
-1.736822    4.241041
2.127073    -2.983680
-4.323818    -3.938116
3.792121    5.135768
-4.786473    3.358547
2.624081    -3.260715
-4.009299    -2.978115
2.493525    1.963710
-2.513661    2.642162
1.864375    -3.176309
-3.171184    -3.572452
2.894220    2.489128
-2.562539    2.884438
3.491078    -3.947487
-2.565729    -2.012114
3.332948    3.983102
-1.616805    3.573188
2.280615    -2.559444
-2.651229    -3.103198
2.321395    3.154987
-1.685703    2.939697
3.031012    -3.620252
-4.599622    -2.185829
4.196223    1.126677
-2.133863    3.093686
4.668892    -2.562705
-2.793241    -2.149706
2.884105    3.043438
-2.967647    2.848696
4.479332    -1.764772
-4.905566    -2.911070

</code></pre>

<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>引文：</strong> k均值算法是一种聚类算法，所谓聚类，他是一种无监督学习，将相似的对象归到同一个蔟中。蔟内的对象越相似，聚类的效果越好。聚类和分类最大的不同在于，分类的目标事先已知，而聚类则不一样。因为其产生的结果和分类相同，而只是类别没有预先定义。</p>
<p>Github源码实现:<a href="https://github.com/csuldw/MachineLearning/tree/master/Kmeans">链接</a></p>]]>
    
    </summary>
    
      <category term="K-Means" scheme="http://csuldw.github.io/tags/K-Means/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="聚类" scheme="http://csuldw.github.io/tags/%E8%81%9A%E7%B1%BB/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sklearn训练模型的保存与恢复（Python）]]></title>
    <link href="http://csuldw.github.io/2015/05/31/2015-05-31%20scikit-learn%20training%20model's%20save%20and%20reused/"/>
    <id>http://csuldw.github.io/2015/05/31/2015-05-31 scikit-learn training model's save and reused/</id>
    <published>2015-05-31T12:52:00.000Z</published>
    <updated>2016-03-08T08:48:07.491Z</updated>
    <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>在做模型训练的时候，尤其是在训练集上做交叉验证，通常想要将模型保存下来，然后放到独立的测试集上测试，下面介绍的是Python中训练模型的保存和再使用。</p>
<p>scikit-learn已经有了模型持久化的操作，导入joblib即可</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h3 id="模型保存"><strong>模型保存</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>os.chdir(<span class="string">"workspace/model_save"</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>X = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>y = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>clf = svm.SVC()</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>clf.fit(X, y)  </span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>clf.fit(train_X,train_y)</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>joblib.dump(clf, <span class="string">"train_model.m"</span>)</span><br></pre></td></tr></table></figure>
<p>通过joblib的dump可以将模型保存到本地，clf是训练的分类器</p>
<h3 id="模型从本地调回"><strong>模型从本地调回</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>clf = joblib.load(<span class="string">"train_model.m"</span>)</span><br></pre></td></tr></table></figure>
<p>通过joblib的load方法，加载保存的模型。</p>
<p>然后就可以在测试集上测试了</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clf.<span class="function"><span class="title">predit</span><span class="params">(test_X，test_y)</span></span></span><br></pre></td></tr></table></figure>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="描述">描述</h2><p>在做模型训练的时候，尤其是在训练集上做交叉验证，通常想要将模型保存下来，然后放到独立的测试集上测试，下面介绍的是Python中训练模型的保存和再使用。</p>
<p>scikit-learn已经有了模型持久化的操作，导入joblib即可</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.externals <span class="keyword">import</span> joblib</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="scikit-learn" scheme="http://csuldw.github.io/tags/scikit-learn/"/>
    
      <category term="持久化" scheme="http://csuldw.github.io/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法-朴素贝叶斯Python实现]]></title>
    <link href="http://csuldw.github.io/2015/05/28/2015-05-28-NB/"/>
    <id>http://csuldw.github.io/2015/05/28/2015-05-28-NB/</id>
    <published>2015-05-28T04:59:00.000Z</published>
    <updated>2016-03-08T09:01:43.043Z</updated>
    <content type="html"><![CDATA[<p>源码：<a href="https://github.com/csuldw/MachineLearning/tree/master/NaiveBayes" target="_blank" rel="external">Github-MachineLearning</a></p>
<p><strong>引文：</strong>前面提到的K最近邻算法和决策树算法，数据实例最终被明确的划分到某个分类中，下面介绍一种不能完全确定数据实例应该划分到哪个类别，或者说只能给数据实例属于给定分类的概率。</p>
<a id="more"></a>
<h3 id="基于贝叶斯决策理论的分类方法之朴素贝叶斯"><strong>基于贝叶斯决策理论的分类方法之朴素贝叶斯</strong></h3><ul>
<li>优点：在数据较少的情况下仍然有效，可以处理多类别问题</li>
<li>缺点：对于输入数据的准备方式较为敏感 </li>
<li>适用数据类型：标称型数据。</li>
</ul>
<h3 id="朴素贝叶斯的一般过程"><strong>朴素贝叶斯的一般过程</strong></h3><ul>
<li>收集数据：可以使用任何方式</li>
<li>准备数据：需要数据型或是布尔型数据</li>
<li>分类数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好</li>
<li>训练算法：计算不同的独立特征的条件概率</li>
<li>测试算法：计算错误率</li>
<li>使用算法：文档分类</li>
</ul>
<h3 id="原理"><strong>原理</strong></h3><p>主要是运用<strong>贝叶斯定理</strong></p>
<p>$$ P(H|X) = \dfrac{P(X|H) p(H)}{P(X)} $$</p>
<h3 id="算法实现"><strong>算法实现</strong></h3><p>下面做一个简单的留言板分类，自动判别留言类别：侮辱类和非侮辱类，分别使用1和0表示。下面来做一下这个实验。以下函数全部写在一个叫bayes.py文件中，后面的实验室通过导入bayes.py，调用里面的函数来做的。</p>
<p>导入numpy包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<h4 id="1-加载数据集"><strong>1.加载数据集</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">    postingList=[[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span>],</span><br><span class="line">                 [<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>, <span class="string">'to'</span>, <span class="string">'dog'</span>, <span class="string">'park'</span>, <span class="string">'stupid'</span>],</span><br><span class="line">                 [<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</span><br><span class="line">                 [<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">                 [<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</span><br><span class="line">                 [<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</span><br><span class="line">    classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]    <span class="comment">#1 is abusive, 0 not</span></span><br><span class="line">    <span class="keyword">return</span> postingList,classVec</span><br></pre></td></tr></table></figure>
<p>该函数返回的是<strong>词条切分集合</strong>和<strong>类标签</strong>。</p>
<h4 id="2-根据样本创建一个词库"><strong>2.根据样本创建一个词库</strong></h4><p>下面的函数是根据上面给出来的样本数据所创建出来的一个词库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">    vocabSet = set([])  <span class="comment">#create empty set</span></span><br><span class="line">    <span class="keyword">for</span> document <span class="keyword">in</span> dataSet:</span><br><span class="line">        vocabSet = vocabSet | set(document) <span class="comment">#union of the two sets</span></span><br><span class="line">    <span class="keyword">return</span> list(vocabSet)</span><br></pre></td></tr></table></figure>
<h4 id="3-统计每个样本在词库中的出现情况"><strong>3.统计每个样本在词库中的出现情况</strong></h4><p>下面的函数功能是把单个样本映射到词库中去，统计单个样本在词库中的出现情况，1表示出现过，0表示没有出现，函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">print</span> <span class="string">"the word: %s is not in my Vocabulary!"</span> % word</span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>
<h4 id="4-计算条件概率和类标签概率"><strong>4.计算条件概率和类标签概率</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix,trainCategory)</span>:</span></span><br><span class="line">    numTrainDocs = len(trainMatrix)</span><br><span class="line">    numWords = len(trainMatrix[<span class="number">0</span>])</span><br><span class="line">    pAbusive = sum(trainCategory)/float(numTrainDocs) <span class="comment">#计算某个类发生的概率</span></span><br><span class="line">    p0Num = ones(numWords); p1Num = ones(numWords) <span class="comment">#初始样本个数为1，防止条件概率为0，影响结果       </span></span><br><span class="line">    p0Denom = <span class="number">2.0</span>; p1Denom = <span class="number">2.0</span>  <span class="comment">#作用同上                      </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">        <span class="keyword">if</span> trainCategory[i] == <span class="number">1</span>:</span><br><span class="line">            p1Num += trainMatrix[i]</span><br><span class="line">            p1Denom += sum(trainMatrix[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p0Num += trainMatrix[i]</span><br><span class="line">            p0Denom += sum(trainMatrix[i])</span><br><span class="line">    p1Vect = log(p1Num/p1Denom)         <span class="comment">#计算类标签为1时的其它属性发生的条件概率</span></span><br><span class="line">    p0Vect = log(p0Num/p0Denom)         <span class="comment">#计算标签为0时的其它属性发生的条件概率</span></span><br><span class="line">    <span class="keyword">return</span> p0Vect,p1Vect,pAbusive       <span class="comment">#返回条件概率和类标签为1的概率</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<h4 id="5-训练贝叶斯分类算法"><strong>5.训练贝叶斯分类算法</strong></h4><p>该算法包含四个输入，vec2Classify表示待分类的样本在词库中的映射集合，p0Vec表示条件概率$P(w_i|c=0)$，p1Vec表示条件概率$P(w_i|c=1)$，pClass1表示类标签为1时的概率$P(c=1)$。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">classifyNB</span><span class="params">(vec2Classify, p0Vec, p1Vec, pClass1)</span></span>:</span><br><span class="line">    p1 = <span class="function"><span class="title">sum</span><span class="params">(vec2Classify * p1Vec)</span></span> + <span class="function"><span class="title">log</span><span class="params">(pClass1)</span></span>    <span class="id">#element-wise</span> mult</span><br><span class="line">    p0 = <span class="function"><span class="title">sum</span><span class="params">(vec2Classify * p0Vec)</span></span> + <span class="function"><span class="title">log</span><span class="params">(<span class="number">1.0</span> - pClass1)</span></span></span><br><span class="line">    <span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">        return <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        return <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>其中p1和p0表示的是</p>
<p>$$lnp(w_1|c=1)p(w_2|c=1)…p(w_n|c=1)*p(c=1)$$</p>
<p>和</p>
<p>$$lnp(w_1|c=0)p(w_2|c=0)…p(w_n|c=0)*p(c=0)$$</p>
<p>取对数是因为防止p(w_1|c=1)p(w_2|c=1)p(w_3|c=1)…p(w_n|c=1)多个小于1的数相乘结果值下溢。</p>
<h4 id="6-文档词袋模型,修改函数setOfWords2Vec"><strong>6.文档词袋模型,修改函数setOfWords2Vec</strong></h4><p>词袋模型主要修改上面的第三个步骤，因为有的词可能出现多次，所以在单个样本映射到词库的时候需要多次统计。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">    returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">            returnVec[vocabList.index(word)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>
<h4 id="7-测试函数"><strong>7.测试函数</strong></h4><p>下面给出一个测试函数，直接调用该测试函数就可以实现简单的分类，测试结果看下个部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment">#step1：加载数据集和类标号</span></span><br><span class="line">    listOPosts,listClasses = loadDataSet()</span><br><span class="line">    <span class="comment">#step2：创建词库</span></span><br><span class="line">    myVocabList = createVocabList(listOPosts)</span><br><span class="line">    <span class="comment"># step3：计算每个样本在词库中的出现情况</span></span><br><span class="line">    trainMat=[]</span><br><span class="line">    <span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">        trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">    <span class="comment">#step4：调用第四步函数，计算条件概率</span></span><br><span class="line">    p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses))</span><br><span class="line">    <span class="comment"># step5</span></span><br><span class="line">    <span class="comment"># 测试1 </span></span><br><span class="line">    testEntry = [<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="keyword">print</span> testEntry,<span class="string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br><span class="line">    <span class="comment"># 测试2</span></span><br><span class="line">    testEntry = [<span class="string">'stupid'</span>, <span class="string">'garbage'</span>]</span><br><span class="line">    thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">    <span class="keyword">print</span> testEntry,<span class="string">'classified as: '</span>,classifyNB(thisDoc,p0V,p1V,pAb)</span><br></pre></td></tr></table></figure>
<h4 id="8-实验"><strong>8.实验</strong></h4><p>首先导入库，然后导入bayes.py文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">r"E:\3-CSU\Academic\Machine Leaning\机器学习实战\src\machinelearninginaction\Ch04"</span>)</span><br><span class="line"><span class="keyword">import</span> bayes</span><br></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20150528122404620" alt="这里写图片描述"></p>
<p>可以看出，贝叶斯算法将[‘love’, ‘my’, ‘dalmation’]分为“无侮辱”一类，将[‘stupid’, ‘garbage’]分为“侮辱”性质的一类。</p>
<h3 id="Reference"><strong>Reference</strong></h3><p><strong>[1]《Machine Learning in Action 》机器学习实战</strong></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>源码：<a href="https://github.com/csuldw/MachineLearning/tree/master/NaiveBayes">Github-MachineLearning</a></p>
<p><strong>引文：</strong>前面提到的K最近邻算法和决策树算法，数据实例最终被明确的划分到某个分类中，下面介绍一种不能完全确定数据实例应该划分到哪个类别，或者说只能给数据实例属于给定分类的概率。</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="Naive Bayes" scheme="http://csuldw.github.io/tags/Naive-Bayes/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法-K最近邻从原理到实现]]></title>
    <link href="http://csuldw.github.io/2015/05/21/2015-05-21-KNN/"/>
    <id>http://csuldw.github.io/2015/05/21/2015-05-21-KNN/</id>
    <published>2015-05-21T12:34:00.000Z</published>
    <updated>2016-03-13T06:00:40.457Z</updated>
    <content type="html"><![CDATA[<p>源码：<a href="https://github.com/csuldw/MachineLearning/tree/master/KNN" target="_blank" rel="external">Github-MachineLearning</a></p>
<p><strong>引文</strong>：决策树和基于规则的分类器都是<strong>积极学习方法</strong>（eager learner）的例子，因为一旦训练数据可用，他们就开始学习从输入属性到类标号的映射模型。一个相反的策略是推迟对训练数据的建模，直到需要分类测试样例时再进行。采用这种策略的技术被称为<strong>消极学习法</strong>（lazy learner）。<strong>最近邻分类器</strong>就是这样的一种方法。</p>
<a id="more"></a>
<h3 id="1-K最近邻分类器原理"><strong>1.K最近邻分类器原理</strong></h3><p>首先给出一张图，根据这张图来理解最近邻分类器，如下：</p>
<center><img src="http://img.blog.csdn.net/20150521201557111" alt="这里写图片描述"><br></center>

<p>根据上图所示，有两类不同的样本数据，分别用<strong>蓝色的小正方形</strong>和<strong>红色的小三角形</strong>表示，而图正中间的那个<strong>绿色的圆</strong>所标示的数据则是待分类的数据。也就是说，现在， 我们不知道中间那个绿色的数据是从属于哪一类（蓝色小正方形or红色小三角形），下面，我们就要解决这个问题：给这个绿色的圆分类。</p>
<p>　　我们常说，物以类聚，人以群分，判别一个人是一个什么样品质特征的人，常常可以从他or她身边的朋友入手，所谓观其友，而识其人。我们不是要判别上图中那个绿色的圆是属于哪一类数据么，好说，从它的邻居下手。但一次性看多少个邻居呢？从上图中，你还能看到：</p>
<ul>
<li>如果K=3，绿色圆点的最近的3个邻居是2个红色小三角形和1个蓝色小正方形，少数从属于多数，基于统计的方法，判定绿色的这个待分类点属于红色的三角形一类。</li>
<li>如果K=5，绿色圆点的最近的5个邻居是2个红色三角形和3个蓝色的正方形，还是少数从属于多数，基于统计的方法，判定绿色的这个待分类点属于蓝色的正方形一类。</li>
</ul>
<p>于此我们看到，当无法判定当前待分类点是从属于已知分类中的哪一类时，我们可以依据统计学的理论看它所处的位置特征，衡量它周围邻居的权重，而把它归为(或分配)到权重更大的那一类。这就是K近邻算法的核心思想。</p>
<p>KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。</p>
<p>KNN 算法本身简单有效，它是一种 lazy-learning 算法，分类器不需要使用训练集进行训练，训练时间复杂度为0。KNN 分类的计算复杂度和训练集中的文档数目成正比，也就是说，如果训练集中文档总数为 n，那么 KNN 的分类时间复杂度为O(n)。</p>
<p>前面的例子中强调了选择合适的K值的重要性。如果太小，则最近邻分类器容易受到训练数据的噪声而产生的过分拟合的影响；相反，如果K太大，最近分类器可能会误会分类测试样例，因为最近邻列表中可能包含远离其近邻的数据点。（如下图所示）</p>
<center><img src="http://img.blog.csdn.net/20150521203027253" alt="这里写图片描述"><br><br><strong>K较大时的最近邻分类</strong><br><br></center>


<p>可见，K值的选取还是非常关键。</p>
<hr>
<h3 id="2-算法"><strong>2.算法</strong></h3><p>算法步骤如下所示：</p>
<center><img src="http://img.blog.csdn.net/20150521203212596" alt="这里写图片描述"></center>

<p>对每个测试样例$z = (x’,y’)$，算法计算它和所有训练样例$（x,y）属于D$之间的距离（或相似度），以确定其最近邻列表$D_z$。如果训练样例的数目很大，那么这种计算的开销就会很大。不过，可以使索引技术降低为测试样例找最近邻是的计算量。</p>
<p>一旦得到最近邻列表，测试样例就可以根据最近邻的多数类进行分类，使用多数表决方法。</p>
<hr>
<h3 id="3-K最邻近算法实现（Python）"><strong>3.K最邻近算法实现（Python）</strong></h3><p>KNN.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNN</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createDataset</span><span class="params">(self)</span>:</span></span><br><span class="line">        group = array([[<span class="number">1.0</span>,<span class="number">1.1</span>],[<span class="number">1.0</span>,<span class="number">1.0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0.1</span>]])</span><br><span class="line">        labels = [<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</span><br><span class="line">        <span class="keyword">return</span> group,labels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KnnClassify</span><span class="params">(self,testX,trainX,labels,K)</span>:</span></span><br><span class="line">        [N,M]=trainX.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#calculate the distance between testX and other training samples</span></span><br><span class="line">        difference = tile(testX,(N,<span class="number">1</span>)) - trainX <span class="comment"># tile for array and repeat for matrix in Python, == repmat in Matlab</span></span><br><span class="line">        difference = difference ** <span class="number">2</span> <span class="comment"># take pow(difference,2)</span></span><br><span class="line">        distance = difference.sum(<span class="number">1</span>) <span class="comment"># take the sum of difference from all dimensions</span></span><br><span class="line">        distance = distance ** <span class="number">0.5</span></span><br><span class="line">        sortdiffidx = distance.argsort()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># find the k nearest neighbours</span></span><br><span class="line">        vote = &#123;&#125; <span class="comment">#create the dictionary</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K):</span><br><span class="line">            ith_label = labels[sortdiffidx[i]];</span><br><span class="line">            vote[ith_label] = vote.get(ith_label,<span class="number">0</span>)+<span class="number">1</span> <span class="comment">#get(ith_label,0) : if dictionary 'vote' exist key 'ith_label', return vote[ith_label]; else return 0</span></span><br><span class="line">        sortedvote = sorted(vote.iteritems(),key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse = <span class="keyword">True</span>)</span><br><span class="line">        <span class="comment"># 'key = lambda x: x[1]' can be substituted by operator.itemgetter(1)</span></span><br><span class="line">        <span class="keyword">return</span> sortedvote[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">k = KNN() <span class="comment">#create KNN object</span></span><br><span class="line">group,labels = k.createDataset()</span><br><span class="line">cls = k.KnnClassify([<span class="number">0</span>,<span class="number">0</span>],group,labels,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> cls</span><br></pre></td></tr></table></figure>
<hr>
<p>运行：</p>
<ol>
<li>在Python Shell 中可以运行KNN.py</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> os</span><br><span class="line">&gt;&gt;&gt;os.chdir(<span class="string">"/home/liudiwei/code/data_miningKNN/"</span>)</span><br><span class="line">&gt;&gt;&gt;execfile(<span class="string">"KNN.py"</span>)</span><br></pre></td></tr></table></figure>
<p>输出:B<br>（B表示类别）</p>
<p>2.或者terminal中直接运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python KNN.py</span><br></pre></td></tr></table></figure>
<p>3.也可以不在KNN.py中写输出，而选择在Shell中获得结果，i.e.,</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> KNN</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>KNN.k.KnnClassify([<span class="number">0</span>,<span class="number">0</span>],KNN.group,KNN.labels,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="References"><strong>References</strong></h3><p>【1】Introduction to Data Mining <a href="http://vdisk.weibo.com/s/akTUdytgliZM8" target="_blank" rel="external">数据挖掘导论</a><br>【2】<a href="http://blog.csdn.net/abcjennifer/article/details/19757987" target="_blank" rel="external">Rachel Zhang-K近邻分类算法实现 in Python</a></p>
<hr>
<p>附件（两张自己的计算过程图）：</p>
<center><img src="http://img.blog.csdn.net/20150524192410343" alt="这里写图片描述"><br><strong>图1 KNN算法核心部分</strong><br></center><br><center><br><img src="http://img.blog.csdn.net/20150524192640924" alt="这里写图片描述"><br><strong>图2 简易计算过程</strong><br></center><br>说明：上述图片仅供参考，看不懂就自己测试一组数据如[0,1]慢慢推导一下吧<br><br>———-<br><br><center><strong>本栏目机器学习算法持续更新中……</strong></center>]]></content>
    <summary type="html">
    <![CDATA[<p>源码：<a href="https://github.com/csuldw/MachineLearning/tree/master/KNN">Github-MachineLearning</a></p>
<p><strong>引文</strong>：决策树和基于规则的分类器都是<strong>积极学习方法</strong>（eager learner）的例子，因为一旦训练数据可用，他们就开始学习从输入属性到类标号的映射模型。一个相反的策略是推迟对训练数据的建模，直到需要分类测试样例时再进行。采用这种策略的技术被称为<strong>消极学习法</strong>（lazy learner）。<strong>最近邻分类器</strong>就是这样的一种方法。</p>]]>
    
    </summary>
    
      <category term="KNN" scheme="http://csuldw.github.io/tags/KNN/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="最近邻" scheme="http://csuldw.github.io/tags/%E6%9C%80%E8%BF%91%E9%82%BB/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法-决策树理论]]></title>
    <link href="http://csuldw.github.io/2015/05/08/2015-05-08-decision%20tree/"/>
    <id>http://csuldw.github.io/2015/05/08/2015-05-08-decision tree/</id>
    <published>2015-05-08T13:53:12.000Z</published>
    <updated>2016-03-08T09:02:18.819Z</updated>
    <content type="html"><![CDATA[<p>源码下载：<a href="https://github.com/csuldw/MachineLearning/tree/master/DecisionTree" target="_blank" rel="external">Github-MachineLearning</a></p>
<p><strong>用较少的东西，同样可以做好的事情。越是小的决策树，越优于大的决策树。</strong></p>
<h2 id="引文"><strong>引文</strong></h2><p>数据分类是一个两阶段过程，包括学习阶段（构建分类模型）和分类阶段（使用模型预测给定数据的类标号）。决策树分类算法是监督学习的一种，即Supervised learning。</p>
<ul>
<li>分类过程的第一阶段也可以看做学习一个映射或函数y=f(x),它可以预测给定元组X的类标号y。</li>
<li>在第二阶段，使用模型进行分类。首先评估分类器的预测准确率。这个过程要尽量的减少<strong>过拟合</strong>。（为什么是尽量减少而不是避免呢，因为过拟合一般是避免不了的，再好的模型也会有过拟合的情况）。</li>
</ul>
<a id="more"></a>
<h2 id="1_决策树归纳"><strong>1 决策树归纳</strong></h2><p> 决策树归纳是从有类标号的训练元组中学习决策树。常用的决策树算法有ID3，C4.5和CART。它们都是采用贪心（即非回溯的）方法，其中决策树自顶向下递归的分治方法构造。其中划分属性的方法各不相同，ID3使用的是<strong>信息增益</strong>，C4.5使用的是<strong>信息增益率</strong>，而CART使用的是<strong>Gini基尼指数</strong>。下面来简单介绍下决策树的理论知识。内容包含<strong>熵</strong>、<strong>信息增益</strong>、<strong>信息增益率</strong>以及<strong>Gini指数</strong>的计算公式。</p>
<h2 id="2_基本原理"><strong>2 基本原理</strong></h2><h3 id="2-1_算法优点"><strong>2.1 算法优点</strong></h3><p> 决策树算法的优点如下：<br>（1）分类精度高；<br>（2）成的模式简单；<br>（3）对噪声数据有很好的健壮性。<br>因而是目前应用最为广泛的归纳推理算法之一，在数据挖掘中受到研究者的广泛关注。</p>
<h3 id="2-2_算法一般流程"><strong>2.2 算法一般流程</strong></h3><p>（1）收集数据：任意方法和途径。<br>（2）准备数据：书构造算法只适用于标称型数据，因此数据必须离散化。<br>（3）分析数据：构造树完成后，检查图形是否符合预测。<br>（4）训练算法：决策树的数据构造。<br>（5）测试算法：一般将决策树用于分类，可以用错误率衡量，而错误率使用经验率计算。<br>（6）使用算法：决策树可以用于任何监督学习算法。  </p>
<h3 id="2-3_实例"><strong>2.3 实例</strong></h3><p><strong>信息增益和熵（克劳德.香农提出）</strong></p>
<h4 id="1-使用信息增益进行决策树归纳"><strong>1.使用信息增益进行决策树归纳</strong></h4><p><strong>信息增益度量属性选择</strong></p>
<p>熵被用来衡量一个随机变量出现的期望值。熵越大，一个变量的不确定性就越大（也就是可取的值很多），把它搞清楚所需要的信息量也就越大，熵是整个系统的平均消息量。 信息熵是信息论中用于度量信息量的一个概念。一个系统越是有序，信息熵就越低；反之，一个系统越是混乱，信息熵就越高。所以，信息熵也可以说是系统有序化程度的一个度量。</p>
<p><strong>熵（Entropy）的计算公式</strong></p>
<p>熵定义为<strong>信息的期望值</strong>。先看看信息的定义：</p>
<p>$$l(x_i)=-log_2p(x_i)$$</p>
<p>其中，$p(x_i)$是选择该分类的概率。</p>
<p>对$D$中的元组所有分类所有可能值的信息期望，即熵，计算公式如下：</p>
<p>$$Entropy=H(D)=E(I(D))=-\sum_i^{n}p_ilog_2(p_i)，p_i是D中任意元组属于类C_i非零概率。$$</p>
<p>熵越大，说明系统越混乱，携带的信息就越少。熵越小，说明系统越有序，携带的信息就越多。信息的作用就是在于消除不确定性。</p>
<p>ID3划分特征使用的就是信息增益IG.</p>
<p>一个属性的信息增益越大，表明属性对样本的熵减少的能力就更强，该属性使得数据所属类别的不确定性变为确定性的能力越强。</p>
<p>注：<strong>需要的期望信息越小，分区的纯度越高。</strong></p>
<p><strong>信息增益计算</strong></p>
<p>首先计算特征A对数据集D的经验<strong>条件熵</strong>$H(D|A)$,在数学上就是条件概率分布（Condition Probability）.</p>
<p>$$H(D|A)=\sum_j\dfrac{|D_j|}{|D|}\times H(D_j)，项\dfrac{|D_i|}{|D|}充当第j个分区的权重$$</p>
<p>引入条件熵，在信息论中主要是为了消除结果的不确定性。<br>然后计算信息增益</p>
<p>$$Gain(A) = H(D) - H(D|A)$$</p>
<p>其中，$Gain(A)$即为所求的信息增益。</p>
<p>下面来应用一个实例，<strong>训练元组数据D</strong></p>
<p><img src="http://img.blog.csdn.net/20150513110022176" alt="这里写图片描述"></p>
<p>在这里</p>
<p>$$H(D)=-\dfrac{9}{14}log_2\dfrac{9}{14}-\dfrac{5}{14}log_2\dfrac{5}{14}=0.940位$$</p>
<p>$$H(D|age)=\dfrac{5}{14}\times(-\dfrac{2}{5}log_2\dfrac{2}{5}-\dfrac{3}{5}log_2 \dfrac{3}{5})+\dfrac{4}{14}\times(-\dfrac{4}{4}log_2\dfrac{0}{4}-\dfrac{0}{4}log_2 \dfrac{0}{4})+\dfrac{5}{14}\times(-\dfrac{3}{5}log_2\dfrac{3}{5}-\dfrac{2}{5}log_2 \dfrac{2}{5})=0.694位$$</p>
<p>根据计算出来的条件熵，计算按$age$划分的信息增益，计算方法如下：</p>
<p>$$Gain(age)=H(D)-H(D|age)=0.940-0.964=0.246位$$</p>
<p>类似的可以计算出其它属性的信息增益：</p>
<p>$$ Gain(income)=0.029位，<br>Gain(student)=0.151位，Gain(credit_rating)=0.048位 $$</p>
<p>由于$age$在属性中具有最高的信息增益，所以它被选作分裂特征。下面再进行递归计算信息增益，在此就不展示了。</p>
<p>ID3采用的就是就是IG，算法步骤如下：</p>
<center><br><img src="http://img.blog.csdn.net/20150921091028096" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20150921091053471" alt="这里写图片描述"><br></center>

<h4 id="2-使用增益率计算"><strong>2.使用增益率计算</strong></h4><p><strong>ID3使用的是信息增益，C4.5使用的是信息增益率。</strong></p>
<p>C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进：<br>1) 用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；<br>2) 在树构造过程中进行剪枝；<br>3) 能够完成对连续属性的离散化处理；<br>4) 能够对不完整数据进行处理。  </p>
<p>C4.5算法有如下优点：产生的分类规则易于理解，准确率较高。其缺点是：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。此外，C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。</p>
<p>另外，无论是ID3还是C4.5最好在小数据集上使用，决策树分类一般只试用于小数据。当属性取值很多时最好选择C4.5算法，ID3得出的效果会非常差。</p>
<p><strong>分裂信息计算公式：</strong></p>
<p>$$Split_H(D|A)=-∑\dfrac{|D_j|}{|D|}\times log_2(\dfrac{|D_j|}{|D|})$$</p>
<p>增益率定义为：</p>
<p>$$Gain_Rate(A)=\dfrac{Gain(A)}{Split_H(D|A)}$$</p>
<p>选择具有最大增益率的特征作为分裂特征。</p>
<h4 id="3-基尼指数Gini_index"><strong>3.基尼指数Gini index</strong></h4><p>基尼指数在CART中使用，Gini index度量的是数据分区或训练元组集D的不纯度。计算方式如下：</p>
<p>$$Gini(D)=1-\sum p^{2}_i，其中，p_i是D中元组数以C_i类的概率，对m个类计算和。$$</p>
<h2 id="3-学习推介"><strong>3.学习推介</strong></h2><p>Andrew W. Moore PPT <a href="http://www.autonlab.org/tutorials/dtree18.pdf" target="_blank" rel="external">DTree</a><br>决策树Python实现，单独成文，网址：<a href="http://blog.csdn.net/dream_angel_z/article/details/45965463" target="_blank" rel="external">决策树实现</a><br>Wikipedia维基百科-<a href="https://en.wikipedia.org/wiki/Decision_tree" target="_blank" rel="external">Decision Tree决策树</a></p>
<p>最后，附一张决策树的优点和缺点图：</p>
<center><br><img src="http://img.blog.csdn.net/20150921094738621" alt="这里写图片描述"><br></center>


<h2 id="4-Reference"><strong>4.Reference</strong></h2><p>[1]数据挖掘概念与技术 Third Edition,韩家伟.<br>[2]机器学习实战 ,Peter Harrington.  </p>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>源码下载：<a href="https://github.com/csuldw/MachineLearning/tree/master/DecisionTree">Github-MachineLearning</a></p>
<p><strong>用较少的东西，同样可以做好的事情。越是小的决策树，越优于大的决策树。</strong></p>
<h2 id="引文"><strong>引文</strong></h2><p>数据分类是一个两阶段过程，包括学习阶段（构建分类模型）和分类阶段（使用模型预测给定数据的类标号）。决策树分类算法是监督学习的一种，即Supervised learning。</p>
<ul>
<li>分类过程的第一阶段也可以看做学习一个映射或函数y=f(x),它可以预测给定元组X的类标号y。</li>
<li>在第二阶段，使用模型进行分类。首先评估分类器的预测准确率。这个过程要尽量的减少<strong>过拟合</strong>。（为什么是尽量减少而不是避免呢，因为过拟合一般是避免不了的，再好的模型也会有过拟合的情况）。</li>
</ul>]]>
    
    </summary>
    
      <category term="Decision Tree" scheme="http://csuldw.github.io/tags/Decision-Tree/"/>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git小结-同步一个fork]]></title>
    <link href="http://csuldw.github.io/2015/04/15/2015-04-12-Syncing-a-fork/"/>
    <id>http://csuldw.github.io/2015/04/15/2015-04-12-Syncing-a-fork/</id>
    <published>2015-04-15T05:14:54.000Z</published>
    <updated>2016-03-08T08:46:56.581Z</updated>
    <content type="html"><![CDATA[<h2 id="如何使用搜索引擎">如何使用搜索引擎</h2><p>其实这个问题并不难，我又被坑了。百度搜的东西不靠谱啊，以后这种问题一定要用<strong>英文</strong>在 <a href="http://www.google.com" target="_blank" rel="external">Google</a> 或者 <a href="http://cn.bing.com/" target="_blank" rel="external">Bing</a> 上搜索，这样才能搜到原汁原味的答案。就当是一个教训吧。   </p>
<p>搜索 fork sync，就可以看到 GitHub 自己的帮助文档 <a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="external">Syncing a fork</a> 点进去看这篇的时候，注意到有一个 Tip: Before you can sync your fork with an upstream repository, you must <a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/" target="_blank" rel="external">configure a remote that points to the upstream repository</a> in Git.<br>根据这两篇文章，问题迎刃而解！ </p>
<a id="more"></a>
<hr>
<h2 id="具体方法">具体方法</h2><hr>
<h3 id="Configuring_a_remote_for_a_fork">Configuring a remote for a fork</h3><ul>
<li><p>给 fork 配置一个 remote   </p>
</li>
<li><p>主要使用 <code>git remote -v</code> 查看远程状态。   </p>
</li>
</ul>
<pre><code>git remote -v
# origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
# origin  https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
</code></pre>

<ul>
<li>添加一个将被同步给 fork 远程的上游仓库      </li>
</ul>
<pre><code>git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git
</code></pre>


<ul>
<li>再次查看状态确认是否配置成功。   </li>
</ul>
<pre><code>git remote -v
# origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (fetch)
# origin    https://github.com/YOUR_USERNAME/YOUR_FORK.git (push)
# upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch)
# upstream  https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push)
</code></pre>

<hr>
<h3 id="Syncing_a_fork">Syncing a fork</h3><ul>
<li>从上游仓库 fetch 分支和提交点，传送到本地，并会被存储在一个本地分支 upstream/master<br><code>git fetch upstream</code>    </li>
</ul>
<pre><code>git fetch upstream
# remote: Counting objects: 75, done.
# remote: Compressing objects: 100% (53/53), done.
# remote: Total 62 (delta 27), reused 44 (delta 9)
# Unpacking objects: 100% (62/62), done.
# From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY
#  * [new branch]      master     -> upstream/master
</code></pre>

<ul>
<li>切换到本地主分支(如果不在的话)<br><code>git checkout master</code>    </li>
</ul>
<pre><code>git checkout master
# Switched to branch 'master'
</code></pre>

<ul>
<li>把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修改的内容。<br><code>git merge upstream/master</code>      </li>
</ul>
<pre><code>git merge upstream/master
# Updating a422352..5fdff0f
# Fast-forward
#  README                    |    9 -------
#  README.md                 |    7 ++++++
#  2 files changed, 7 insertions(+), 9 deletions(-)
#  delete mode 100644 README
#  create mode 100644 README.md
</code></pre>

<ul>
<li>如果想更新到 GitHub 的 fork 上，直接 <code>git push origin master</code> 就好了。</li>
</ul>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="如何使用搜索引擎">如何使用搜索引擎</h2><p>其实这个问题并不难，我又被坑了。百度搜的东西不靠谱啊，以后这种问题一定要用<strong>英文</strong>在 <a href="http://www.google.com">Google</a> 或者 <a href="http://cn.bing.com/">Bing</a> 上搜索，这样才能搜到原汁原味的答案。就当是一个教训吧。   </p>
<p>搜索 fork sync，就可以看到 GitHub 自己的帮助文档 <a href="https://help.github.com/articles/syncing-a-fork/">Syncing a fork</a> 点进去看这篇的时候，注意到有一个 Tip: Before you can sync your fork with an upstream repository, you must <a href="https://help.github.com/articles/configuring-a-remote-for-a-fork/">configure a remote that points to the upstream repository</a> in Git.<br>根据这两篇文章，问题迎刃而解！ </p>]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://csuldw.github.io/tags/GitHub/"/>
    
      <category term="fork" scheme="http://csuldw.github.io/tags/fork/"/>
    
      <category term="同步" scheme="http://csuldw.github.io/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="GitHub" scheme="http://csuldw.github.io/categories/GitHub/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代码校验工具 SublimeLinter 的安装与使用]]></title>
    <link href="http://csuldw.github.io/2015/03/26/2015-03-26-sublimeLinter/"/>
    <id>http://csuldw.github.io/2015/03/26/2015-03-26-sublimeLinter/</id>
    <published>2015-03-26T07:14:54.000Z</published>
    <updated>2016-03-08T09:01:57.155Z</updated>
    <content type="html"><![CDATA[<h2 id="序">序</h2><p>本文我将讲述一下 SublimeLinter 的安装过程。<br>其组件 jshint 的安装与使用。<br>其组件 csslint 的安装与使用。<br>我将基于 <a href="http://sublimetext.com/3" target="_blank" rel="external">Sublime Text 3</a> 来安装。<br>使用 Sublime Text 2 的用户阅读本文是没有帮助的。   </p>
<p>SublimeLinter 是 Sublime 的插件，它的作用是检查代码语法是否有错误，并提示。习惯了 IDE 下写代码的人一定需要一款在 Sublime 上类似的语法检查工具。下面我们开始。   </p>
<a id="more"></a>
<hr>
<h2 id="安装_SublimeLinter">安装 SublimeLinter</h2><p>如同其他插件一样使用 Package Control 来安装。   </p>
<ol>
<li>按下 <code>Ctrl+Shift+p</code> 进入 Command Palette   </li>
<li>输入<code>install</code>进入 Package Control: Install Package   </li>
<li>输入<code>SublimeLinter</code>。进行安装.   </li>
</ol>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-sublimeLinter.jpg" alt="SublimeLinter">   </p>
<p>安装完成后可以看到这样一段话：   </p>
<pre><code class="markdown">Welcome to SublimeLinter, a linter framework for Sublime Text 3.

                  * * * IMPORTANT! * * *

         SublimeLinter 3 is NOT a drop-in replacement for
        earlier versions.

         Linters *NOT* included with SublimeLinter 3, 
         they must be installed separately.

         The settings are different.

                 * * * READ THE DOCS! * * *

 Otherwise you will never know how to install linters, nor will
 you know about all of the great new features in SublimeLinter 3.

 For complete documentation on how to install and use SublimeLinter,
 please see:

 http://www.sublimelinter.com</code></pre>   

<p>可以看到具体的 Linters 组件<strong>不</strong>被包含在 SublimeLinter 3 中，所以我们要额外独立安装组件。<br>可以针对不同的语言安装不同的组件。   </p>
<hr>
<h2 id="JavaScript_语法检查">JavaScript 语法检查</h2><p>SublimeLinter-jshint 是基于 nodeJS 下的 jshint 的插件，实际上 SublimeLinter-jshint 调用了 nodeJS 中 jshint 的接口来进行语法检查的。   </p>
<hr>
<h3 id="安装_SublimeLinter-jshint">安装 SublimeLinter-jshint</h3><p>为了让 JavaScript 代码有语法检查，我们安装 SublimeLinter-jshint<br>同样的方法，我们安装 SublimeLinter-jshint    </p>
<ol>
<li>按下 <code>Ctrl+Shift+p</code> 进入 Command Palette   </li>
<li>输入<code>install</code>进入 Package Control: Install Package   </li>
<li>输入<code>SublimeLinter-jshint</code>。进行安装.   </li>
</ol>
<p>如下图   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-jshint.jpg" alt="SublimeLinter-jshint">   </p>
<p>安装完成后我们可以看到下面的一段话   </p>
<h2 id="SublimeLinter-jshint"><pre><code class="markdown">SublimeLinter-jshint</code></pre></h2><p>  This linter plugin for SublimeLinter provides an interface to jshint.</p>
<p>  <strong> IMPORTANT! </strong></p>
<p>  Before this plugin will activate, you <em>must</em><br>  follow the installation instructions here:</p>
<p>  <a href="https://github.com/SublimeLinter/SublimeLinter-jshint" target="_blank" rel="external">https://github.com/SublimeLinter/SublimeLinter-jshint</a><br></p>
<hr>
<h3 id="安装_nodeJS_和_jshint">安装 nodeJS 和 jshint</h3><p>在插件开始工作之前，我们必须再看一下上述插件的<a href="https://github.com/SublimeLinter/SublimeLinter-jshint" target="_blank" rel="external">安装说明</a><br>通过 <a href="https://github.com/SublimeLinter/SublimeLinter-jshint" target="_blank" rel="external">SublimeLinter-jshint 的说明</a> 我们可以看到，这个组件依赖于 nodeJS 下的 jshint，所以我们安装 nodeJS 环境和 nodeJS 下的 jshint。   </p>
<ol>
<li>安装 <a href="https://nodejs.org/" target="_blank" rel="external">Node.js</a>   </li>
<li>通过 npm 安装<code>jshint</code>   </li>
</ol>
<p>在命令行下输入如下代码，完成安装   </p>
<pre><code>npm <span class="keyword">install</span> -g jshint
</code></pre><p>安装完成后命令行中出现如下的信息   </p>
<pre><code><span class="attribute">C</span>:\Users\Administrator\AppData\Roaming\npm\jshint -&gt; <span class="attribute">C</span>:\Users\Administrator\AppData\Roaming\npm\node_modules\jshint\bin\jshint
jshint<span class="variable">@2</span>.<span class="number">6.3</span> <span class="attribute">C</span>:\Users\Administrator\AppData\Roaming\npm\node_modules\jshint
├── strip-json-comments<span class="variable">@1</span>.<span class="number">0.2</span>
├── underscore<span class="variable">@1</span>.<span class="number">6.0</span>
├── exit<span class="variable">@0</span>.<span class="number">1.2</span>
├── shelljs<span class="variable">@0</span>.<span class="number">3.0</span>
├── console-browserify<span class="variable">@1</span>.<span class="number">1.0</span> (date-now<span class="variable">@0</span>.<span class="number">1.4</span>)
├── htmlparser2<span class="variable">@3</span>.<span class="number">8.2</span> (domelementtype<span class="variable">@1</span>.<span class="number">3.0</span>, entities<span class="variable">@1</span>.<span class="number">0.0</span>, domhandler<span class="variable">@2</span>.<span class="number">3.0</span>, readable-stream<span class="variable">@1</span>.<span class="number">1.13</span>, domutils<span class="variable">@1</span>.<span class="number">5.1</span>)
├── minimatch<span class="variable">@1</span>.<span class="number">0.0</span> (sigmund<span class="variable">@1</span>.<span class="number">0.0</span>, lru-cache<span class="variable">@2</span>.<span class="number">5.0</span>)
└── cli<span class="variable">@0</span>.<span class="number">6.6</span> (glob<span class="variable">@3</span>.<span class="number">2.11</span>)
</code></pre><p>可以查看 jshint 版本，已确认安装完成。  </p>
<pre><code>C:<span class="command">\Users</span><span class="command">\Administrator</span>&gt;jshint -v
jshint v2.6.3
</code></pre><p>现在，恭喜你，我们使用 Sublime 编辑 JavaScript 文件，就会有语法检查了！   </p>
<p>在编辑过程中，会有如下提示   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-jshint-test.jpg" alt="SublimeLinter-jshint-test"></p>
<p>点击提示点后，Sublime 状态栏也会有相应的说明   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-jshint-test2.jpg" alt="SublimeLinter-jshint-test2"></p>
<hr>
<h2 id="css_语法检查">css 语法检查</h2><p>与 jshint 同理，SublimeLinter-csslint 也是基于 nodeJS 下的 csslint 的插件，实际上 SublimeLinter-csslint 调用了 nodeJS 中 csslint 的接口来进行语法检查的。   </p>
<hr>
<h3 id="安装_SublimeLinter-csslint">安装 SublimeLinter-csslint</h3><p>同样的方法。   </p>
<ol>
<li>按下 <code>Ctrl+Shift+p</code> 进入 Command Palette   </li>
<li>输入<code>install</code>进入 Package Control: Install Package   </li>
<li>输入<code>SublimeLinter-csslint</code>。进行安装.   </li>
</ol>
<p>如下图   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-csslint.jpg" alt="SublimeLinter-csslint">   </p>
<p>安装完成后我们可以看到下面的一段话   </p>
<pre><code><span class="header">SublimeLinter-csslint
-------------------------------</span>
This linter plugin for SublimeLinter provides an interface to csslint.

<span class="bullet">** </span>IMPORTANT! **

Before this plugin will activate, you <span class="strong">*must*</span>
follow the installation instructions here:

https://github.com/SublimeLinter/SublimeLinter-csslint
</code></pre><p>在使用插件之前，必须遵循上述网址中的<a href="https://github.com/SublimeLinter/SublimeLinter-csslint" target="_blank" rel="external">安装说明</a>   </p>
<hr>
<h3 id="在_nodeJS_下安装_csslint">在 nodeJS 下安装 csslint</h3><p>进入上述的 GitHub 地址，csslint 的说明页。我们知道了和 jshint 一样，csslint 也是基于 nodeJS 下的 csslint 来使用的。   </p>
<p>这里安装 nodeJS 过程省略。<br>只需用 npm 安装 csslint 即可。   </p>
<p>在命令行中输入     </p>
<pre><code>npm <span class="keyword">install</span> -g csslint   
</code></pre><p>安装完成后命令行中出现如下的信息     </p>
<pre><code><span class="attribute">C</span>:\Users\Administrator\AppData\Roaming\npm\csslint -&gt; <span class="attribute">C</span>:\Users\Administrator\AppData\Roaming\npm\node_modules\csslint\cli.js
csslint<span class="variable">@0</span>.<span class="number">10.0</span> <span class="attribute">C</span>:\Users\Administrator\AppData\Roaming\npm\node_modules\csslint
└── parserlib<span class="variable">@0</span>.<span class="number">2.5</span>
</code></pre><p>可以查看 csslint 版本，已确认安装完成。   </p>
<pre><code>C:<span class="command">\Users</span><span class="command">\Administrator</span>&gt;csslint --version
v0.10.0
</code></pre><p>现在，恭喜你，我们使用 Sublime 编辑 css 文件，就会有语法检查了！     </p>
<p>在编辑过程中，会有如下提示   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-csslint-test.jpg" alt="SublimeLinter-csslint-test"></p>
<p>点击提示点后，Sublime 状态栏也会有相应的说明   </p>
<p><img src="http://7q5cdt.com1.z0.glb.clouddn.com/SublimeLinter-csslint-test2.jpg" alt="SublimeLinter-csslint-test2"></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="序">序</h2><p>本文我将讲述一下 SublimeLinter 的安装过程。<br>其组件 jshint 的安装与使用。<br>其组件 csslint 的安装与使用。<br>我将基于 <a href="http://sublimetext.com/3">Sublime Text 3</a> 来安装。<br>使用 Sublime Text 2 的用户阅读本文是没有帮助的。   </p>
<p>SublimeLinter 是 Sublime 的插件，它的作用是检查代码语法是否有错误，并提示。习惯了 IDE 下写代码的人一定需要一款在 Sublime 上类似的语法检查工具。下面我们开始。   </p>]]>
    
    </summary>
    
      <category term="SublimeLinter" scheme="http://csuldw.github.io/tags/SublimeLinter/"/>
    
      <category term="工具" scheme="http://csuldw.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习算法Top10]]></title>
    <link href="http://csuldw.github.io/2015/03/18/2015-03-18-machine-learning-top10-algorithms/"/>
    <id>http://csuldw.github.io/2015/03/18/2015-03-18-machine-learning-top10-algorithms/</id>
    <published>2015-03-18T02:24:00.000Z</published>
    <updated>2016-03-13T06:01:19.923Z</updated>
    <content type="html"><![CDATA[<p>以下就是从参加评选的18种候选算法中，最终决选出来的十大经典算法：</p>
<h3 id="一、C4-5">一、C4.5</h3><p>C4.5，是机器学习算法中的一个分类决策树算法，<br>它是决策树(决策树也就是做决策的节点间的组织方式像一棵树，其实是一个倒树)核心算法<br>ID3的改进算法，所以基本上了解了一半决策树构造方法就能构造它。<br>决策树构造方法其实就是每次选择一个好的特征以及分裂点作为当前节点的分类条件。</p>
<p>C4.5相比于ID3改进的地方有：</p>
<a id="more"></a>
<ul>
<li>1.用信息增益率来选择属性。ID3选择属性用的是子树的信息增益，这里可以用很多方法来定义信息，ID3使用的是熵(entropy，熵是一种不纯度度量准则),也就是熵的变化值.而C4.5用的是信息增益率。区别就在于<font color="#007FFF"><strong>一个是信息增益，一个是信息增益率</strong></font>。一般来说率就是用来取平衡用的，就像方差起的作用差不多，比如有两个跑步的人，一个起点是10m/s的人、其10s后为20m/s；另一个人起速是1m/s、其1s后为2m/s。如果紧紧算差值那么两个差距就很大了，如果使用速度增加率(加速度，即都是为1m/s^2)来衡量，2个人就是一样的加速度。因此，C4.5克服了ID3用信息增益选择属性时偏向选择取值多的属性的不足。</li>
<li>2.在树构造过程中进行剪枝，在构造决策树的时候，那些挂着几个元素的节点，不考虑最好，不然容易导致overfitting。</li>
<li>3.对非离散数据也能处理。</li>
<li>4.能够对不完整数据进行处理。</li>
</ul>
<h3 id="二、The_k-means_algorithm_即K-Means算法">二、The k-means algorithm 即K-Means算法</h3><p>k-means algorithm算法是一个聚类算法，<font color="#007FFF"><strong>把n的对象根据他们的属性分为k个分割(k &lt; n)</strong></font>。它与处理混合正态分布的最大期望算法(本十大算法第五条)很相似，因为他们都试图找到数据中自然聚类的中心。<br>它假设对象属性来自于空间向量，并且目标是使各个群组内部的均方误差总和最小。</p>
<h3 id="三、_Support_vector_machines">三、 Support vector machines</h3><p>支持向量机，英文为Support Vector Machine，简称SV机（论文中一般简称SVM）。</p>
<p>它是一种监督式学习的方法，它广泛的应用于统计分类以及回归分析中。</p>
<p><font color="#007FFF"><strong>支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面</strong></font>。在分开数据的超平面的两边建有两个互相平行的超平面，分隔超平面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。</p>
<p>一个极好的指南是C.J.C Burges的《模式识别支持向量机指南》。van der Walt 和 Barnard 将支持向量机和其他分类器进行了比较。</p>
<h3 id="四、The_Apriori_algorithm">四、The Apriori algorithm</h3><p>Apriori算法是一种最有影响的<font color="#007FFF"><strong>挖掘布尔关联规则频繁项集</strong></font>的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，<font color="#007FFF"><strong>所有支持度大于最小支持度的项集称为频繁项集，简称频集</strong></font>。</p>
<h3 id="五、最大期望(EM)算法">五、最大期望(EM)算法</h3><p>在统计计算中，最大期望 （EM，Expectation–Maximization）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。</p>
<p>最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。</p>
<h3 id="六、_PageRank">六、 PageRank</h3><p>PageRank是Google算法的重要内容。2001年9月被授予美国专利，专利人是Google创始人之一拉里•佩奇（Larry Page）。因此，PageRank里的page不是指网页，而是指佩奇，即这个等级方法是以佩奇来命名的。PageRank根据网站的外部链接和内部链接的数量和质量，衡量网站的价值。PageRank背后的概念是，每个到页面的链接都是对该页面的一次投票， 被链接的越多，就意味着被其他网站投票越多。</p>
<p>这个就是所谓的“链接流行度”——衡量多少人愿意将他们的网站和你的网站挂钩。PageRank这个概念引自学术中一篇论文的被引述的频度——即被别人引述的次数越多，一般判断这篇论文的权威性就越高。</p>
<h3 id="七、AdaBoost">七、AdaBoost</h3><p>Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器 (强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器融合起来，作为最后的决策分类器。</p>
<h3 id="八、_kNN:_k-nearest_neighbor_classification">八、 kNN: k-nearest neighbor classification</h3><p>K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。KNN方法的思路：<font color="#007FFF"><strong>如果一个样本在特征空间中的k个最相似的(即特征空间中最邻近的K个)样本中的大多数属于某一个类别，则该样本也属于这个类别</strong></font>。</p>
<h3 id="九、_Naive_Bayes">九、 Naive Bayes</h3><p>在众多的分类模型中，应用最为广泛的两种分类模型是<font color="#007FFF"><strong>决策树模型(Decision Tree Model)和朴素贝叶斯模型（Naive Bayesian Model，NBC）</strong></font>。 朴素贝叶斯模型发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。在属性个数比较多或者属性之间相关性较大时，NBC模型的分类效率比不上决策树模型。而在属性相关性较小时，NBC模型的性能最为良好。</p>
<h3 id="十、_CART:_分类与回归树">十、 CART: 分类与回归树</h3><p>CART, Classification and Regression Trees。 在分类树下面有两个关键的思想：<strong>第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝</strong>。</p>
<p>至于18种候选算法，可参考这里：<a href="http://www.cs.uvm.edu/~icdm/algorithms/CandidateList.shtml" target="_blank" rel="external">http://www.cs.uvm.edu/~icdm/algorithms/CandidateList.shtml</a></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下就是从参加评选的18种候选算法中，最终决选出来的十大经典算法：</p>
<h3 id="一、C4-5">一、C4.5</h3><p>C4.5，是机器学习算法中的一个分类决策树算法，<br>它是决策树(决策树也就是做决策的节点间的组织方式像一棵树，其实是一个倒树)核心算法<br>ID3的改进算法，所以基本上了解了一半决策树构造方法就能构造它。<br>决策树构造方法其实就是每次选择一个好的特征以及分裂点作为当前节点的分类条件。</p>
<p>C4.5相比于ID3改进的地方有：</p>]]>
    
    </summary>
    
      <category term="Machine Learning" scheme="http://csuldw.github.io/tags/Machine-Learning/"/>
    
      <category term="汇总" scheme="http://csuldw.github.io/tags/%E6%B1%87%E6%80%BB/"/>
    
      <category term="ML" scheme="http://csuldw.github.io/categories/ML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[腾讯笔试题-字符串匹配]]></title>
    <link href="http://csuldw.github.io/2015/02/14/2015-02-14-string-match/"/>
    <id>http://csuldw.github.io/2015/02/14/2015-02-14-string-match/</id>
    <published>2015-02-14T04:12:00.000Z</published>
    <updated>2016-03-08T08:46:15.136Z</updated>
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>假设两个字符串中所含有的字符和个数都相同我们就叫这两个字符串匹配，比如：abcda和adabc,由于出现的字符个数都是相同，只是顺序不同，所以这两个字符串是匹配的。要求高效。</p>
<a id="more"></a>
<h2 id="思路">思路</h2><p>假定字符串中都是ASCII字符。用一个数组来计数，前者加，后者减，全部为0则匹配。</p>
<h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*---------------------------------------------</span><br><span class="line">*   date：2015-02-14</span><br><span class="line">*   author：LDW</span><br><span class="line">*   title: 字符串匹配</span><br><span class="line">*   From：腾讯</span><br><span class="line">*   Blog：http://csuldw.github.io</span><br><span class="line">-----------------------------------------------*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;cstring&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">StrMatch</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size1 = str1.size();</span><br><span class="line">        <span class="keyword">int</span> size2 = str2.size();</span><br><span class="line">        <span class="keyword">if</span>(size1 &lt;= <span class="number">0</span> || size2 &lt;= <span class="number">0</span> || size1 != size2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count[<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="built_in">memset</span>(count,<span class="number">0</span>,<span class="keyword">sizeof</span>(count));</span><br><span class="line">        <span class="comment">// 前者加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size1; ++i)&#123;</span><br><span class="line">            ++count[str1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后者减</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size2; ++i)&#123;</span><br><span class="line">            --count[str2[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//全部为0则匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">("afafafa")</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">("afafaf")</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;solution.StrMatch(str1,str2)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="题目">题目</h2><p>假设两个字符串中所含有的字符和个数都相同我们就叫这两个字符串匹配，比如：abcda和adabc,由于出现的字符个数都是相同，只是顺序不同，所以这两个字符串是匹配的。要求高效。</p>]]>
    
    </summary>
    
      <category term="字符串匹配" scheme="http://csuldw.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="数据结构" scheme="http://csuldw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="笔试" scheme="http://csuldw.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="算法与数据结构" scheme="http://csuldw.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[排序算法-归并排序]]></title>
    <link href="http://csuldw.github.io/2014/12/21/2014-12-21-MergeSort/"/>
    <id>http://csuldw.github.io/2014/12/21/2014-12-21-MergeSort/</id>
    <published>2014-12-21T04:24:00.000Z</published>
    <updated>2016-03-13T10:23:57.767Z</updated>
    <content type="html"><![CDATA[<p><strong>注：代码均使用C++编写.</strong></p>
<h2 id="介绍">介绍</h2><p>对于数据较大的输入，归并排序是比较快的一个算法。该算法采用的是分治法的思想。</p>
<p>原理：将数据分开排序，然后进行合并，最后形成一个排好的序列。</p>
<a id="more"></a>
<p><img src="/assets/articleImg/2014-12-21-mergeSort-1.png" alt=""></p>
<p>将其合并输出，如下图所示：</p>
<p><img src="/assets/articleImg/2014-12-21-mergeSort-2.png" alt=""></p>
<p>归并排序有一个关键步骤：合并两个排序好的序列。方法是：两个序列中的数相互比较，将较小的数先插入新的序列中。</p>
<p>归并过程：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>
<ul>
<li>发明者：约翰·冯·诺伊曼</li>
<li>时间复杂度：O(nlogn)</li>
<li>空间复杂度 O（n)</li>
<li>稳定的算法</li>
</ul>
<h2 id="一次合并">一次合并</h2><p>在代码实现部分，需要进行递归进行合并，因此，先编写一个合并的方法。</p>
<p>归并操作的工作原理如下：</p>
<p>一次归并函数传递的参数有：一个数组名、数组的起始位置、数组的末尾位置以及数组的中点位置。</p>
<ul>
<li>第一步：申请空间，初始化起点中点和中点到末尾位置两个变量(nl,nr)，同时设定两个指针p和q，空间大小分别为nl和nr;</li>
<li>第二步：将数组分别输入到两个空间中;</li>
<li>第三步：合并两个数组。操作：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置;</li>
<li>重复步骤3直到某一指针超出序列尾;</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾.</li>
</ul>
<p>在第三步的时候，需要注意的是，不额外的开辟辅助数组，直接通过两个指针的值将原数组的数值进行修改。此处需要设置一个变量<code>k</code>，起始位置为数组的起始位置,方便在合并时同时增加指针的下标和数组下标值.</p>
<p>注：使用<code>malloc</code>时，需要引入<code>#include &lt;stdlib.h&gt;</code>头文件。</p>
<p>代码如下:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void mergeOne(<span class="keyword">int</span> nums[], <span class="keyword">int</span> l, <span class="keyword">int</span> <span class="keyword">m</span>, <span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">int</span> nl = <span class="keyword">m</span> - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nr = r - <span class="keyword">m</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = NULL, *<span class="keyword">q</span> = NULL;</span><br><span class="line">    p = (<span class="keyword">int</span> *) malloc (nl * sizeof(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">q</span> = (<span class="keyword">int</span> *) malloc (nr * sizeof(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>将数组输入到两个空间中</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl; i++) &#123;</span><br><span class="line">        p[i] = nums[l + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nr; j++) &#123;</span><br><span class="line">        <span class="string">q[j]</span> = nums[<span class="keyword">m</span> + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //合并两个数组</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k = l;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; nl &amp;&amp; j &lt; nr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] &lt; <span class="string">q[j]</span>) &#123;</span><br><span class="line">            nums[k++] = p[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums[k++] = <span class="string">q[j++]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将剩余的元素合并</span><br><span class="line">    <span class="keyword">while</span>(i &lt; nl) &#123;</span><br><span class="line">        nums[k++]  = p[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;nr) &#123;</span><br><span class="line">        nums[k++] = <span class="string">q[j++]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2><p>通过合并函数来实现归并排序的算法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：此处的left和right必须是数组下标能取到的有效值</span></span><br><span class="line">void mergeSort(int nums[], int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">    int mid = (<span class="keyword">left</span> + <span class="keyword">right</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</span><br><span class="line">        mergeSort(nums, <span class="keyword">left</span>, mid);</span><br><span class="line">        mergeSort(nums, mid+<span class="number">1</span>, <span class="keyword">right</span>);</span><br><span class="line">        mergeOne(nums, <span class="keyword">left</span>, mid, <span class="keyword">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[]=&#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    print_array(nums,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<pre><code class="markdown">1 2 3 4 5 6 7 9

Process returned 0 (0x0)   execution time : 0.097 s
Press any key to continue.
</code></pre>

<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>注：代码均使用C++编写.</strong></p>
<h2 id="介绍">介绍</h2><p>对于数据较大的输入，归并排序是比较快的一个算法。该算法采用的是分治法的思想。</p>
<p>原理：将数据分开排序，然后进行合并，最后形成一个排好的序列。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://csuldw.github.io/tags/C/"/>
    
      <category term="归并" scheme="http://csuldw.github.io/tags/%E5%BD%92%E5%B9%B6/"/>
    
      <category term="排序" scheme="http://csuldw.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="数据结构" scheme="http://csuldw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法与数据结构" scheme="http://csuldw.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[插入排序-简单插入排序&希尔排序]]></title>
    <link href="http://csuldw.github.io/2014/12/21/2014-12-21-InsertSort/"/>
    <id>http://csuldw.github.io/2014/12/21/2014-12-21-InsertSort/</id>
    <published>2014-12-21T03:24:00.000Z</published>
    <updated>2016-03-13T06:01:57.391Z</updated>
    <content type="html"><![CDATA[<p><strong>注：代码均使用C++编写.</strong></p>
<p>首先介绍一个常用排序算法的时间复杂度和空间复杂度的表格：</p>
<p><img src="/assets/articleImg/2014-12-21-performances-of-sort-algs.png" alt=""></p>
<a id="more"></a>
<p>对于插入排序，本文简单介绍两种：简单插入排序和希尔排序。同时，会附上实现源码。</p>
<h2 id="1-知识点小记">1.知识点小记</h2><ul>
<li><p>使用<code>sizeof(nums)/sizeof(nums[0])</code>获得数组的长度；</p>
</li>
<li><p>数组作为参数有两种方法，一种是以数组名本身，一种是以指针；</p>
</li>
<li><p>如果要给一个函数传入一个数组，一般都是传入两个参数，一个数组指针或数组名，另一个是数组大小；</p>
</li>
</ul>
<h2 id="2-简单插入排序">2.简单插入排序</h2><p>直接插入排序(Insertion Sort)的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p>
<p>实现：从头到尾遍历数组，设置一个变量作为哨兵，记录当前元素；然后从当前位置依次往前寻找插入点，如果哨兵元素值要小，就将前面的元素往后移动一位，直到哨兵元素大于前面的元素为止。</p>
<p>设数组为a[0…n-1]。</p>
<ul>
<li>初始时，a[0]自成1个有序区，无序区为a[1..n-1]。令i=1</li>
<li>将a[i]并入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。</li>
<li>i++，并重复第二步直到i==n-1。</li>
</ul>
<p>简单插入排序方法实现：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert sort</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[j]&gt;temp &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个完整的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span>；</span><br><span class="line"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    insertSort(nums, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; (<span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(nums[<span class="number">0</span>])); i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert sort</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums[j]&gt;temp &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单插入排序最坏和平均时间复杂度都为O($n^2$),空间复杂度为O(1)，最好的时间复杂度为O(n).属于稳定的排序算法。</p>
<hr>
<h2 id="3-希尔排序">3.希尔排序</h2><p>希尔排序思路：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p>
<p>希尔排序方法：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line">void shellSort(int nums[], int <span class="keyword">n</span>)&#123;</span><br><span class="line">    int <span class="keyword">d</span> = <span class="keyword">n</span>&gt;&gt;1;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">d</span>&gt;=1)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=0; i&lt;<span class="keyword">n</span>-<span class="keyword">d</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(int j=i+<span class="keyword">d</span>; j&lt;<span class="keyword">n</span>; j+=<span class="keyword">d</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j-<span class="keyword">d</span>]&gt;nums[j])&#123;</span><br><span class="line">                    int temp = nums[j-<span class="keyword">d</span>];</span><br><span class="line">                    nums[j-<span class="keyword">d</span>] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">d</span> = <span class="keyword">d</span>&gt;&gt;1;</span><br><span class="line">        print_array(nums,<span class="keyword">n</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个完整的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(nums[<span class="number">0</span>]);</span><br><span class="line">    shellSort(nums, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; (<span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(nums[<span class="number">0</span>])); i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(d&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n-d; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+d; j&lt;n; j+=d)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j-d]&gt;nums[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j-d];</span><br><span class="line">                    nums[j-d] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        d = d&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        print_array(nums,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;nums[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/assets/articleImg/2014-12-21-insert-sort.png" alt=""></p>
<p>简单插入排序平均时间复杂度为O($n^{1.3}$),空间复杂度为O(1)。最坏情况下的时间复杂度为O($n^2$),最好的时间复杂度为O(n).</p>
<hr>
<h2 id="4-补充知识点">4.补充知识点</h2><p><strong>将数组作为参数传递</strong></p>
<p>两种形式：</p>
<ul>
<li>使用数组名本身,如上方的函数形式：</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> insertSort(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure>
<ul>
<li>用指针作为参数,这就简单了,只需将上面方法中的数组修改成指针形式:</li>
</ul>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> insertSort(<span class="keyword">int</span> *nums, <span class="keyword">int</span> n)</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>注：代码均使用C++编写.</strong></p>
<p>首先介绍一个常用排序算法的时间复杂度和空间复杂度的表格：</p>
<p><img src="/assets/articleImg/2014-12-21-performances-of-sort-algs.png" alt=""></p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://csuldw.github.io/tags/C/"/>
    
      <category term="希尔" scheme="http://csuldw.github.io/tags/%E5%B8%8C%E5%B0%94/"/>
    
      <category term="排序" scheme="http://csuldw.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="插入" scheme="http://csuldw.github.io/tags/%E6%8F%92%E5%85%A5/"/>
    
      <category term="数据结构" scheme="http://csuldw.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法与数据结构" scheme="http://csuldw.github.io/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python元组与列表的区别]]></title>
    <link href="http://csuldw.github.io/2014/12/19/2014-12-19-The-difference-of-list-and-tupple/"/>
    <id>http://csuldw.github.io/2014/12/19/2014-12-19-The-difference-of-list-and-tupple/</id>
    <published>2014-12-19T06:24:00.000Z</published>
    <updated>2016-03-13T06:02:09.663Z</updated>
    <content type="html"><![CDATA[<h2 id="list和tuple区别">list和tuple区别</h2><p>列表和元组非常类似，有时候他们都干一样的事情。他们最大的区别是:</p>
<ul>
<li><p><strong>元组一旦被赋值，值不可以被改变，一旦改变就会出错；列表可以任意的更改</strong>。</p>
</li>
<li><p><strong>他们用不同的符号表示，赋值的时候，列表用方括号”[]”，而元组用小括号”（）”</strong>。</p>
</li>
</ul>
<a id="more"></a>
<p>列表：列表中的元素应该包括在方括号中，你可以添加、删除或是搜索列表中的元素。由于你可以增加或删除项目，所以列表是可变的数据类型，即这种类型是可以被改变的。</p>
<p>元组：元组和列表十分类似，但是元组是不可变的.也就是说你不能修改元组。元组通过圆括号中用逗号分割的项目定义。元组通常用在使语句或用户定义的函数能够安全地采用一组值的时候，即被使用的元组的值不会改变。</p>
<h2 id="用法">用法</h2><h3 id="1-list">1.list</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">li</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] #赋值，使用中括号</span><br><span class="line"><span class="tag">li</span>[<span class="number">1</span>] = <span class="number">11</span> #修改<span class="tag">li</span>[<span class="number">1</span>]的值,此时li变成[<span class="number">1</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="tag">li</span>[<span class="number">0</span>] = <span class="string">"LOVE"</span> #此时li变成[<span class="string">'LOVE'</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
</li>
<li><p>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。</p>
</li>
<li><p>列表用[ ]标识。是python最通用的复合数据类型。看这段代码就明白。</p>
</li>
<li><p>列表中的值得分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引默认0开始的，从右到左索引默认-1开始，下标可以为空表示取到头或尾。</p>
</li>
</ul>
<p>加号（+）是列表连接运算符，星号（*）是重复操作。如下实例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span> = [ <span class="string">'abcd'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">'john'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="keyword">list</span> <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="keyword">print</span> <span class="keyword">list</span>[<span class="number">0</span>] <span class="comment"># 输出列表的第一个元素</span></span><br><span class="line"><span class="keyword">print</span> <span class="keyword">list</span>[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 输出第二个至第三个的元素 </span></span><br><span class="line"><span class="keyword">print</span> <span class="keyword">list</span>[<span class="number">2</span>:] <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="keyword">print</span> tinylist * <span class="number">2</span> <span class="comment"># 输出列表两次</span></span><br><span class="line"><span class="keyword">print</span> <span class="keyword">list</span> + tinylist <span class="comment"># 打印组合的列表</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<pre><code class="markdown">['abcd', 786, 2.23, 'john', 70.2]
abcd
[786, 2.23]
[2.23, 'john', 70.2]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.2, 123, 'john']
</code></pre>


<h3 id="2-tuple">2.tuple</h3><ul>
<li><p>元组是另一个数据类型，类似于List（列表）。</p>
</li>
<li><p>元组用”()”标识。内部元素用逗号隔开。但是元素不能二次赋值，相当于只读列表。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">tuple = ( <span class="string">'abcd'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">'john'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> tuple <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> tuple[<span class="number">0</span>] <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> tuple[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 输出第二个至第三个的元素 </span></span><br><span class="line"><span class="built_in">print</span> tuple[<span class="number">2</span>:] <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span> tinytuple * <span class="number">2</span> <span class="comment"># 输出元组两次</span></span><br><span class="line"><span class="built_in">print</span> tuple + tinytuple <span class="comment"># 打印组合的元组</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="quoted">'abcd</span>', <span class="number">786</span>, <span class="number">2.23</span>, <span class="quoted">'john</span>', <span class="number">70.2</span>)</span></span><br><span class="line">abcd</span><br><span class="line"><span class="list">(<span class="number">786</span>, <span class="number">2.23</span>)</span></span><br><span class="line"><span class="list">(<span class="number">2.23</span>, <span class="quoted">'john</span>', <span class="number">70.2</span>)</span></span><br><span class="line"><span class="list">(<span class="number">123</span>, <span class="quoted">'john</span>', <span class="number">123</span>, <span class="quoted">'john</span>')</span></span><br><span class="line"><span class="list">(<span class="quoted">'abcd</span>', <span class="number">786</span>, <span class="number">2.23</span>, <span class="quoted">'john</span>', <span class="number">70.2</span>, <span class="number">123</span>, <span class="quoted">'john</span>')</span></span><br></pre></td></tr></table></figure>
<p>tuple不可修改，否则会报错。</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="list和tuple区别">list和tuple区别</h2><p>列表和元组非常类似，有时候他们都干一样的事情。他们最大的区别是:</p>
<ul>
<li><p><strong>元组一旦被赋值，值不可以被改变，一旦改变就会出错；列表可以任意的更改</strong>。</p>
</li>
<li><p><strong>他们用不同的符号表示，赋值的时候，列表用方括号”[]”，而元组用小括号”（）”</strong>。</p>
</li>
</ul>]]>
    
    </summary>
    
      <category term="Python" scheme="http://csuldw.github.io/tags/Python/"/>
    
      <category term="Python" scheme="http://csuldw.github.io/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linx学习笔记-tree命令]]></title>
    <link href="http://csuldw.github.io/2014/11/19/2014-11-19-linux-tree-command/"/>
    <id>http://csuldw.github.io/2014/11/19/2014-11-19-linux-tree-command/</id>
    <published>2014-11-19T02:24:00.000Z</published>
    <updated>2016-03-08T08:44:39.758Z</updated>
    <content type="html"><![CDATA[<h2 id="安装">安装</h2><p>有时候，我们想要知道一个目录下面的详细情况，那么有什么好的方法呢？</p>
<p>很幸运，Linux shell 有一个tree 命令，专门用来打印目录树。</p>
<p>如果你没有安装，可以使用<code>yum</code>来安装，命令如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install tree</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="使用">使用</h2><p>此时如果想打印某个目录下的所有文件，可以使用<code>tree</code>命令：</p>
<pre><code class="markdown">[liudiwei@master _code]$ tree
.
`-- preprocessing
    |-- compareTwoFile.py
    |-- download.py
    |-- extractChainFromSeq.py
    |-- extractSeqByChain.py
    |-- formatChain.py
    |-- generateSeqFromDSSP.py
    |-- getProteinFromChain.py
    |-- getProteinNameFromDir.py
    |-- pdbToDSSP.py
    `-- _README.txt
</code></pre>


<p>此外，如果只想要显示目录的话，可以使用添加<code>-d</code>参数：</p>
<pre><code class="markdown">[liudiwei@master DNA_BP]$ tree -d
.
|-- _code
|   `-- preprocessing
|-- _data
|   `-- Exp_DBPI
|       |-- DBPI_Datasets
|       |-- dssp_testset
|       |   `-- format
|       |-- dssp_trainset
|       |   `-- format
|       |-- pdb_testset
|       `-- pdb_trainset
|-- _feature
|   `-- feature_extraction
`-- paper_Graham

14 directories
</code></pre>

<p>如果你不想看到全部的文件？可以加上“-P 通配符”的方法来只列出某种文件：</p>
<pre><code class="markdown">[liudiwei@master DNA_BP]$ tree -P "*.py"
.
|-- _code
|   `-- preprocessing
|       |-- compareTwoFile.py
|       |-- download.py
|       |-- extractChainFromSeq.py
|       |-- extractSeqByChain.py
|       |-- formatChain.py
|       |-- generateSeqFromDSSP.py
|       |-- getProteinFromChain.py
|       |-- getProteinNameFromDir.py
|       `-- pdbToDSSP.py
|-- _data
|   `-- Exp_DBPI
|       |-- DBPI_Datasets
|       |-- dssp_testset
|       |   `-- format
|       |-- dssp_trainset
|       |   `-- format
|       |-- pdb_testset
|       `-- pdb_trainset
|-- _feature
|   `-- feature_extraction
`-- paper2015_Graham
</code></pre>

<h2 id="详细参数">详细参数</h2><p><code>tree</code>常用参数：</p>
<pre><code class="markdown">
-a 显示所有文件和目录。

-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。

-C 在文件和目录清单加上色彩，便于区分各种类型。

-d 显示目录名称而非内容。

-D 列出文件或目录的更改时间。

-f 在每个文件或目录之前，显示完整的相对路径名称。

-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*“,”/“,”=“,”@“,”|“号。

-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。

-i 不以阶梯状列出文件或目录名称。

-I <范本样式> 不显示符合范本样式的文件或目录名称。

-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。

-n 不在文件和目录清单加上色彩。

-N 直接列出文件和目录名称，包括控制字符。

-p 列出权限标示。

-P <范本样式> 只显示符合范本样式的文件或目录名称。

-q 用”?“号取代控制字符，列出文件和目录名称。

-s 列出文件或目录大小。

-t 用文件和目录的更改时间排序。

-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。

-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。
</范本样式></范本样式></code></pre>

<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装">安装</h2><p>有时候，我们想要知道一个目录下面的详细情况，那么有什么好的方法呢？</p>
<p>很幸运，Linux shell 有一个tree 命令，专门用来打印目录树。</p>
<p>如果你没有安装，可以使用<code>yum</code>来安装，命令如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install tree</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://csuldw.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="http://csuldw.github.io/tags/Shell/"/>
    
      <category term="Linux" scheme="http://csuldw.github.io/categories/Linux/"/>
    
  </entry>
  
</feed>