<!doctype html>
<html class="theme-next use-motion ">
<head><meta name="generator" content="Hexo 3.8.0">
  

<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">








  <link rel="stylesheet" type="text/css" href="/others/fancybox/source/jquery.fancybox.css?v=2.1.5">



  
    <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  


<link rel="stylesheet" type="text/css" href="/others/font-awesome/css/font-awesome.min.css?v=4.4.0">

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2">


    <meta name="description" content="中南大学硕士，关注机器学习、深度学习、自然语言处理与人工智能领域.">



  <meta name="keywords" content="数据结构,LeetCode,">



  <link rel="alternate" href="/atom.xml" title="D.W's Notes - Machine Learning" type="application/atom+xml">



  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=0.4.5.2">


<meta name="description" content="本文是先前做LeetCode时的部分题解，有的题目既包含C++代码，也有Python代码，为方便查阅，决定将这些思路合并到一文之中。">
<meta name="keywords" content="数据结构,LeetCode">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode部分题解">
<meta property="og:url" content="https://www.csuldw.com/2015/12/12/2015-12-12-LeetCode-ans/index.html">
<meta property="og:site_name" content="D.W&#39;s Notes - Machine Learning">
<meta property="og:description" content="本文是先前做LeetCode时的部分题解，有的题目既包含C++代码，也有Python代码，为方便查阅，决定将这些思路合并到一文之中。">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://www.csuldw.com/assets/articleImg/2015-12-12-leetcode.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150609210526658">
<meta property="og:image" content="http://img.blog.csdn.net/20150609213752137">
<meta property="og:image" content="http://articles.leetcode.com/wp-content/uploads/2014/12/robot_maze.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150610095309420">
<meta property="og:updated_time" content="2017-01-09T07:30:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode部分题解">
<meta name="twitter:description" content="本文是先前做LeetCode时的部分题解，有的题目既包含C++代码，也有Python代码，为方便查阅，决定将这些思路合并到一文之中。">
<meta name="twitter:image" content="https://www.csuldw.com/assets/articleImg/2015-12-12-leetcode.png">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> LeetCode部分题解 | D.W's Notes - Machine Learning </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div id="container" class="container one-column page-post-detail">

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  
  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
      
	  	<span style="font-size:14px;float:right;padding:39px 40px 0 0;">——悄悄是别离的笙箫，沉默是今晚的康桥.</span>
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">

        	<div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LeetCode部分题解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            Posted on
            <time itemprop="dateCreated" datetime="2015-12-12T00:00:00+08:00" content="2015-12-12">
              2015-12-12 00:00
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp; In
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/12/2015-12-12-LeetCode-ans/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/12/12/2015-12-12-LeetCode-ans/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

          
            <span id="/2015/12/12/2015-12-12-LeetCode-ans/" class="leancloud_visitors" data-flag-title="LeetCode部分题解">
            &nbsp; | &nbsp;   
            views
            </span>
          
        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>本文是先前做LeetCode时的部分题解，有的题目既包含C++代码，也有Python代码，为方便查阅，决定将这些思路合并到一文之中。</p>
<p><img src="/assets/articleImg/2015-12-12-leetcode.png" alt="leetcode"></p>
<a id="more"></a> 

<p>题解目录如下：</p>
<ul>
<li><a href="#Leetcode[1]-Two_Sum">Leetcode[1]-Two Sum</a></li>
<li><a href="#Leetcode[4]-Median_of_Two_Sorted_Arrays">Leetcode[4]-Median of Two Sorted Arrays</a></li>
<li><a href="#Leetcode[7]-Reverse_Integer">Leetcode[7]-Reverse Integer</a></li>
<li><a href="#Leetcode[9]-Palindrome_Number">Leetcode[9]-Palindrome Number</a></li>
<li><a href="#Leetcode[12]-Integer_to_Roman+++">Leetcode[12]-Integer to Roman+++</a></li>
<li><a href="#Leetcode[13]-Roman_to_Integer+++">Leetcode[13]-Roman to Integer+++</a></li>
<li><a href="#Leetcode[15]-3Sum">Leetcode[15]-3Sum</a></li>
<li><a href="#Leetcode[18]-4Sum">Leetcode[18]-4Sum</a></li>
<li><a href="#Leetcode[19]-Remove_Nth_Node_From_End_of_List">Leetcode[19]-Remove Nth Node From End of List</a></li>
<li><a href="#Leetcode[20]-Valid_Parentheses">Leetcode[20]-Valid Parentheses</a></li>
<li><a href="#Leetcode[21]-Merge_Two_Sorted_Lists">Leetcode[21]-Merge Two Sorted Lists</a></li>
<li><a href="#Leetcode[26]-Remove_Duplicates_from_Sorted_Array">Leetcode[26]-Remove Duplicates from Sorted Array</a></li>
<li><a href="#Leetcode[27]-Remove_Element">Leetcode[27]-Remove Element</a></li>
<li><a href="#Leetcode[33]-Search_in_Rotated_Sorted_Array">Leetcode[33]-Search in Rotated Sorted Array</a></li>
<li><a href="#Leetcode[35]-Search_Insert_Position">Leetcode[35]-Search Insert Position</a></li>
<li><a href="#Leetcode[36]-Valid_Sudoku">Leetcode[36]-Valid Sudoku</a></li>
<li><a href="#Leetcode[53]-Maximum_Subarray">Leetcode[53]-Maximum Subarray</a></li>
<li><a href="#Leetcode[62]-Unique_Paths">Leetcode[62]-Unique Paths</a></li>
<li><a href="#Leetcode[63]-Unique_Paths_II">Leetcode[63]-Unique Paths II</a></li>
<li><a href="#Leetcode[66]-Plus_One">Leetcode[66]-Plus One</a></li>
<li><a href="#Leetcode[70]-Climbing_Stairs">Leetcode[70]-Climbing Stairs</a></li>
<li><a href="#Leetcode[74]-Search_a_2D_Matrix">Leetcode[74]-Search a 2D Matrix</a></li>
<li><a href="#Leetcode[81]-Search_for_a_Range">Leetcode[81]-Search for a Range</a></li>
<li><a href="#Leetcode[82]-Remove_Duplicates_from_Sorted_List_II">Leetcode[82]-Remove Duplicates from Sorted List II</a></li>
<li><a href="#Leetcode[83]-Remove_Duplicates_from_Sorted_List">Leetcode[83]-Remove Duplicates from Sorted List</a></li>
<li><a href="#Leetcode[86]-Partition_List">Leetcode[86]-Partition List</a></li>
<li><a href="#Leetcode[88]-Merge_Sorted_Array">Leetcode[88]-Merge Sorted Array</a></li>
<li><a href="#Leetcode[92]-Reverse_Linked_List_II">Leetcode[92]-Reverse Linked List II</a></li>
<li><a href="#Leetcode[94]-Binary_Tree_Inorder_Traversal">Leetcode[94]-Binary Tree Inorder Traversal</a></li>
<li><a href="#Leetcode[96]-Unique_Binary_Search_Trees">Leetcode[96]-Unique Binary Search Trees</a></li>
<li><a href="#Leetcode[98]-Validate_Binary_Search_Tree">Leetcode[98]-Validate Binary Search Tree</a></li>
<li><a href="#Leetcode[100]-Same_Tree">Leetcode[100]-Same Tree</a></li>
<li><a href="#Leetcode[101]-Symmetric_Tree">Leetcode[101]-Symmetric Tree</a></li>
<li><a href="#Leetcode[102]-Binary_Tree_Level_Order_Traversal">Leetcode[102]-Binary Tree Level Order Traversal</a></li>
<li><a href="#Leetcode[103]-Binary_Tree_Zigzag_Level_Order_Traversal">Leetcode[103]-Binary Tree Zigzag Level Order Traversal</a></li>
<li><a href="#Leetcode[104]-Maximum_Depth_of_Binary_Tree">Leetcode[104]-Maximum Depth of Binary Tree</a></li>
<li><a href="#Leetcode[107]-Binary_Tree_Level_Order_Traversal_II">Leetcode[107]-Binary Tree Level Order Traversal II</a></li>
<li><a href="#Leetcode[110]-Balanced_Binary_Tree">Leetcode[110]-Balanced Binary Tree</a></li>
<li><a href="#Leetcode[111]-Minimum_Depth_of_Binary_Tree">Leetcode[111]-Minimum Depth of Binary Tree</a></li>
<li><a href="#Leetcode[113]-Path_Sum_II">Leetcode[113]-Path Sum II</a></li>
<li><a href="#Leetcode[114]-Flatten_Binary_Tree_to_Linked_List">Leetcode[114]-Flatten Binary Tree to Linked List</a></li>
<li><a href="#Leetcode[118]-Pascal's_Triangle">Leetcode[118]-Pascal’s Triangle</a></li>
<li><a href="#Leetcode[119]-Pascal's_Triangle_II">Leetcode[119]-Pascal’s Triangle II</a></li>
<li><a href="#Leetcode[125]-Valid_Palindrome">Leetcode[125]-Valid Palindrome</a></li>
<li><a href="#Leetcode[128]-Longest_Consecutive_Sequence">Leetcode[128]-Longest Consecutive Sequence</a></li>
<li><a href="#Leetcode[136]-Single_Number">Leetcode[136]-Single Number</a></li>
<li><a href="#Leetcode[137]-Single_Number_II">Leetcode[137]-Single Number II</a></li>
<li><a href="#Leetcode[141]-Linked_List_Cycle">Leetcode[141]-Linked List Cycle</a></li>
<li><a href="#Leetcode[143]-Reorder_List">Leetcode[143]-Reorder List</a></li>
<li><a href="#Leetcode[144]-Binary_Tree_Preorder_Traversal">Leetcode[144]-Binary Tree Preorder Traversal</a></li>
<li><a href="#Leetcode[145]-Binary_Tree_Postorder_Traversal">Leetcode[145]-Binary Tree Postorder Traversal</a></li>
<li><a href="#Leetcode[147]-Insertion_Sort_List">Leetcode[147]-Insertion Sort List</a></li>
<li><a href="#Leetcode[148]-Sort_List">Leetcode[148]-Sort List</a></li>
<li><a href="#Leetcode[153]-Find_Minimum_in_Rotated_Sorted_Array">Leetcode[153]-Find Minimum in Rotated Sorted Array</a></li>
<li><a href="#Leetcode[154]-Find_Minimum_in_Rotated_Sorted_Array_II">Leetcode[154]-Find Minimum in Rotated Sorted Array II</a></li>
<li><a href="#LeetCode[155]-Min_Stack">LeetCode[155]-Min Stack</a></li>
<li><a href="#Leetcode[162]-Find_Peak_Element">Leetcode[162]-Find Peak Element</a></li>
<li><a href="#Leetcode[169]-Majority_Element">Leetcode[169]-Majority Element</a></li>
<li><a href="#Leetcode[173]-Binary_Search_Tree_Iterator">Leetcode[173]-Binary Search Tree Iterator</a></li>
<li><a href="#Leetcode[189]-Rotate_Array">Leetcode[189]-Rotate Array</a></li>
<li><a href="#Leetcode[191]-Number_of_Bits">Leetcode[191]-Number of Bits</a></li>
<li><a href="#Leetcode[198]-House_Robber">Leetcode[198]-House Robber</a></li>
<li><a href="#Leetcode[202]-Happy_Number">Leetcode[202]-Happy Number</a></li>
<li><a href="#Leetcode[203]-Remove_Linked_List_Elements">Leetcode[203]-Remove Linked List Elements</a></li>
<li><a href="#Leetcode[206]-Reverse_Linked_List">Leetcode[206]-Reverse Linked List</a></li>
<li><a href="#Leetcode[215]-Kth_Largest_Element_in_an_Array">Leetcode[215]-Kth Largest Element in an Array</a></li>
<li><a href="#Leetcode[217]-Contains_Duplicate">Leetcode[217]-Contains Duplicate</a></li>
<li><a href="#Leetcode[219]-Contains_Duplicate_II">Leetcode[219]-Contains Duplicate II</a></li>
<li><a href="#Leetcode[222]-Count_Complete_Tree_Nodes">Leetcode[222]-Count Complete Tree Nodes</a></li>
<li><a href="#Leetcode[226]-Invert_Binary_Tree">Leetcode[226]-Invert Binary Tree</a></li>
<li><a href="#Leetcode[231]-Power_of_Two">Leetcode[231]-Power of Two</a></li>
<li><a href="#Leetcode[237]-Delete_Node_in_a_Linked_List">Leetcode[237]-Delete Node in a Linked List</a></li>
<li><a href="#Leetcode[242]-Valid_Anagram">Leetcode[242]-Valid Anagram</a></li>
<li><a href="#Leetcode[258]-Add_Digits">Leetcode[258]-Add Digits</a></li>
<li><a href="#Leetcode[260]-Single_Number_III">Leetcode[260]-Single Number III</a></li>
<li><a href="#Leetcode[263]-Ugly_Number++">Leetcode[263]-Ugly Number++</a></li>
<li><a href="#Leetcode[283]-Move_Zeroes">Leetcode[283]-Move Zeroes</a></li>
<li><a href="#Leetcode[292]-Nim_Game">Leetcode[292]-Nim Game</a></li>
<li><a href="#Leetcode[300]-Longest_Increasing_Subsequence">Leetcode[300]-Longest Increasing Subsequence</a></li>
</ul>
<p>下面是具体题解内容。</p>
<hr>
<h1 id="Leetcode-1-Two-Sum"><a href="#Leetcode-1-Two-Sum" class="headerlink" title="Leetcode[1]-Two Sum"></a>Leetcode[1]-Two Sum</h1><p>Link:<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum/</a>  </p>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<hr>
<p>分析：<br>方法一：使用两个for循环，依次比较，不过这个方法在leetcode上超时了</p>
<p>c++</p>
<figure class="highlight fortran"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="built_in">int</span>&gt; twoSum(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="keyword">target</span>) {</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; <span class="built_in">index</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n ; i++) {</span><br><span class="line">        <span class="built_in">index</span>[<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">        for(<span class="built_in">int</span> j = i+<span class="number">1</span> ; j &lt; n ; j++) {</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == <span class="keyword">target</span>){</span><br><span class="line">                <span class="built_in">index</span>[<span class="number">1</span>] = j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">index</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">index</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法二：使用map存储所有的数组值和下标值，然后循环在map中找看能否找到target-nums[i]的map，如果找到了就终止循环，没找到继续找；最后返回index数组；</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mapv;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) {</span><br><span class="line">            mapv[nums[i]] = i;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            it = mapv.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it != mapv.end() &amp;&amp; i!=it-&gt;second){</span><br><span class="line">                index[<span class="number">0</span>]=min(i+<span class="number">1</span>, it-&gt;second + <span class="number">1</span>);</span><br><span class="line">                index[<span class="number">1</span>]=max(i+<span class="number">1</span>, it-&gt;second + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-4-Median-of-Two-Sorted-Arrays"><a href="#Leetcode-4-Median-of-Two-Sorted-Arrays" class="headerlink" title="Leetcode[4]-Median of Two Sorted Arrays"></a>Leetcode[4]-Median of Two Sorted Arrays</h1><p>Link: <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">https://leetcode.com/problems/median-of-two-sorted-arrays/</a></p>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<hr>
<p>思路：先将两个数组合并，然后排序，最后找中位数</p>
<p>中位数：若有n个数，n为奇数，则选择第（n+1）/2个为中位数，若n为偶数，则中位数是（n/2以及n/2+1）的平均数；</p>
<p>合并两个vector：merge(nums1.begin(),nums1.end(),nums2.begin(),nums2.end(),nums.begin());</p>
<p>Code(c++):</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> findMedianSortedArrays(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2) {</span><br><span class="line">        <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(),n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; nums(m+n);</span><br><span class="line">    </span><br><span class="line">        merge(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>(),nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>(),nums.<span class="built_in">begin</span>());</span><br><span class="line">    </span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> mid = (m+n)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">if</span>((m+n)%<span class="number">2</span>==<span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">return</span> <span class="keyword">double</span>(nums[mid]+nums[mid - <span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">        }<span class="built_in">else</span></span><br><span class="line">            <span class="built_in">return</span> nums[mid];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-7-Reverse-Integer"><a href="#Leetcode-7-Reverse-Integer" class="headerlink" title="Leetcode[7]-Reverse Integer"></a>Leetcode[7]-Reverse Integer</h1><p>Link: <a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-integer/</a></p>
<p>Reverse digits of an integer.</p>
<pre><code>Example1: x = 123, return 321
Example2: x = -123, return -321</code></pre><hr>
<p>取一个数的最后一位，用<code>x % 10</code>,取一个数的前n-1位（共n位），用<code>x/10</code>，每一次取的时候，都将上一次取的数乘以10，然后再加上末尾的数即可，代码如下：</p>
<p>Code(C++)</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span> Solution {</span><br><span class="line">public:</span><br><span class="line">    int <span class="built_in">reverse</span>(int x) {</span><br><span class="line">        long <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="literal">result</span> = <span class="literal">result</span>*<span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line"><span class="built_in">        return</span> (<span class="literal">result</span> &gt; INT_MAX || <span class="literal">result</span> &lt; INT_MIN)? <span class="number">0</span> : <span class="literal">result</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-9-Palindrome-Number"><a href="#Leetcode-9-Palindrome-Number" class="headerlink" title="Leetcode[9]-Palindrome Number"></a>Leetcode[9]-Palindrome Number</h1><p>Link: <a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-number/</a></p>
<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
<hr>
<p>思路：求出它的反转数，然后比较两个数是否恒等于即可。</p>
<p>C++代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x, result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( y &gt; <span class="number">0</span> ){</span><br><span class="line">            result = result * <span class="number">10</span> + y%<span class="number">10</span>;</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result == x;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>法二：将数字转换成字符串，遍历一遍字符串，看首位是否相等即可</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(<span class="keyword">int</span> x) {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;=<span class="number">9</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    string <span class="keyword">str</span>;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss&lt;&lt;x;</span><br><span class="line">    ss&gt;&gt;<span class="keyword">str</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">str</span>.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (len/<span class="number">2</span>); i++ ){</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">str</span>[i] != <span class="keyword">str</span>[len<span class="number">-1</span>-i])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-12-Integer-to-Roman"><a href="#Leetcode-12-Integer-to-Roman" class="headerlink" title="Leetcode[12]-Integer to Roman+++"></a>Leetcode[12]-Integer to Roman+++</h1><p>Link: <a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">https://leetcode.com/problems/integer-to-roman/</a></p>
<p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<hr>
<p>分析：</p>
<p>C++:</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string intToRoman(<span class="keyword">int</span> num) {</span><br><span class="line">        <span class="keyword">int</span> s[<span class="number">7</span>]={<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">int</span> Roman[<span class="number">7</span>]={<span class="number">1000</span>,<span class="number">500</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">1</span>};</span><br><span class="line">        <span class="keyword">char</span> ch[<span class="number">7</span>]={<span class="string">'M'</span>,<span class="string">'D'</span>,<span class="string">'C'</span>,<span class="string">'L'</span>,<span class="string">'X'</span>,<span class="string">'V'</span>,<span class="string">'I'</span>};</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">index</span>=<span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">index</span>&lt;<span class="number">7</span>) {</span><br><span class="line">            s[<span class="keyword">index</span>]=num/Roman[<span class="keyword">index</span>];</span><br><span class="line">            num%=Roman[<span class="keyword">index</span>++];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++){</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="number">1</span>&amp;&amp;i+<span class="number">1</span>&lt;<span class="number">7</span>&amp;&amp;s[i+<span class="number">1</span>]==<span class="number">4</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="number">4</span>){</span><br><span class="line">                <span class="keyword">if</span> (s[i<span class="number">-1</span>]==<span class="number">1</span>)</span><br><span class="line">                    result=result+ch[i]+ch[i<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    result=result+ch[i]+ch[i<span class="number">-1</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)</span><br><span class="line">                    result+=ch[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-13-Roman-to-Integer"><a href="#Leetcode-13-Roman-to-Integer" class="headerlink" title="Leetcode[13]-Roman to Integer+++"></a>Leetcode[13]-Roman to Integer+++</h1><p>Link: <a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">https://leetcode.com/problems/roman-to-integer/</a></p>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<hr>
<p>分析：</p>
<p>从前往后扫描，用一个临时变量记录分段数字。</p>
<p>如果当前处理的字符对应的值和上一个字符一样，那么临时变量加上这个字符。比如III = 3<br>如果当前比前一个大，说明这一段的值应该是当前这个值减去前面记录下的临时变量中的值。比如IIV = 5 – 2<br>如果当前比前一个小，那么就可以先将临时变量的值加到结果中，然后开始下一段记录。比如VI = 5 + 1</p>
<p>C++:</p>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> romanToInt(string s) {</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">num</span>[<span class="number">256</span>] = { <span class="number">0</span> };</span><br><span class="line">        <span class="built_in">num</span>[<span class="string">'I'</span>] = <span class="number">1</span>; <span class="built_in">num</span>[<span class="string">'V'</span>] = <span class="number">5</span>; <span class="built_in">num</span>[<span class="string">'X'</span>] = <span class="number">10</span>; <span class="built_in">num</span>[<span class="string">'L'</span>]=<span class="number">50</span>;</span><br><span class="line">        <span class="built_in">num</span>[<span class="string">'C'</span>] = <span class="number">100</span>; <span class="built_in">num</span>[<span class="string">'D'</span>] = <span class="number">500</span>; <span class="built_in">num</span>[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.size()){</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">num</span>[s[i]] &lt; <span class="built_in">num</span>[s[i+<span class="number">1</span>]])</span><br><span class="line">                result -= <span class="built_in">num</span>[s[i]];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result += <span class="built_in">num</span>[s[i]];</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Python：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Num = {<span class="string">"I"</span>:<span class="number">1</span>, <span class="string">"V"</span>:<span class="number">5</span>, <span class="string">"X"</span>:<span class="number">10</span>, <span class="string">"L"</span>:<span class="number">50</span>, <span class="string">"C"</span>:<span class="number">100</span>, <span class="string">"D"</span>:<span class="number">500</span>, <span class="string">"M"</span>:<span class="number">1000</span>}</span><br><span class="line">        L = len(s)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(i &lt; L - <span class="number">1</span>):</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(Num.get(s[i]) &lt; Num.get(s[i + <span class="number">1</span>])):</span><br><span class="line">                sum -= Num.get(s[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sum += Num.get(s[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        sum += Num.get(s[i])</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-15-3Sum"><a href="#Leetcode-15-3Sum" class="headerlink" title="Leetcode[15]-3Sum"></a>Leetcode[15]-3Sum</h1><p>Link:<a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode.com/problems/3sum/</a></p>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:<br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>    For example, given array S = {-1 0 1 2 -1 -4},</p>
<pre><code>A solution set is:
(-1, 0, 1)
(-1, -1, 2)</code></pre><hr>
<p>分析：根据题意，我们可以要找出三个数相加等于0的这样的一个集合，所以采用二维数组存储。</p>
<p>首先对数组进行从小到大排序，然后抽取一个变量出来，该变量从左往右递归遍历，递归的同时设置两个变量，让其中一个从第一个变量的右边开始，另一个从数组的末端开始，同步的向中间遍历，有点类似于快速排序的判断方式，</p>
<ul>
<li>如果三个数相加小于零，则让第二个变量自加；</li>
<li>如果三个数相加大于零，则让第三个变量自减；</li>
<li>如果三个数相加等于零，则将三个数加入到数组中，然后让第二个变量和第三个变量同步增减，自增自减的过程中要判断是否有重复数字；</li>
</ul>
<p>依次递归，直到第一个变量条件终止为止。</p>
<p><strong>Code(c++):</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;  result;</span><br><span class="line"></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++){</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            threeNumber(nums, result, i); </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//return vector&lt;vector&lt;int&gt; &gt; results </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threeNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;results, <span class="keyword">int</span> curIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = curIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.size()<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(i &lt; j){</span><br><span class="line">            <span class="keyword">if</span>(nums[curIndex] + nums[i] + nums[j] &lt; <span class="number">0</span>)   i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[curIndex] + nums[i] + nums[j] &gt; <span class="number">0</span>)   j--;</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">                v.push_back(nums[curIndex]);</span><br><span class="line">                v.push_back(nums[i]);</span><br><span class="line">                v.push_back(nums[j]);</span><br><span class="line">                results.push_back(v);</span><br><span class="line">                i++; j--;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i]==nums[i - <span class="number">1</span>]) i++;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; i &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-18-4Sum"><a href="#Leetcode-18-4Sum" class="headerlink" title="Leetcode[18]-4Sum"></a>Leetcode[18]-4Sum</h1><p>Link: <a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum/</a></p>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.</p>
<hr>
<p>分析：和第15道题有点类似，仅仅是多了一层循环，注意该循环的条件就行.</p>
<p>C++:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;    </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();        </span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++){</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i+<span class="number">1</span> &amp;&amp; nums[j]== nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                fourNumber(nums,result,i,j,target);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fourNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;results, <span class="keyword">int</span> curIndex1,<span class="keyword">int</span> curIndex2,<span class="keyword">int</span> target)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> i = curIndex2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.size()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;j) {</span><br><span class="line">            <span class="keyword">if</span>(nums[curIndex1] + nums[curIndex2] + nums[i] + nums[j] &lt; target ) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[curIndex1] + nums[curIndex2] + nums[i] + nums[j] &gt; target ) j--;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">                vec.push_back(nums[curIndex1]);</span><br><span class="line">                vec.push_back(nums[curIndex2]);</span><br><span class="line">                vec.push_back(nums[i]);</span><br><span class="line">                vec.push_back(nums[j]);</span><br><span class="line">                results.push_back(vec);</span><br><span class="line">                i++,j--;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])i++;</span><br><span class="line">                <span class="keyword">while</span>(j &gt; i &amp;&amp; nums[j] == nums[j+<span class="number">1</span>])j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode[19]-Remove Nth Node From End of List"></a>Leetcode[19]-Remove Nth Node From End of List</h1><p>Link: <a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p>
<pre><code>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.

After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</code></pre><p>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>
<hr>
<p><strong>思路：</strong>先将链表翻转，然后遍历，找到第n-1个节点，然后删除第n个节点，最后再次翻转链表即可。</p>
<p><strong>笔记：</strong>在链表翻转后，我采用的是在翻转后的链表的头部放一个无关的节点，然后往后面找，变量从1到n，当变量为n的时候，此时节点还处于n-1节点上，接着我们就让该节点的下个节点指向它的下下个节点，这样第k个节点就删除了。</p>
<p>Code(c++):</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* removeNthFromEnd(ListNode* head, <span class="keyword">int</span> n) {</span><br><span class="line">    </span><br><span class="line">        reverseList(head);</span><br><span class="line">        ListNode *newList = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        newList-&gt;<span class="keyword">next</span> = head;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">        ListNode *pre = newList;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//find the prior element</span></span><br><span class="line">			<span class="comment">//when we get the Nth Node,delete this node from list</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">count</span>==n &amp;&amp; pre-&gt;<span class="keyword">next</span>!=<span class="keyword">NULL</span>){</span><br><span class="line">                pre-&gt;<span class="keyword">next</span> = pre-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                pre = pre-&gt;<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        head = newList-&gt;<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">//when head is not null,reverse it</span></span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">NULL</span>)</span><br><span class="line">            reverseList(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> reverseList(ListNode* &amp;head){</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">NULL</span> || head-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *newList = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        </span><br><span class="line">        ListNode *temp;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">NULL</span>){</span><br><span class="line">            temp = pre-&gt;<span class="keyword">next</span>;</span><br><span class="line">            pre-&gt;<span class="keyword">next</span> = newList-&gt;<span class="keyword">next</span>;</span><br><span class="line">            newList-&gt;<span class="keyword">next</span> = pre;</span><br><span class="line">            pre = temp;</span><br><span class="line">        }</span><br><span class="line">        newList = newList-&gt;<span class="keyword">next</span>;</span><br><span class="line">        head = newList;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-20-Valid-Parentheses"><a href="#Leetcode-20-Valid-Parentheses" class="headerlink" title="Leetcode[20]-Valid Parentheses"></a>Leetcode[20]-Valid Parentheses</h1><p>Link: <a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-parentheses/</a></p>
<p>Given a string containing just the characters <code>'(', ')'</code>, <code>'{', '}'</code>, <code>'[' and ']'</code>, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, <code>"()"</code> and <code>"()[]{}"</code> are all valid but <code>"(]"</code> and <code>"([)]"</code> are not.</p>
<hr>
<p>思路：借助vector容器，存放字符’(‘,’{‘,’[‘，从左到右的读取字符串的每一个字符，</p>
<ul>
<li><p>如果字符为上面给定的三个，则加入到vector中；</p>
</li>
<li><p>如果不是，在确保vector容器有字符的情况下，则让其和vector的最后一个比较；</p>
<ul>
<li>如果是匹配的，则将vector容器的大小缩减为size()-1；</li>
<li>如果不匹配，则返回false；</li>
</ul>
</li>
<li><p>最后，如果vector元素全部匹配完了，则返回true，否则返回false；</p>
</li>
</ul>
<p>代码如下（c++）：</p>
<figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool isValid(string s) {</span><br><span class="line">        vector&lt;<span class="built_in">char</span>&gt; <span class="built_in">str</span>;</span><br><span class="line">        <span class="built_in">int</span> len = s.length();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;len; i++){</span><br><span class="line">            <span class="keyword">if</span>(isThose(s[i])) {</span><br><span class="line">                <span class="built_in">str</span>.push_back(s[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>()&gt;<span class="number">0</span> &amp;&amp; isTrue(<span class="built_in">str</span>[<span class="built_in">str</span>.<span class="built_in">size</span>()<span class="number">-1</span>],s[i])) {</span><br><span class="line">                cout&lt;&lt;<span class="built_in">str</span>.<span class="built_in">size</span>()&lt;&lt;<span class="string">"f"</span>&lt;&lt;isTrue(<span class="built_in">str</span>[<span class="built_in">str</span>.<span class="built_in">size</span>()<span class="number">-1</span>],s[i])&lt;&lt;endl;</span><br><span class="line">                <span class="built_in">str</span>.resize(<span class="built_in">str</span>.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bool isThose(<span class="built_in">char</span> &amp;a){</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="string">'{'</span> || a == <span class="string">'('</span> || a == <span class="string">'['</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bool isTrue(<span class="built_in">char</span> &amp;a, <span class="built_in">char</span> &amp;b){</span><br><span class="line">        <span class="keyword">if</span>( a == <span class="string">'('</span> &amp;&amp; b == <span class="string">')'</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( a == <span class="string">'['</span> &amp;&amp; b == <span class="string">']'</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( a == <span class="string">'{'</span> &amp;&amp; b == <span class="string">'}'</span> ) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode[21]-Merge Two Sorted Lists"></a>Leetcode[21]-Merge Two Sorted Lists</h1><p>Link: <a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-two-sorted-lists/</a></p>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p><strong>思路</strong>：要求合并两个排好序的链表。开始我们初始化头front和尾tail，然后从两个单链表的头部比较两个单链表，两链表同时不为空的条件下递归比较：</p>
<ul>
<li>如果l1的值大于l2的值，就将尾部指向l1，并同步向右移动l1的头指针和tail指针</li>
<li>如果l1的值小于l2的值，就将尾部指向l2，并同步向右移动l2的头指针和tail指针</li>
</ul>
<p>接着，如果l1不为空，则将尾指针的下一个指向l1，如果l2不为空，则将尾指针的下一个指向l2，然后将front右移一位，</p>
<p>最后返回front即可。</p>
<p>Code(c++):</p>
<figure class="highlight ocaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">ListNode</span> {</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> *next;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), next(<span class="type">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> {</span><br><span class="line">public:</span><br><span class="line">    <span class="type">ListNode</span>* mergeTwoLists(<span class="type">ListNode</span>* l1, <span class="type">ListNode</span>* l2) {</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="type">NULL</span>) return l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="type">NULL</span>) return l1;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span>* front = <span class="keyword">new</span> <span class="type">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span>* tail = front;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( l1 &amp;&amp; l2){</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;<span class="keyword">val</span> &lt; l2-&gt;<span class="keyword">val</span>){</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(l1){</span><br><span class="line">            tail-&gt;next = l1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(l2){</span><br><span class="line">            tail-&gt;next = l2;</span><br><span class="line">        }</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        return front;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-26-Remove-Duplicates-from-Sorted-Array"><a href="#Leetcode-26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Leetcode[26]-Remove Duplicates from Sorted Array"></a>Leetcode[26]-Remove Duplicates from Sorted Array</h1><p>Link: <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
<hr>
<p><strong>思路</strong>：需要额外添加一个新的变量pos，初始值为0，用来记录非重复元素的位置。从数组的第二个元素开始遍历，如果和前面的元素相等，则直接跳到下一个；如果不等，则将该数组的值赋值给++pos位，接着继续遍历下一个；</p>
<p><strong>Code(c++):</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>,i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i<span class="number">-1</span>]){</span><br><span class="line">                i++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                nums[++pos] = nums[i++];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        n = pos+<span class="number">1</span>;</span><br><span class="line">        nums.resize(n);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>做个简单的修改：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>,i = <span class="number">1</span>;<span class="comment">//将pos从1开始</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i<span class="number">-1</span>]){</span><br><span class="line">                i++;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                nums[pos++] = nums[i++];<span class="comment">//这里保持一致</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        n = pos;</span><br><span class="line">        nums.resize(n);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Python代码</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pos = <span class="number">1</span>;i = <span class="number">1</span>;count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                i=i+<span class="number">1</span></span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[pos] = nums[i]</span><br><span class="line">                pos = pos+<span class="number">1</span></span><br><span class="line">                i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">            nums.pop(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-27-Remove-Element"><a href="#Leetcode-27-Remove-Element" class="headerlink" title="Leetcode[27]-Remove Element"></a>Leetcode[27]-Remove Element</h1><p>Link: <a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-element/</a></p>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<hr>
<p>思路：遍历数组，如果数组对应的数等于给定的值，数组最后一位和当前位互换，然后将数组长度减一；否则，就执行i++;最后重置数组长度。</p>
<p>Code(c++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> temp = *a;</span><br><span class="line">        *a = *b;</span><br><span class="line">        *b = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; n){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) {</span><br><span class="line">                swap(&amp;nums[i],&amp;nums[n<span class="number">-1</span>]);</span><br><span class="line">                n--;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                i++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        nums.resize(n);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-33-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode[33]-Search in Rotated Sorted Array"></a>Leetcode[33]-Search in Rotated Sorted Array</h1><p>Link: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<hr>
<p>C++:</p>
<p>方法一：直接for循环求解</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：二分搜索求解<br>分析：从中点处划分，左右两边一定有一部分是有序的，对于有序的分别做判断。</p>
<figure class="highlight fortran"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> search(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> <span class="keyword">target</span>) {</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>()-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j){</span><br><span class="line">            <span class="built_in">int</span> mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == <span class="keyword">target</span>) </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            //<span class="keyword">if</span> left is sorted</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt;= nums[mid]){</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= <span class="keyword">target</span> &amp;&amp; <span class="keyword">target</span> &lt; nums[mid]) </span><br><span class="line">                    j = mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; <span class="keyword">target</span> &amp;&amp; <span class="keyword">target</span> &lt;= nums[j] ) </span><br><span class="line">                    i = mid +<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    j = mid-<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-35-Search-Insert-Position"><a href="#Leetcode-35-Search-Insert-Position" class="headerlink" title="Leetcode[35]-Search Insert Position"></a>Leetcode[35]-Search Insert Position</h1><p>Link: <a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">https://leetcode.com/problems/search-insert-position/</a></p>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<pre><code>Here are few examples.
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0</code></pre><p>题目比较简单，直接给出答案吧<br>code(c++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n) {</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &gt;= target) {</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            ++i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-36-Valid-Sudoku"><a href="#Leetcode-36-Valid-Sudoku" class="headerlink" title="Leetcode[36]-Valid Sudoku"></a>Leetcode[36]-Valid Sudoku</h1><p>Link:<a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-sudoku/</a></p>
<p>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.<br><img src="http://img.blog.csdn.net/20150609210526658" alt="这里写图片描述"></p>
<p>A partially filled sudoku which is valid.</p>
<p>Note:<br>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
<hr>
<p>分析：验证一个数独的合法性，从三个方向入手</p>
<ul>
<li>每一行不能出现重复元素</li>
<li>每一列不能出现重复元素</li>
<li>每一个九方格不能出现重复元素</li>
</ul>
<p>我采用的是map来保存元素的数值，然后判断map中是否有，有则返回false；参数之间的关系推导如下：<br><img src="http://img.blog.csdn.net/20150609213752137" alt="这里写图片描述"><br><br>代码如下</p>
<p>Code(c++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        <span class="comment">//row</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i&lt;<span class="number">9</span>; i++) {</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">9</span>; j++){</span><br><span class="line">                <span class="keyword">if</span>(mp.find(board[i][j])!=mp.end())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)<span class="keyword">continue</span>;</span><br><span class="line">                mp[board[i][j]] = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//cow</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  j = <span class="number">0</span>; j&lt;<span class="number">9</span>; j++) {</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">9</span>; i++){</span><br><span class="line">                <span class="keyword">if</span>(mp.find(board[i][j])!=mp.end())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'.'</span>)<span class="keyword">continue</span>;</span><br><span class="line">                mp[board[i][j]] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//board</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++){</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = (i/<span class="number">3</span>)*<span class="number">3</span>; j &lt; <span class="number">3</span> + (i/<span class="number">3</span>)*<span class="number">3</span> ; j++){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = (<span class="number">3</span>*i)%<span class="number">9</span>; k &lt;= (<span class="number">3</span>*(i+<span class="number">1</span>)<span class="number">-1</span>)%<span class="number">9</span>; k++){</span><br><span class="line">                    <span class="keyword">if</span>(mp.find(board[j][k])!=mp.end())</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(board[j][k] == <span class="string">'.'</span>)<span class="keyword">continue</span>;</span><br><span class="line">                    mp[board[j][k]] = k;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-53-Maximum-Subarray"><a href="#Leetcode-53-Maximum-Subarray" class="headerlink" title="Leetcode[53]-Maximum Subarray"></a>Leetcode[53]-Maximum Subarray</h1><p>Link: <a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray/</a></p>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<p>More practice:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<hr>
<p>给定一个长度为n的序列，求其最大子序列和。<br>算法思路：使用动态规划求解，dp[i]表示在尾数在位置i上的最大子序列和，那么dp[i]可以表示为</p>
<ul>
<li>dp[i] = max(dp[i-1] + nums[i],nums[i])</li>
<li>dp[0] = nums[0]</li>
</ul>
<p>其中dp[0]表示初值。</p>
<p><strong>C++代码如下：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> answer = dp[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i){</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">            answer = max(answer,dp[i]);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Python代码如下：</strong></p>
<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def maxSubArray(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        :<span class="built_in">type</span> num<span class="variable">s:</span> List[<span class="keyword">int</span>]</span><br><span class="line">        :rtype: <span class="keyword">int</span></span><br><span class="line">        <span class="string">""</span><span class="comment">"</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">dp</span> = []</span><br><span class="line">        <span class="keyword">dp</span>.<span class="keyword">append</span>(ans)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">dp</span>.<span class="keyword">append</span>(<span class="built_in">max</span>(<span class="keyword">dp</span>[i-<span class="number">1</span>] + nums[i],nums[i]))</span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="keyword">dp</span>[i], ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-62-Unique-Paths"><a href="#Leetcode-62-Unique-Paths" class="headerlink" title="Leetcode[62]-Unique Paths"></a>Leetcode[62]-Unique Paths</h1><p>Link: <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-paths/</a></p>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="http://articles.leetcode.com/wp-content/uploads/2014/12/robot_maze.png" alt="这里写图片描述"></p>
<p>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
<hr>
<p>题目：给定一个m*n的矩阵，让机器人从左上方走到右下方，只能往下和往右走，一共多少种走法。</p>
<p>思路：采用动态规划设计思想，到第0列和第0行的任何位置都只有1种走法，即初始化为d[0][*] = 1,d[*][0] = 1;当机器人走到第i行第j列的时候，它的走法总数是等于第i-1行第j列的总数加上第i行第j-1列的总数，即dp [ i ] [ j ]  = d[i-1][j] + dp[i][j-1].代码如下:</p>
<p>Code(c++): </p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) {</span><br><span class="line">            dp[k][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; n; t++) {</span><br><span class="line">            dp[<span class="number">0</span>][t] = <span class="number">1</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++){</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-63-Unique-Paths-II"><a href="#Leetcode-63-Unique-Paths-II" class="headerlink" title="Leetcode[63]-Unique Paths II"></a>Leetcode[63]-Unique Paths II</h1><p>Link: <a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-paths-ii/</a></p>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]</code></pre><p>The total number of unique paths is 2.</p>
<p>题意：在上题的基础上增加了点限制条件，不过大体上还是差不多的，还是采用动态规划思想，找到初始值和递推关系，和上体相比较，只是初始化和到达dp[i][j]时要加点判断语句，</p>
<ul>
<li>第0列，从上到下，如果碰到一个1，则设置该位置和后面的位置都不可到达，即dp[i to n][0]；</li>
<li>第0行，从左到右，如果碰到一个1，则设置该位置和右方的位置都不可到达，即dp[0][i to n];</li>
<li>其它位置，如果该位置不为1，则到达该位置的方式共有 dp[i][j] = dp[i-1][j] + dp[i][j-1],如果为1，则dp[i][j] = 0；</li>
</ul>
<p>代码如下：</p>
<p>Code(c++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.size(),n = obstacleGrid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span> )dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        }  </span><br><span class="line">        </span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span> )dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        }    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++){</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>) obstacleGrid[i][j] = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-66-Plus-One"><a href="#Leetcode-66-Plus-One" class="headerlink" title="Leetcode[66]-Plus One"></a>Leetcode[66]-Plus One</h1><p>Link:<a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a></p>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<hr>
<p>题意：给定一个数组，表示的是非负数的各个位的数，现在将该数加一，求加一后得到的数组。</p>
<p>分析：由于加以后数组的长度可能发生变化，说以不能单纯的直接在数组后面加一。可以先将数组翻转，个位转到前面来，然后从前往后依次加一，最后判断如果在最后一位相加超过十了，就将数组长度加一，代码如下：</p>
<p>Code(c++):</p>
<figure class="highlight fortran"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; plusOne(vector&lt;<span class="built_in">int</span>&gt;&amp; <span class="built_in">digits</span>) {</span><br><span class="line">        <span class="built_in">int</span> n = <span class="built_in">digits</span>.<span class="built_in">size</span>();</span><br><span class="line">        reverse(<span class="built_in">digits</span>.begin(),<span class="built_in">digits</span>.<span class="keyword">end</span>());</span><br><span class="line">        <span class="built_in">int</span> temp = <span class="number">0</span>,flag = false;</span><br><span class="line">        for(<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;n ; i++) {</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) temp =<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="built_in">digits</span>[i] + temp;</span><br><span class="line">            <span class="built_in">digits</span>[i] = <span class="built_in">sum</span> %<span class="number">10</span>;</span><br><span class="line">            temp = <span class="built_in">sum</span>/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == n-<span class="number">1</span> &amp;&amp; <span class="built_in">sum</span> &gt;= <span class="number">10</span>)</span><br><span class="line">                flag = true;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(flag){</span><br><span class="line">            <span class="built_in">digits</span>.resize(n+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">digits</span>[n] = temp;</span><br><span class="line">        }</span><br><span class="line">        reverse(<span class="built_in">digits</span>.begin(),<span class="built_in">digits</span>.<span class="keyword">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">digits</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-70-Climbing-Stairs"><a href="#Leetcode-70-Climbing-Stairs" class="headerlink" title="Leetcode[70]-Climbing Stairs"></a>Leetcode[70]-Climbing Stairs</h1><p>Link: <a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode.com/problems/climbing-stairs/</a></p>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<hr>
<p>题意：给你一个n阶的台阶，你一次最多只能上2个台阶，请问一共有多少个走法？</p>
<p>分析：典型的斐波那契数列题目，可以使用递归求解，也可以使用DP方法求解；</p>
<p>i表示阶梯数，f(i)表示有多少种走法；</p>
<ul>
<li>当i = 1时，f(1) = 1,</li>
<li>当i = 2时，f(2) = 2;</li>
<li>当i &gt; 3时，f(i) = f(i-1) + f(i-2)。</li>
</ul>
<p>其实很容易理解，当阶梯数大于2时，它的走法可以是从n-1阶梯走一步，或是从n-2阶梯处一次走两步到达，即f(i) = f(i-1) + f(i-2)。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">2</span>) dp[i] = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-74-Search-a-2D-Matrix"><a href="#Leetcode-74-Search-a-2D-Matrix" class="headerlink" title="Leetcode[74]-Search a 2D Matrix"></a>Leetcode[74]-Search a 2D Matrix</h1><p>Link: <a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">https://leetcode.com/problems/search-a-2d-matrix/</a></p>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>For example,</p>
<p>Consider the following matrix:</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,   <span class="number">3</span>,  <span class="number">5</span>,  <span class="number">7</span>],</span><br><span class="line">  [<span class="number">10</span>, <span class="number">11</span>, <span class="number">16</span>, <span class="number">20</span>],</span><br><span class="line">  [<span class="number">23</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">50</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>Given target = 3, return true.</p>
<hr>
<p>这道题之前做过：<a href="http://blog.csdn.net/dream_angel_z/article/details/46413705" target="_blank" rel="noopener">查找特殊矩阵中的一个数</a></p>
<p>算法思路：</p>
<p>起始从右上角开始查找，a[i][j]初试值为a[0][n-1]，循环下列<br>while( i &lt; n &amp;&amp; j &gt;= 0)<br>如果key &lt; a[i][j],往左走，j–，<br>如果key &gt; a[i][j],则往下走，执行i++<br>如果key == a[i][j],表示找到了</p>
<p>C++代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.size(), n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; m &amp;&amp; j &gt;= <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>( target &lt; matrix[i][j] ) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; matrix[i][j] ) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-81-Search-for-a-Range"><a href="#Leetcode-81-Search-for-a-Range" class="headerlink" title="Leetcode[81]-Search for a Range"></a>Leetcode[81]-Search for a Range</h1><p>Link: <a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/search-in-rotated-sorted-array-ii/</a></p>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<hr>
<p>思路：首先初始化一个2列的数组，值为-1，然后一次遍历数组，设置一个变量作为标识，记录出现target值的下标，并保存到数组中，如果标识值等于=了，就不增加它的值，保证数组第二个元素是最后一个出现target的下标。</p>
<p>C++:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">2</span>);</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">-1</span>,res[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            <span class="keyword">if</span>(target == nums[i]){</span><br><span class="line">                <span class="keyword">if</span>(temp == <span class="number">2</span>)</span><br><span class="line">                    res[temp<span class="number">-1</span>] = i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res[temp++] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(temp ==<span class="number">1</span>) {</span><br><span class="line">            res[temp] = res[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode[82]-Remove Duplicates from Sorted List II"></a>Leetcode[82]-Remove Duplicates from Sorted List II</h1><p>Link: <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/</a></p>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given <code>1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</code>, return<code>1-&gt;2-&gt;5</code>.
Given <code>1-&gt;1-&gt;1-&gt;2-&gt;3</code>, return <code>2-&gt;3</code>.</p>
<hr>
<p>思路：跟上道题<a href="http://blog.csdn.net/dream_angel_z/article/details/46446067" target="_blank" rel="noopener">Leetcode[83]-Remove Duplicates from Sorted List</a>算法有点区别，这道题需要设置一个标示符，如果某一趟比较的时候两个元素相等了，就设flag等于true，接着下一趟循环如果两个元素不相等，但此时的flag为true，就需要将两个元素前面的那个删掉。</p>
<p>最后，必定第二个元素为空而终止，此时还需要判断flag是否为true，如果为true，则末尾的元素还需要删掉；</p>
<p>代码如下：<br>Code(c++):</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">       ListNode * newList = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        newList-&gt;next = head;</span><br><span class="line">        ListNode *pre = newList;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next){</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;next-&gt;val == pre-&gt;next-&gt;next-&gt;val){</span><br><span class="line">                pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>){</span><br><span class="line">                pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//最后还需要判断是否上次判断时元素重复</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>){</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        head = newList-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode[83]-Remove Duplicates from Sorted List"></a>Leetcode[83]-Remove Duplicates from Sorted List</h1><p>Link: <a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,</p>
<pre><code>Given 1-&gt;1-&gt;2, return 1-&gt;2.
Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</code></pre><hr>
<p>比较简单，直接贴代码了！</p>
<p>C++:</p>
<figure class="highlight ocaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">ListNode</span> {</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> *next;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), next(<span class="type">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> {</span><br><span class="line">public:</span><br><span class="line">    <span class="type">ListNode</span>* deleteDuplicates(<span class="type">ListNode</span>* head) {</span><br><span class="line">        <span class="type">ListNode</span> * pre = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre &amp;&amp; pre-&gt;next){</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;<span class="keyword">val</span> == pre-&gt;next-&gt;<span class="keyword">val</span>){</span><br><span class="line">                pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">                continue;</span><br><span class="line">            }</span><br><span class="line">            pre = pre-&gt;next;            </span><br><span class="line">        }</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意while循环的时候也要判断pre-&gt;next是否为空，如果为空就不用做判断了！</strong></p>
<hr>
<h1 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode[86]-Partition List"></a>Leetcode[86]-Partition List</h1><p>Link： <a href="https://leetcode.com/problems/partition-list/" target="_blank" rel="noopener">https://leetcode.com/problems/partition-list/</a></p>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
<hr>
<p>思路：设置两个临时单链表，一个存放小于x的链表，一个存放大于x的链表，然后遍历head，一次存入两个链表中，最后合并两个链表。</p>
<p>Code(c++):</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    ListNode* partition(ListNode* head, int x) {</span><br><span class="line">        <span class="keyword">if</span>(head == NULL |<span class="type">| head</span>-&gt;next==NULL) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *<span class="built_in">left</span> = new ListNode(<span class="number">-1</span>),*<span class="built_in">right</span> = new ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode *ltail = <span class="built_in">left</span>,* rtail = <span class="built_in">right</span>;</span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        while(pre){</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;val &lt; x) {</span><br><span class="line">                ltail-&gt;next = pre;</span><br><span class="line">                ltail = ltail-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                rtail-&gt;next = pre;</span><br><span class="line">                rtail = rtail-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">right</span>-&gt;next){</span><br><span class="line">            ltail-&gt;next = <span class="built_in">right</span>-&gt;next;</span><br><span class="line">            rtail-&gt;next = NULL;//<span class="built_in">set</span> rtail <span class="built_in">as</span> NULL, otherwise <span class="built_in">time</span> limited error</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">left</span> = <span class="built_in">left</span>-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">left</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-88-Merge-Sorted-Array"><a href="#Leetcode-88-Merge-Sorted-Array" class="headerlink" title="Leetcode[88]-Merge Sorted Array"></a>Leetcode[88]-Merge Sorted Array</h1><p>Link:<a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/merge-sorted-array/</a></p>
<p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<hr>
<p>分析：首先将nums1数组容量扩大到m+n,然后进行m+n-1次迭代，从后往前比较nums1和nums2的大小。</p>
<ul>
<li>如果nums1的值大于nums2的值，就将nums1的值放到nums1的最后一个；</li>
<li>如果nums2的值大于nums1的值，就将nums2的值放到nums1的最后一个；</li>
<li>……</li>
<li>依次迭代</li>
<li>……</li>
</ul>
<p>最后会必定有一个数组放完了，然后判断，哪个数组没放完，就接着放。</p>
<p>Code(c++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        nums1.resize(m+n);</span><br><span class="line">        <span class="keyword">int</span> j = m<span class="number">-1</span>, k = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m+n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">            <span class="keyword">if</span>(j &gt;=<span class="number">0</span> &amp;&amp; k &gt;= <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(nums1[j] &gt;= nums2[k]){</span><br><span class="line">                    nums1[i] = nums1[j--];</span><br><span class="line">                }<span class="keyword">else</span> <span class="keyword">if</span>(nums1[j] &lt; nums2[k]){</span><br><span class="line">                    nums1[i] = nums2[k--];</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;=<span class="number">0</span>){</span><br><span class="line">                nums1[i] = nums2[k--];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=<span class="number">0</span>){</span><br><span class="line">                nums1[i] = nums1[j--];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> s = m+n<span class="number">-1</span>;</span><br><span class="line">        nums1.resize(m+n);</span><br><span class="line">        <span class="keyword">int</span> i = m<span class="number">-1</span>,j = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &gt;= nums2[j]){</span><br><span class="line">                nums1[s--] = nums1[i--];</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt;nums2[j]){</span><br><span class="line">                nums1[s--] = nums2[j--];</span><br><span class="line">            }</span><br><span class="line">        }  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>){</span><br><span class="line">            nums1[s--] = nums2[j--];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>){</span><br><span class="line">            nums1[s--] = nums1[i--];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode[92]-Reverse Linked List II"></a>Leetcode[92]-Reverse Linked List II</h1><p>Link: <a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list-ii/</a></p>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
<hr>
<p><strong>思路</strong>：分别找到m节点和m的前节点，n节点和n的后节点，然后翻转m到n的部分，最后链接三部分成一个整体；代码如下</p>
<p><strong>Code(c++):</strong></p>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *<span class="built_in">next</span>;</span><br><span class="line"> *     ListNode(int x) : val(x), <span class="built_in">next</span>(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseBetween(ListNode* head, int m, int n) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == NULL) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *newList = new ListNode(<span class="number">-1</span>);</span><br><span class="line">        newList-&gt;<span class="built_in">next</span> = head;</span><br><span class="line"></span><br><span class="line">        ListNode *prebegin = newList;</span><br><span class="line">        ListNode *begin = head;</span><br><span class="line"></span><br><span class="line">        ListNode *<span class="keyword">end</span> = newList;</span><br><span class="line">        ListNode *postend = head;</span><br><span class="line">        </span><br><span class="line">        //begin as center start node</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">--m){</span></span><br><span class="line">            prebegin = prebegin-&gt;<span class="built_in">next</span>;</span><br><span class="line">            begin = begin-&gt;<span class="built_in">next</span>;</span><br><span class="line">        }</span><br><span class="line">        //<span class="keyword">end</span> as center <span class="keyword">end</span> node</span><br><span class="line">        <span class="keyword">while</span>(n<span class="comment">--){</span></span><br><span class="line">            <span class="keyword">end</span> = <span class="keyword">end</span>-&gt;<span class="built_in">next</span>;</span><br><span class="line">            postend = postend-&gt;<span class="built_in">next</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        //<span class="built_in">reverse</span> center part</span><br><span class="line">        <span class="built_in">reverse</span>(begin, <span class="keyword">end</span>);</span><br><span class="line">        //link three part as one list</span><br><span class="line">        prebegin-&gt;<span class="built_in">next</span> = begin;</span><br><span class="line">        <span class="keyword">end</span>-&gt;<span class="built_in">next</span> = postend;</span><br><span class="line">        </span><br><span class="line">        head = newList-&gt;<span class="built_in">next</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    void <span class="built_in">reverse</span>(ListNode*&amp; begin, ListNode*&amp; <span class="keyword">end</span>){</span><br><span class="line">        <span class="keyword">if</span>(begin == <span class="keyword">end</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin-&gt;<span class="built_in">next</span> == <span class="keyword">end</span>){</span><br><span class="line">            <span class="keyword">end</span>-&gt;<span class="built_in">next</span> = begin;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            //at least <span class="number">3</span> nodes</span><br><span class="line">            ListNode* pre = begin;</span><br><span class="line">            ListNode* cur = pre-&gt;<span class="built_in">next</span>;</span><br><span class="line">            ListNode* post = cur-&gt;<span class="built_in">next</span>;</span><br><span class="line">            <span class="keyword">while</span>(post != <span class="keyword">end</span>-&gt;<span class="built_in">next</span>){</span><br><span class="line">                cur-&gt;<span class="built_in">next</span> = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = post;</span><br><span class="line">                post = post-&gt;<span class="built_in">next</span>;</span><br><span class="line">            }</span><br><span class="line">            cur-&gt;<span class="built_in">next</span> = pre;</span><br><span class="line">        }</span><br><span class="line">        //swap begin <span class="keyword">and</span> <span class="keyword">end</span></span><br><span class="line">        ListNode* temp = begin;</span><br><span class="line">        begin = <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span> = temp;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-94-Binary-Tree-Inorder-Traversal"><a href="#Leetcode-94-Binary-Tree-Inorder-Traversal" class="headerlink" title="Leetcode[94]-Binary Tree Inorder Traversal"></a>Leetcode[94]-Binary Tree Inorder Traversal</h1><p>Link: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">2</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>return<code>[1,3,2]</code>.</p>
<hr>
<p>递归遍历法C++：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) {</span><br><span class="line">        result.clear();</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root-&gt;left);</span><br><span class="line">        result.push_back(root-&gt;val);</span><br><span class="line">        inorder(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>非递归算法1：</p>
<figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; inorderTraversal(TreeNode* root) {</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; result;  </span><br><span class="line">        stack&lt;TreeNode *&gt; myStack;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)  </span><br><span class="line">            return result;  </span><br><span class="line">        TreeNode *p = root;  </span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span> || !myStack.<span class="literal">empty</span>()) {  </span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) {  </span><br><span class="line">                myStack.push(p);  </span><br><span class="line">                p = p-&gt;<span class="built_in">left</span>;  </span><br><span class="line">            }  </span><br><span class="line">            <span class="keyword">if</span> (!myStack.<span class="literal">empty</span>())  {  </span><br><span class="line">                p = myStack.top();  </span><br><span class="line">                myStack.pop();  </span><br><span class="line">                result.push_back(p-&gt;val);  </span><br><span class="line">                p = p-&gt;<span class="built_in">right</span>;  </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;  </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>非递归遍历方法二：(递归条件只需要判断栈是否为空)<br>在递归条件中，</p>
<ul>
<li>首先取出栈顶节点，如果不为空的话，就把它的左节点进栈，然后再取栈顶元素，如果不为空，则再让它的左节点进栈，直到栈顶元素是空的节点为止；</li>
<li>然后让栈顶的空指针退栈</li>
<li>接着判断栈是否为空，如果不为空，则栈顶节点出栈，并将栈顶元素的值加入到数组中，然后把该节点的右节点入栈（右节点是否是空的，此处不做判断，内部的while循环会判断，因为内while循环后的栈顶节点必定是空指针）</li>
</ul>
<p>最后，返回数组即可。</p>
<figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; inorderTraversal(TreeNode* root) {</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) return result; </span><br><span class="line">        </span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="literal">empty</span>()){</span><br><span class="line">            <span class="keyword">while</span>((p = stk.top()) &amp;&amp; p){</span><br><span class="line">                stk.push(p-&gt;<span class="built_in">left</span>);</span><br><span class="line">            }</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(!stk.<span class="literal">empty</span>()){</span><br><span class="line">                p = stk.top();</span><br><span class="line">                result.push_back(p-&gt;val);</span><br><span class="line">                stk.pop();</span><br><span class="line">                p = p-&gt;<span class="built_in">right</span>;</span><br><span class="line">                stk.push(p);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-96-Unique-Binary-Search-Trees"><a href="#Leetcode-96-Unique-Binary-Search-Trees" class="headerlink" title="Leetcode[96]-Unique Binary Search Trees"></a>Leetcode[96]-Unique Binary Search Trees</h1><p>Link: <a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">https://leetcode.com/problems/unique-binary-search-trees/</a></p>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<pre><code>1         3     3      2      1
 \       /     /      / \      \
  3     2     1      1   3      2
 /     /       \                 \
2     1         2                 3</code></pre><p><strong>思路：</strong> 动态规划解题，dp[n]表示n个节点可以有dp[n]种不同的树，不管n为多少，先固定一个节点，剩余n-1个节点，分配给左右字数，然后把左子树个数乘以右子树的个数，</p>
<ul>
<li>初始值dp[0] = 1,dp[1] = 1,</li>
<li>dp[n] = dp[0] * dp[n-1] + dp[1] * dp[n-2] + …+ dp[i] * dp[n-1-i] +… + dp[n-1] * dp[0]，也就是左边i个节点，右边n-1-i个节点。代码如下：</li>
</ul>
<p><strong>Code(c++):</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        dp.resize(n+<span class="number">1</span>);<span class="comment">//set  the length of vector to n+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) {</span><br><span class="line">	        <span class="comment">//dp[0] = 1 , dp[1] =1</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">2</span>){</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//dp[n] = dp[0]*dp[n-1]+dp[1]*dp[n-2]+...+dp[n-1]*dp[0]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=i; j++) {</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>]*dp[i-j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-98-Validate-Binary-Search-Tree"><a href="#Leetcode-98-Validate-Binary-Search-Tree" class="headerlink" title="Leetcode[98]-Validate Binary Search Tree"></a>Leetcode[98]-Validate Binary Search Tree</h1><p>Link: <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/validate-binary-search-tree/</a></p>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.<br>confused what “{1,#,2,3}” means? &gt; read more on how binary tree is serialized on OJ.</p>
<hr>
<p>思路：递归方法，对于根结点</p>
<ul>
<li>如果有左子树，比较根结点与左子树的最大值，如果小于等于则返回false；</li>
<li>如果有右子树，比较根结点与右子树的最小值 ，如果大于等于则返回false；</li>
<li>接着判断左子树和右子树是否也是合法的二叉搜索树；</li>
</ul>
<p>Code(c++):</p>
<figure class="highlight zephir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isValidBST(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;val &lt;= leftMax(root-&gt;left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;val &gt;= rightMin(root-&gt;right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//get the left tree max value</span></span><br><span class="line">    <span class="keyword">int</span> leftMax(TreeNode *root){</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> max = root-&gt;val;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> lmax = leftMax(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rmax = leftMax(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> max1 = lmax&gt;rmax?lmax:rmax;</span><br><span class="line">        <span class="keyword">return</span> max&gt;max1?max:max1;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//get the right tree minimum value</span></span><br><span class="line">    <span class="keyword">int</span> rightMin(TreeNode *root){</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> max = root-&gt;val;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> lmin = rightMin(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rmin = rightMin(root-&gt;right);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> max1 = lmin&gt;rmin? rmin:lmin;</span><br><span class="line">        <span class="keyword">return</span> max&gt;max1?max1:max;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-100-Same-Tree"><a href="#Leetcode-100-Same-Tree" class="headerlink" title="Leetcode[100]-Same Tree"></a>Leetcode[100]-Same Tree</h1><p>Link: <a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/same-tree/</a></p>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<hr>
<p>思路：递归法判断<br>假设两棵树根结点为p和q</p>
<ul>
<li>如果p和q都为空，则返回true；否则，</li>
<li>如果p和q都非空，并且他们的值都相等，则判断其左右子树是否是相似树；否则</li>
<li>返回false；</li>
</ul>
<p>代码如下(C++)：</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) {</span><br><span class="line">        <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &amp;&amp; q &amp;&amp; (p-&gt;val == q-&gt;val)){</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p-&gt;<span class="built_in">left</span>,q-&gt;<span class="built_in">left</span>) &amp;&amp; isSameTree(p-&gt;<span class="built_in">right</span>,q-&gt;<span class="built_in">right</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-101-Symmetric-Tree"><a href="#Leetcode-101-Symmetric-Tree" class="headerlink" title="Leetcode[101]-Symmetric Tree"></a>Leetcode[101]-Symmetric Tree</h1><p>Link: <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/</a></p>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<figure class="highlight livescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span> / <span class="string">\</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">But the following <span class="keyword">is</span> not:</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   <span class="string">\</span>   <span class="string">\</span></span><br><span class="line">   <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<hr>
<p>思路：从左右两边同时执行DFS，同步进栈出栈，如果发现不匹配，则返回false,最后如果匹配后，栈中还剩有节点，则也返回false，否则返回true。</p>
<p>Code（c++）：</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    bool isSymmetric(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root==NULL) <span class="keyword">return</span> true;</span><br><span class="line">        </span><br><span class="line">        TreeNode* p = root,*q = root;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk,stk2;//define two stack to save node</span><br><span class="line">        stk.push(p);</span><br><span class="line">        stk2.push(q);</span><br><span class="line">        //<span class="keyword">if</span> both of stk and stk2 is not empty </span><br><span class="line">        while(!stk.empty() &amp;&amp; !stk2.empty() ){</span><br><span class="line">	        //p go <span class="built_in">left</span>,q go <span class="built_in">right</span></span><br><span class="line">            while(p-&gt;<span class="built_in">left</span> &amp;&amp; q-&gt;<span class="built_in">right</span>){</span><br><span class="line">                p = p-&gt;<span class="built_in">left</span>;</span><br><span class="line">                stk.push(p);</span><br><span class="line">                q = q-&gt;<span class="built_in">right</span>;</span><br><span class="line">                stk2.push(q);</span><br><span class="line">            }</span><br><span class="line">            //next line is very important to this method </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;<span class="built_in">left</span> |<span class="type">| q</span>-&gt;<span class="built_in">right</span>) <span class="keyword">return</span> false;</span><br><span class="line">            </span><br><span class="line">            //both of stk and stk2 is not empty,pop from  stack and judge p's <span class="built_in">right</span> node and q's <span class="built_in">left</span> node</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty() &amp;&amp; !stk2.empty()){</span><br><span class="line">                p = stk.<span class="built_in">top</span>();</span><br><span class="line">                q = stk2.<span class="built_in">top</span>();</span><br><span class="line">                stk.pop();</span><br><span class="line">                stk2.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> false;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(p-&gt;<span class="built_in">right</span>) stk.push(p-&gt;<span class="built_in">right</span>);</span><br><span class="line">                <span class="keyword">if</span>(q-&gt;<span class="built_in">left</span>) stk2.push(q-&gt;<span class="built_in">left</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!stk.empty() |<span class="type">| !stk2</span>.empty()) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> true;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-102-Binary-Tree-Level-Order-Traversal"><a href="#Leetcode-102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="Leetcode[102]-Binary Tree Level Order Traversal"></a>Leetcode[102]-Binary Tree Level Order Traversal</h1><p>Link: <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal/</a></p>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>return its level order traversal as:</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]</code></pre><hr>
<p><strong>思路</strong>： 使用层序遍历，一层一层的出队，并将节点值放入数组中；</p>
<p>代码C++：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; levelOrder(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; que;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        que.push(p);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty()){</span><br><span class="line">            <span class="keyword">int</span> queSize = que.size();</span><br><span class="line">            nums.resize(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queSize; i++){</span><br><span class="line">                p = que.front();</span><br><span class="line">                nums.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left) que.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right) que.push(p-&gt;right);</span><br><span class="line">                que.pop();</span><br><span class="line">            }</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>有问题，来一起讨论吧!</p>
<hr>
<h1 id="Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="Leetcode[103]-Binary Tree Zigzag Level Order Traversal"></a>Leetcode[103]-Binary Tree Zigzag Level Order Traversal</h1><p>Link: <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/</a></p>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>return its zigzag level order traversal as:</p>
<pre><code>[
  [3],
  [20,9],
  [15,7]
]</code></pre><hr>
<p>思路：使用层序遍历，借助队列，依次遍历每层，如果层数为偶数，则将该层的数字翻转，使用vector的reverse函数即可。</p>
<p>代码Code （C++）：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; que;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        que.push(p);       </span><br><span class="line">        <span class="keyword">int</span> level  = <span class="number">0</span>; <span class="comment">// curent level</span></span><br><span class="line">        <span class="keyword">while</span>(!que.empty()){</span><br><span class="line">            nums.resize(<span class="number">0</span>);</span><br><span class="line">            level += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> queSize = que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queSize; i++ ) {</span><br><span class="line">                p = que.front();</span><br><span class="line">                nums.push_back(p-&gt;val);</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left) que.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right) que.push(p-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(level % <span class="number">2</span> == <span class="number">0</span>) reverse(nums.begin(),nums.end());</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>  res;         </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-104-Maximum-Depth-of-Binary-Tree"><a href="#Leetcode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode[104]-Maximum Depth of Binary Tree"></a>Leetcode[104]-Maximum Depth of Binary Tree</h1><p>Link: <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<hr>
<p>求最大深度，用递归的方法</p>
<p>C++:</p>
<figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maxDepth(TreeNode* root) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) return <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> ldepth = <span class="number">0</span>,rdepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>!=<span class="literal">NULL</span>){</span><br><span class="line">            ldepth = maxDepth(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>!=<span class="literal">NULL</span>){</span><br><span class="line">            rdepth = maxDepth(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        }</span><br><span class="line">        return ldepth&gt;rdepth?ldepth+<span class="number">1</span>:rdepth+<span class="number">1</span>;   </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-107-Binary-Tree-Level-Order-Traversal-II"><a href="#Leetcode-107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="Leetcode[107]-Binary Tree Level Order Traversal II"></a>Leetcode[107]-Binary Tree Level Order Traversal II</h1><p>Link: <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</a></p>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7</code></pre><p>return its bottom-up level order traversal as:</p>
<pre><code>[
  [15,7],
  [9,20],
  [3]
]</code></pre><hr>
<p>使用BFS层序遍历，然后得到的vector数组使用reverse反转即可。</p>
<p>Code(c++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; que;</span><br><span class="line">        </span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        que.push(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.empty()){ </span><br><span class="line">            <span class="keyword">int</span> queSize = que.size();</span><br><span class="line">            nums.resize(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queSize; i++) {</span><br><span class="line">                p = que.front();</span><br><span class="line">                nums.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;left) que.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right) que.push(p-&gt;right);</span><br><span class="line">                que.pop();</span><br><span class="line">            }</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        }</span><br><span class="line">        reverse(res.begin(),res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-110-Balanced-Binary-Tree"><a href="#Leetcode-110-Balanced-Binary-Tree" class="headerlink" title="Leetcode[110]-Balanced Binary Tree"></a>Leetcode[110]-Balanced Binary Tree</h1><p>Link: <a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/balanced-binary-tree/</a></p>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<hr>
<p>判断一棵树是否属于平衡二叉树</p>
<p>判断主节点的左右节点深度大小差，如果不在【-1,1】内，返回false，否则，继续判断其左右节点是否属于平衡二叉树；</p>
<p>只要有不满足的，就返回false</p>
<p>Code(C++):</p>
<figure class="highlight zephir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isBalanced(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ldepth = getDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rdepth = getDepth(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ldepth - rdepth &gt; <span class="number">1</span> || ldepth - rdepth &lt; <span class="number">-1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//get node's depth</span></span><br><span class="line">    <span class="keyword">int</span> getDepth(TreeNode *root){</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> ldepth=<span class="number">0</span>,rdepth=<span class="number">0</span>;</span><br><span class="line">        ldepth = getDepth(root-&gt;left);</span><br><span class="line">        rdepth = getDepth(root-&gt;right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> ldepth &gt; rdepth ? ldepth+<span class="number">1</span>:rdepth+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-111-Minimum-Depth-of-Binary-Tree"><a href="#Leetcode-111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="Leetcode[111]-Minimum Depth of Binary Tree"></a>Leetcode[111]-Minimum Depth of Binary Tree</h1><p>Link: <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-depth-of-binary-tree/</a></p>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<hr>
<p>C++:</p>
<p>递归法</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    int minDepth(TreeNode* root) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; !root-&gt;<span class="built_in">right</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        int dleft=<span class="number">0</span>,dright=<span class="number">0</span>,dmin = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>) dleft = minDepth(root-&gt;<span class="built_in">left</span>) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>) dright = minDepth(root-&gt;<span class="built_in">right</span>) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; root-&gt;<span class="built_in">right</span>) <span class="keyword">return</span> dright;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">right</span> &amp;&amp; root-&gt;<span class="built_in">left</span>) <span class="keyword">return</span> dleft;</span><br><span class="line">        </span><br><span class="line">        dmin = dleft&gt;dright?dright:dleft; </span><br><span class="line">        <span class="keyword">return</span> dmin;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-113-Path-Sum-II"><a href="#Leetcode-113-Path-Sum-II" class="headerlink" title="Leetcode[113]-Path Sum II"></a>Leetcode[113]-Path Sum II</h1><p>Link: <a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/path-sum-ii/</a></p>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1</code></pre><p>return</p>
<pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]</code></pre><hr>
<p>思路：使用深度优先遍历，需要</p>
<ul>
<li>一个map，保存节点是否出栈过；</li>
<li>一个一维数组，保存根结点到当前节点的路径；</li>
<li>一个二维数组，保存根结点到当前叶节点的和等于给定sum的路径集合；</li>
<li>一个栈，用来辅助深度优先遍历；</li>
</ul>
<p>按照深度优先的遍历方式遍历，</p>
<ul>
<li>进栈的时候元素同时添加到一维数组中，并将该节点的map值设置为0,</li>
<li>当节点左右节点都为空的时候，判断一维数组里面的数据和是否等于给定sum，如果等于就把它丢到二维数组中，同时执行下一步出栈；</li>
<li>出栈的时候也同时缩小一维数组的长度，并将该节点的map值设置为1，表示该节点不能再次进栈了；</li>
</ul>
<p>Code（c++）：非递归算法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">map</span>&lt;TreeNode *, <span class="keyword">int</span>&gt; visited;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stk;</span><br><span class="line">        </span><br><span class="line">        TreeNode* p = root;</span><br><span class="line">        nums.push_back(p-&gt;val);</span><br><span class="line">        stk.push(p);</span><br><span class="line">        visited[p] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()){</span><br><span class="line">            p = stk.top();</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;left &amp;&amp; visited[p] == <span class="number">0</span>){</span><br><span class="line">	            <span class="comment">//this is very important to break this while</span></span><br><span class="line">                <span class="keyword">if</span>(visited[p-&gt;left]==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">                nums.push_back(p-&gt;val);</span><br><span class="line">                stk.push(p);</span><br><span class="line">                visited[p] = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()){</span><br><span class="line">                p = stk.top();</span><br><span class="line">                <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right &amp;&amp; sumVector(nums) == sum){</span><br><span class="line">                    res.push_back(nums);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>( p-&gt;right &amp;&amp; (visited.find(p-&gt;right) == visited.end() || visited[p-&gt;right] == <span class="number">0</span>)){</span><br><span class="line">                    p = p-&gt;right;</span><br><span class="line">                    stk.push(p);</span><br><span class="line">                    nums.push_back(p-&gt;val);</span><br><span class="line">                    visited[p] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                visited[p] = <span class="number">1</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">                nums.resize(nums.size()<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>递归方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        getPath(result,nums,sum,<span class="number">0</span>,root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, TreeNode *root)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(sum == target &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right){</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        getPath(res, nums, target, sum, root-&gt;left);</span><br><span class="line">        getPath(res, nums, target, sum, root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        nums.pop_back();</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-114-Flatten-Binary-Tree-to-Linked-List"><a href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="Leetcode[114]-Flatten Binary Tree to Linked List"></a>Leetcode[114]-Flatten Binary Tree to Linked List</h1><p>Link: <a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>   1
   / \
  2   5
 / \   \
3   4   6</code></pre><p>The flattened tree should look like:</p>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6</code></pre><hr>
<p>*<em>思路: *</em>  首先找到根节点左节点的最右子节点，然后把根节点的右子树移到左子树的最右端；接着把根结点的左子树移到右节点上，并将左子树置为空树，同时将根结点往右下移一个节点，依次递归即可。代码如下：</p>
<p>Code(c++):</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    void flatten(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        while(root){</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> &amp;&amp; root-&gt;<span class="built_in">right</span>){</span><br><span class="line">                TreeNode *p = root-&gt;<span class="built_in">left</span>;</span><br><span class="line">                while(p-&gt;<span class="built_in">right</span>) </span><br><span class="line">                    p =p-&gt;<span class="built_in">right</span>;</span><br><span class="line">                p-&gt;<span class="built_in">right</span> = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>)</span><br><span class="line">                root-&gt;<span class="built_in">right</span> = root-&gt;<span class="built_in">left</span>;</span><br><span class="line">            root-&gt;<span class="built_in">left</span> = NULL;</span><br><span class="line">            root = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-118-Pascal’s-Triangle"><a href="#Leetcode-118-Pascal’s-Triangle" class="headerlink" title="Leetcode[118]-Pascal’s Triangle"></a>Leetcode[118]-Pascal’s Triangle</h1><p>Link: <a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">https://leetcode.com/problems/pascals-triangle/</a></p>
<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<p>分析：</p>
<ul>
<li>第j=0列全为1，第j==i列时，都为1</li>
<li>其它列<ul>
<li>a[2][1] = a[1][0]+a[1][1]</li>
<li>a[3][1] = a[2][0]+a[2][1]</li>
<li>a[3][2] = a[2][1]+a[2][2]</li>
<li>……</li>
<li>推算得出</li>
<li>……</li>
<li>a[i][j] = a[i-1][j-1]+a[i-1][j]</li>
</ul>
</li>
</ul>
<p><strong>代码（c++）：</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) {</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec(numRows);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) {</span><br><span class="line">            vec[i].resize(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i ; j++){</span><br><span class="line">                <span class="keyword">if</span>(j==i || j==<span class="number">0</span>)</span><br><span class="line">                    vec[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>{</span><br><span class="line">                    vec[i][j] = vec[i<span class="number">-1</span>][j<span class="number">-1</span>] + vec[i<span class="number">-1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码（Python）：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        b=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows):</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">                    temp.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j &lt; i:</span><br><span class="line">                        temp.append(b[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i<span class="number">-1</span>][j])</span><br><span class="line">                    <span class="keyword">elif</span> j==i:</span><br><span class="line">                        temp.append(<span class="number">1</span>)</span><br><span class="line">            b.append(temp)</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-119-Pascal’s-Triangle-II"><a href="#Leetcode-119-Pascal’s-Triangle-II" class="headerlink" title="Leetcode[119]-Pascal’s Triangle II"></a>Leetcode[119]-Pascal’s Triangle II</h1><p>Link: <a href="https://leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/pascals-triangle-ii/</a></p>
<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].</p>
<p>Note:<br>Could you optimize your algorithm to use only O(k) extra space?</p>
<hr>
<p>分析：通过递归设置vector的值，变量i表示当前行数，同时根据行数可以得到当前的vector元素个数。如果我们从前往后遍历，当i增加的时候，我们的num[j] = num[j] + num[j-1]就会出问题，因为num[j+1]=num[j+1]+num[j],而num[j]已经更新了。</p>
<p>所以这里采用的是从后往前遍历，num[j] = num[j] + num[j-1],这样num[j-1] = num[j-1] + num[j-2]，不会受到前面的num[j]的变化而变化。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(rowIndex+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++){</span><br><span class="line">            nums[i] =<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j--){</span><br><span class="line">                nums[j] = nums[j] + nums[j<span class="number">-1</span>];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Python代码</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rowIndex: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> rowIndex &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rowIndex+<span class="number">1</span>):</span><br><span class="line">            a = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j==<span class="number">0</span>:</span><br><span class="line">                    a.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> j &lt; i:</span><br><span class="line">                        a.append(nums[i<span class="number">-1</span>][j<span class="number">-1</span>]+nums[i<span class="number">-1</span>][j])</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        a.append(<span class="number">1</span>)</span><br><span class="line">            nums.append(a)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">-1</span>]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-125-Valid-Palindrome"><a href="#Leetcode-125-Valid-Palindrome" class="headerlink" title="Leetcode[125]-Valid Palindrome"></a>Leetcode[125]-Valid Palindrome</h1><p>Link: <a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-palindrome/</a></p>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<figure class="highlight ada"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">For</span> example,</span><br><span class="line"><span class="string">"A man, a plan, a canal: Panama"</span> <span class="keyword">is</span> a palindrome.</span><br><span class="line"><span class="string">"race a car"</span> <span class="keyword">is</span> <span class="keyword">not</span> a palindrome.</span><br></pre></td></tr></tbody></table></figure>

<p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
<hr>
<p> 思路：定义两个标示符，一个指向字符串前面，一个指向字符串末尾，如果前后位置的字符不是字母或是数字，则直接跳过该字符，如果是大写，则转换成小写再比较，如果碰到不匹配的直接返回false。</p>
<p>Code(C++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>){  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = length<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j){</span><br><span class="line">            <span class="keyword">if</span>(!isStr(s[i])) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isStr(s[j])) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i++] != s[j--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isStr</span><span class="params">(<span class="keyword">char</span> &amp;a)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="string">'0'</span> &amp;&amp; a &lt;= <span class="string">'9'</span> ) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(a &gt;= <span class="string">'a'</span> &amp;&amp; a &lt;= <span class="string">'z'</span> ) {</span><br><span class="line">            a -= <span class="number">32</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(a &gt;= <span class="string">'A'</span> &amp;&amp; a &lt;= <span class="string">'Z'</span> ) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-128-Longest-Consecutive-Sequence"><a href="#Leetcode-128-Longest-Consecutive-Sequence" class="headerlink" title="Leetcode[128]-Longest Consecutive Sequence"></a>Leetcode[128]-Longest Consecutive Sequence</h1><p>Link:<a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-consecutive-sequence/</a></p>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<hr>
<p>思路：跟最大连续子序列和的思路类似，采用DP思想。设置一个长度为n的数组dp[n]，dp[i]表示在下标为i的时候，当前最大连续序列的长度为dp[i]，最后找到dp[i]中最大的那个值即可。</p>
<p>C++:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==(nums[i<span class="number">-1</span>]+<span class="number">1</span>))dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[i<span class="number">-1</span>]){</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                dp[i]=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> maxl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n;j++){</span><br><span class="line">            maxl = max(maxl,dp[j]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-129-Sum-Root-to-Leaf-Numbers"><a href="#Leetcode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="Leetcode[129]-Sum Root to Leaf Numbers"></a>Leetcode[129]-Sum Root to Leaf Numbers</h1><p>Link: <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a></p>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<p>The root-to-leaf path 1-&gt;2 represents the number 12.<br>The root-to-leaf path 1-&gt;3 represents the number 13.</p>
<p>Return the sum = 12 + 13 = 25.</p>
<hr>
<p>这道题让我真的醉了，先说下思路吧。</p>
<p>先求出每个叶子节点的值，然后将这些值相加。求叶子节点的值可以通过深度优先遍历，一遍往下，一遍增加各个节点的值，如果是叶子节点就将数组值的和加入到一个只有叶子节点的数组中，最后求这个只有叶子节点的数组的值得和。从头到尾自己写的代码，可以AC了，还没有进行优化，先做到这里吧。</p>
<p>代码（C++）：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//return sum of newleafValue</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = saveLeafNums(root);</span><br><span class="line">        <span class="keyword">return</span> sumV(nums);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//save leftnode to vector</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; saveLeafNums(TreeNode * root){</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,nodeValue;</span><br><span class="line">        <span class="keyword">int</span> eachSum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stk;</span><br><span class="line">        <span class="built_in">map</span>&lt;TreeNode *, <span class="keyword">int</span>&gt; visited;</span><br><span class="line">    </span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">    </span><br><span class="line">        stk.push(p);</span><br><span class="line">        visited[p] = <span class="number">0</span>;</span><br><span class="line">        nodeValue.push_back(p-&gt;val);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(!stk.empty()){</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;left &amp;&amp; visited[p]==<span class="number">0</span> ){</span><br><span class="line">	            <span class="comment">//if this node is visited,break </span></span><br><span class="line">                <span class="keyword">if</span>(visited[p-&gt;left]==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">                stk.push(p);</span><br><span class="line">                visited[p] = <span class="number">0</span>;</span><br><span class="line">                tenMutilVector(nodeValue);<span class="comment">//enlarge vector element's value</span></span><br><span class="line">                nodeValue.push_back(p-&gt;val);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(!stk.empty()) {</span><br><span class="line">                p = stk.top();</span><br><span class="line">                <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right){</span><br><span class="line">                    nums.push_back(sumV(nodeValue));</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(p-&gt;right &amp;&amp; (visited.find(p-&gt;right)==visited.end() || visited[p-&gt;right]==<span class="number">0</span>)){</span><br><span class="line">                    p = p-&gt;right;</span><br><span class="line">                    stk.push(p);</span><br><span class="line">                    visited[p] = <span class="number">0</span>;</span><br><span class="line">                    tenMutilVector(nodeValue);</span><br><span class="line">                    nodeValue.push_back(p-&gt;val);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                visited[p] = <span class="number">1</span>;</span><br><span class="line">                stk.pop();</span><br><span class="line">                tenDivideVector(nodeValue);</span><br><span class="line">                nodeValue.resize(nodeValue.size()<span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tenMutilVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            nums[i] *= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tenDivideVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            nums[i] /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> sumValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            sumValue += nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sumValue;</span><br><span class="line">    }   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>附加一个求深度的代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ldepth = <span class="number">0</span>,rdepth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ldepth = getDepth(root-&gt;left);</span><br><span class="line">    rdepth = getDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ldepth&gt;rdepth?ldepth+<span class="number">1</span>:rdepth+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：（递归法）</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    int sumNumbers(TreeNode* root) {</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span>;</span><br><span class="line">        sumStep(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>;</span><br><span class="line">    }</span><br><span class="line">private:</span><br><span class="line">    int <span class="built_in">sum</span>;</span><br><span class="line">    void sumStep(TreeNode *root, int num){</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; !root-&gt;<span class="built_in">right</span>) {</span><br><span class="line">            <span class="built_in">sum</span> = <span class="built_in">sum</span> + num*<span class="number">10</span> + root-&gt;val;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            sumStep(root-&gt;<span class="built_in">left</span>, num*<span class="number">10</span> + root-&gt;val);</span><br><span class="line">            sumStep(root-&gt;<span class="built_in">right</span>, num*<span class="number">10</span> + root-&gt;val);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-136-Single-Number"><a href="#Leetcode-136-Single-Number" class="headerlink" title="Leetcode[136]-Single Number"></a>Leetcode[136]-Single Number</h1><p>Lind:<a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number/</a></p>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<hr>
<p>分析：首先对数组进行排序，然后从开始进行两两比较，如果两个相等，则以步长为2往后比较，如果不相等，则返回第一个值。代码如下：</p>
<p>Code(c++)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n) {</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line">                i = i+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-137-Single-Number-II"><a href="#Leetcode-137-Single-Number-II" class="headerlink" title="Leetcode[137]-Single Number II"></a>Leetcode[137]-Single Number II</h1><p>Link:<a href="https://leetcode.com/problems/single-number-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-ii/</a></p>
<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<hr>
<p>思路：先排序，然后一对一对的进行比较.</p>
<p>C++</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n<span class="number">-2</span>){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=nums[i+<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                i = i + <span class="number">3</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-141-Linked-List-Cycle"><a href="#Leetcode-141-Linked-List-Cycle" class="headerlink" title="Leetcode[141]-Linked List Cycle"></a>Leetcode[141]-Linked List Cycle</h1><p>Link:<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a></p>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<hr>
<p><strong>分析：</strong>设置两个临时指针，一个一次走一步，一个一次走两步，如果再次相遇，表示有环。</p>
<p><strong>Code(c++):</strong></p>
<figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode *<span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) : val(x), <span class="keyword">next</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool hasCycle(ListNode *head) {</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;<span class="keyword">next</span>==<span class="literal">NULL</span>) return <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *first = head,*<span class="built_in">second</span> = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">second</span>!=<span class="literal">NULL</span> &amp;&amp; <span class="built_in">second</span>-&gt;<span class="keyword">next</span>!=<span class="literal">NULL</span>){</span><br><span class="line">            <span class="built_in">second</span> = <span class="built_in">second</span>-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;  </span><br><span class="line">            first = first-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(first == <span class="built_in">second</span>)</span><br><span class="line">                return <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode[143]-Reorder List"></a>Leetcode[143]-Reorder List</h1><p>Link: <a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reorder-list/</a></p>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
<hr>
<p>思路：将列表分成两半，然后把后一半翻转，最后一个一个构成新链表。</p>
<p>C++:</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:<span class="type"></span></span><br><span class="line"><span class="type"></span></span><br><span class="line"><span class="type">    void reorderList</span>(ListNode* head) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head==NULL || head-&gt;next==NULL) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *mid = getMid(head);</span><br><span class="line">        ListNode *left = head,*right = reverseList(mid-&gt;next);</span><br><span class="line">        </span><br><span class="line">        mid-&gt;next = NULL;</span><br><span class="line">        </span><br><span class="line">        ListNode* <span class="keyword">new</span><span class="type">Head</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* <span class="keyword">new</span><span class="type">Tail</span> = <span class="keyword">new</span><span class="type">Head</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &amp;&amp; right){</span><br><span class="line">            ListNode *temp = left-&gt;next;</span><br><span class="line">            left-&gt;next = <span class="keyword">new</span><span class="type">Tail</span>-&gt;next;</span><br><span class="line">            <span class="keyword">new</span><span class="type">Tail</span>-&gt;next = left;</span><br><span class="line">            <span class="keyword">new</span><span class="type">Tail</span> = <span class="keyword">new</span><span class="type">Tail</span>-&gt;next;</span><br><span class="line">            left = temp;</span><br><span class="line">    </span><br><span class="line">            temp = right-&gt;next;</span><br><span class="line">            right-&gt;next = <span class="keyword">new</span><span class="type">Tail</span>-&gt;next;</span><br><span class="line">            <span class="keyword">new</span><span class="type">Tail</span>-&gt;next = right;</span><br><span class="line">            <span class="keyword">new</span><span class="type">Tail</span> = <span class="keyword">new</span><span class="type">Tail</span>-&gt;next;</span><br><span class="line">            right = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(left) <span class="keyword">new</span><span class="type">Tail</span>-&gt;next = left;</span><br><span class="line">        <span class="keyword">if</span>(right) <span class="keyword">new</span><span class="type">Tail</span>-&gt;next = right;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Head</span> = <span class="keyword">new</span><span class="type">Head</span>-&gt;next;</span><br><span class="line">        head = <span class="keyword">new</span><span class="type">Head</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//reverse list</span></span><br><span class="line">    ListNode* reverseList(ListNode* head){</span><br><span class="line">        <span class="keyword">if</span>(head==NULL || head-&gt;next==NULL) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *pre = head;</span><br><span class="line">        ListNode *<span class="keyword">new</span><span class="type">List</span> = <span class="keyword">new</span> <span class="type">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(pre!=NULL){</span><br><span class="line">            ListNode* temp = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = <span class="keyword">new</span><span class="type">List</span>-&gt;next;</span><br><span class="line">            <span class="keyword">new</span><span class="type">List</span>-&gt;next = pre;</span><br><span class="line">            pre = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">new</span><span class="type">List</span> = <span class="keyword">new</span><span class="type">List</span>-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">List</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//get the middle element</span></span><br><span class="line">    ListNode* getMid(ListNode* head){</span><br><span class="line">        <span class="keyword">if</span>(head==NULL ||head-&gt;next ==NULL)<span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *first=head,*second=head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(second &amp;&amp; second-&gt;next){</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-144-Binary-Tree-Preorder-Traversal"><a href="#Leetcode-144-Binary-Tree-Preorder-Traversal" class="headerlink" title="Leetcode[144]-Binary Tree Preorder Traversal"></a>Leetcode[144]-Binary Tree Preorder Traversal</h1><p>Link: <a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-preorder-traversal/</a></p>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree<code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3</code></pre><p>return [1,2,3].</p>
<hr>
<h2 id="C-递归遍历："><a href="#C-递归遍历：" class="headerlink" title="C++递归遍历："></a>C++递归遍历：</h2><figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**C++</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; nums;</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; preorderTraversal(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) return nums;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        return nums;</span><br><span class="line">    }</span><br><span class="line">    void preOrder(TreeNode * root){</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) return;</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>)  preOrder(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>) preOrder(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">    }   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="C-递归遍历二"><a href="#C-递归遍历二" class="headerlink" title="C++递归遍历二:"></a>C++递归遍历二:</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) {</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ves;</span><br><span class="line">        preorder(root, ves);</span><br><span class="line">        <span class="keyword">return</span> ves;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">        preorder(root-&gt;left, nums);</span><br><span class="line">        preorder(root-&gt;right, nums);</span><br><span class="line">    }   </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<h2 id="非递归遍历C-："><a href="#非递归遍历C-：" class="headerlink" title="非递归遍历C++："></a>非递归遍历C++：</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode* root) {</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; nums;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode* &gt; stk;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> nums;</span><br><span class="line">    TreeNode * p = root;</span><br><span class="line">    stk.push(p);   </span><br><span class="line">    <span class="keyword">while</span>(!stk.empty()){</span><br><span class="line">        p = stk.top();</span><br><span class="line">        nums.push_back(p-&gt;val);</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right) stk.push(p-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) stk.push(p-&gt;left);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-145-Binary-Tree-Postorder-Traversal"><a href="#Leetcode-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="Leetcode[145]-Binary Tree Postorder Traversal"></a>Leetcode[145]-Binary Tree Postorder Traversal</h1><p>Link: <a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-tree-postorder-traversal/</a></p>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3</code></pre><p>return <code>[3,2,1]</code>.</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<hr>
<p>方法一：递归遍历</p>
<figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; nums;</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; postorderTraversal(TreeNode* root) {</span><br><span class="line">        postorder(root);</span><br><span class="line">        return nums;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    void postorder(TreeNode * root){</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) return;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>) postorder(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>) postorder(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">        nums.push_back(root-&gt;val);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-147-Insertion-Sort-List"><a href="#Leetcode-147-Insertion-Sort-List" class="headerlink" title="Leetcode[147]-Insertion Sort List"></a>Leetcode[147]-Insertion Sort List</h1><p>Link: <a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="noopener">https://leetcode.com/problems/insertion-sort-list/</a></p>
<p>Sort a linked list using insertion sort.</p>
<hr>
<p>链表的插入排序</p>
<p>思路：新开辟一个链表空间，用来作为插入排序的目标链。循环遍历原链表，对每个节点，让其从头到尾的在已经排好序的链表中找到插入位置（此处记录的是插入位置的前一个位置），然后将其插入进去即可。</p>
<p>代码Code(c++)：</p>
<figure class="highlight xl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    ListNode* insertionSortList(ListNode* head) {</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">if</span>(head == NULL || head-&gt;</span>next ==NULL) return head;</span><br><span class="line">        ListNode *pre = new ListNode(-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="title">pre</span>-&gt;</span>next = head;</span><br><span class="line">        <span class="function"><span class="title">head</span> = head-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">pre</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next = NULL;</span><br><span class="line">        ListNode *temp,*headNext;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(head!=NULL){</span><br><span class="line">            ListNode *prior = pre;</span><br><span class="line">            <span class="function"><span class="title">temp</span> = pre-&gt;</span>next;</span><br><span class="line">            <span class="keyword">while</span>(temp){</span><br><span class="line">                <span class="function"><span class="title">if</span>(head-&gt;</span><span class="function"><span class="title">val</span> &gt; temp-&gt;</span>val){</span><br><span class="line">                    prior = temp;</span><br><span class="line">                    <span class="function"><span class="title">temp</span> = temp-&gt;</span>next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> break;</span><br><span class="line">            }</span><br><span class="line">            <span class="function"><span class="title">headNext</span> = head-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">head</span>-&gt;</span><span class="function"><span class="title">next</span> = prior-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">prior</span>-&gt;</span>next = head;</span><br><span class="line">            head = headNext;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="title">head</span>= pre-&gt;</span>next;</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-148-Sort-List"><a href="#Leetcode-148-Sort-List" class="headerlink" title="Leetcode[148]-Sort List"></a>Leetcode[148]-Sort List</h1><p>Link: <a href="https://leetcode.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode.com/problems/sort-list/</a></p>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
<hr>
<p><strong>分析：</strong>题目要求时间复杂度为O(nlogn)，所以一开始想到的就是快速排序，但是快速排序一直AC不了，然后就想到用归并排序，没想到归并排序竟然可以。下面给出详细代码：</p>
<p>归并排序需要做的</p>
<ul>
<li>找到中间点</li>
<li>合并两个排好序的链表</li>
<li>递归实现归并排序</li>
</ul>
<p>Code(c++):</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    //mergeSort</span><br><span class="line">    ListNode* sortList(ListNode* head) {</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(head == NULL |<span class="type">| head</span>-&gt;next==NULL) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">        ListNode *mid = getMid(head);</span><br><span class="line">        ListNode *<span class="built_in">left</span> = head,*<span class="built_in">right</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(mid){</span><br><span class="line">            cout&lt;&lt;mid-&gt;val&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">right</span> = mid-&gt;next;</span><br><span class="line">            mid-&gt;next = NULL;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> mergeLinkedList(sortList(<span class="built_in">left</span>),sortList(<span class="built_in">right</span>));</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">    //get middle point from ListNode</span><br><span class="line">    ListNode* getMid(ListNode* head){</span><br><span class="line">        <span class="keyword">if</span>(head==NULL |<span class="type">| head</span>-&gt;next==NULL ) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">        ListNode* <span class="built_in">first</span> = head,* second = head-&gt;next;</span><br><span class="line">    </span><br><span class="line">        while(second &amp;&amp; second-&gt;next){</span><br><span class="line">            <span class="built_in">first</span> = <span class="built_in">first</span>-&gt;next;</span><br><span class="line">            second = second-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">first</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    //merge two sorted Linked List</span><br><span class="line">    ListNode* mergeLinkedList(ListNode* <span class="built_in">first</span>,ListNode* second){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">first</span>==NULL) <span class="keyword">return</span> second;</span><br><span class="line">        <span class="keyword">if</span>(second==NULL) <span class="keyword">return</span> <span class="built_in">first</span>;</span><br><span class="line">    </span><br><span class="line">        ListNode* tail,* front;</span><br><span class="line">        front = new ListNode(<span class="number">-1</span>);</span><br><span class="line">        tail = front;</span><br><span class="line">        while(<span class="built_in">first</span> &amp;&amp; second){</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">first</span>-&gt;val &lt; second-&gt;val){</span><br><span class="line">                tail-&gt;next = <span class="built_in">first</span>;</span><br><span class="line">                <span class="built_in">first</span> = <span class="built_in">first</span>-&gt;next;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                tail-&gt;next = second;</span><br><span class="line">                second = second-&gt;next;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">first</span>){</span><br><span class="line">            tail-&gt;next =<span class="built_in">first</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(second){</span><br><span class="line">            tail-&gt;next = second;</span><br><span class="line">        }</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Leetcode[153]-Find Minimum in Rotated Sorted Array"></a>Leetcode[153]-Find Minimum in Rotated Sorted Array</h1><p>Link: <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/</a></p>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<hr>
<p>C++:</p>
<p>方法一：直接遍历，暴力求解</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> findMin(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span>  i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="built_in">if</span>(nums[i]&lt;<span class="built_in">min</span>){</span><br><span class="line">                <span class="built_in">min</span> = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">min</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Leetcode[154]-Find Minimum in Rotated Sorted Array II"></a>Leetcode[154]-Find Minimum in Rotated Sorted Array II</h1><p>Link：　<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/</a></p>
<pre><code>Follow up for "Find Minimum in Rotated Sorted Array":
What if duplicates are allowed?

Would this affect the run-time complexity? How and why?</code></pre><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<hr>
<p>Ｃ++：</p>
<p>方法一：直接遍历求解</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> findMin(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span>  i = <span class="number">1</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="built_in">if</span>(nums[i]&lt;<span class="built_in">min</span>){</span><br><span class="line">                <span class="built_in">min</span> = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">min</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="LeetCode-155-Min-Stack"><a href="#LeetCode-155-Min-Stack" class="headerlink" title="LeetCode[155]-Min Stack"></a>LeetCode[155]-Min Stack</h1><p>Link: <a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode.com/problems/min-stack/</a></p>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.</p>
<hr>
<p>思路：需要两个栈，一个用来作为一般的栈，另一个用来存放进栈到某一位置的当前站内最小元素，代码如下：</p>
<p>Code（c++）:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min.empty() || (!min.empty() &amp;&amp; x &lt;= min.top())){</span><br><span class="line">            min.push(x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!stk.empty()){</span><br><span class="line">            <span class="keyword">if</span>(stk.top() == min.top())min.pop();</span><br><span class="line">            stk.pop();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!stk.empty())</span><br><span class="line">            <span class="keyword">return</span> stk.top();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!stk.empty()) <span class="keyword">return</span> min.top();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-162-Find-Peak-Element"><a href="#Leetcode-162-Find-Peak-Element" class="headerlink" title="Leetcode[162]-Find Peak Element"></a>Leetcode[162]-Find Peak Element</h1><p>Link: <a href="https://leetcode.com/problems/find-peak-element/" target="_blank" rel="noopener">https://leetcode.com/problems/find-peak-element/</a></p>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that num[-1] = num[n] = -∞.</p>
<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.</p>
<p>click to show spoilers.</p>
<hr>
<p>分析：</p>
<ul>
<li>如果只有一个元素，直接返回0；</li>
<li>如果元素个数&gt;=2，判断首尾是否大于它的附近元素，大于则返回下标；</li>
<li>循环遍历，下标从&gt;=1到 &lt; n-1，判断nums[i]是否同时大于它的附近元素，如果大于则返回该下标；</li>
</ul>
<p>否则，返回-1；</p>
<p>Code(c++)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[n<span class="number">-1</span>] &gt; nums[n<span class="number">-2</span>]) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n<span class="number">-1</span>; i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>] &amp;&amp; nums[i]&gt;nums[i+<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-169-Majority-Element"><a href="#Leetcode-169-Majority-Element" class="headerlink" title="Leetcode[169]-Majority Element"></a>Leetcode[169]-Majority Element</h1><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Credits:<br>Special thanks to @ts for adding this problem and creating all test cases.</p>
<hr>
<p>思路一：将数组排好序，中间的那个数一定就是我们需要的majority element。时间复杂度O(nlogn)</p>
<p>思路二：Moore voting algorithm–每找出两个不同的element，就成对删除即count–，最终剩下的一定就是所求的。时间复杂度：O(n)</p>
<p>Code1(C++):</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> majorityElement1(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">return</span> nums[n/<span class="number">2</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Code2(C++)</p>
<figure class="highlight fortran"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> majorityElement(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">int</span> n = nums.<span class="built_in">size</span>();  </span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">count</span> = <span class="number">0</span>,<span class="keyword">number</span>;</span><br><span class="line">        for(<span class="built_in">int</span> i=<span class="number">0</span>;i &lt; n; i++){</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">count</span> == <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">number</span> = nums[i];</span><br><span class="line">                <span class="built_in">count</span>++;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">number</span> == nums[i] ? <span class="built_in">count</span>++: <span class="built_in">count</span>--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">number</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-173-Binary-Search-Tree-Iterator"><a href="#Leetcode-173-Binary-Search-Tree-Iterator" class="headerlink" title="Leetcode[173]-Binary Search Tree Iterator"></a>Leetcode[173]-Binary Search Tree Iterator</h1><p>Link: <a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">https://leetcode.com/problems/binary-search-tree-iterator/</a></p>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</p>
<hr>
<p><strong>思路：</strong> 遍历一遍，然后从小到大的放到队列里去，然后判断队列是否非空，不非空则前面的就是最小的，出队即可！</p>
<p>C++:</p>
<figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> binary tree</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(<span class="built_in">int</span> x) : val(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> BSTIterator {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="built_in">int</span>&gt; que;</span><br><span class="line">    BSTIterator(TreeNode *root) {</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        map&lt;TreeNode *, <span class="built_in">int</span>&gt; visited;</span><br><span class="line">        TreeNode *p;</span><br><span class="line">        <span class="keyword">if</span>(root) { </span><br><span class="line">            stk.push(root);</span><br><span class="line">            visited[root] = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="literal">empty</span>()){</span><br><span class="line">            p = stk.top();</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;<span class="built_in">left</span> &amp;&amp; visited[p] == <span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(visited[p-&gt;<span class="built_in">left</span>] == <span class="number">1</span>) break;</span><br><span class="line">                p = p-&gt;<span class="built_in">left</span>;</span><br><span class="line">                stk.push(p);</span><br><span class="line">                visited[p]=<span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            visited[p]=<span class="number">1</span>;</span><br><span class="line">            que.push(p-&gt;val);</span><br><span class="line">            stk.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;<span class="built_in">right</span> &amp;&amp; (visited.find(p-&gt;<span class="built_in">right</span>)==visited.<span class="keyword">end</span>() || visited[p-&gt;<span class="built_in">right</span>]==<span class="number">0</span>)){</span><br><span class="line">                stk.push(p-&gt;<span class="built_in">right</span>);</span><br><span class="line">                visited[p-&gt;<span class="built_in">right</span>] = <span class="number">0</span>;</span><br><span class="line">                continue;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">	/* another way     </span><br><span class="line">	stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span>(root || !stk.<span class="literal">empty</span>() ) {</span><br><span class="line">            <span class="keyword">if</span>(root){</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;<span class="built_in">left</span>;</span><br><span class="line">            }<span class="keyword">else</span> {</span><br><span class="line">                root = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                que.push(root-&gt;val);</span><br><span class="line">                root = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">            }   </span><br><span class="line">        } */ </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">/** @return whether we have a <span class="keyword">next</span> smallest number */</span><br><span class="line">    bool hasNext() {</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="literal">empty</span>()) return <span class="literal">true</span>;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">/** @return the <span class="keyword">next</span> smallest number */</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">next</span>() {</span><br><span class="line">        <span class="built_in">int</span> val = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        return val;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your BSTIterator will be called like this:</span><br><span class="line"> * BSTIterator i = BSTIterator(root);</span><br><span class="line"> * <span class="keyword">while</span> (i.hasNext()) cout &lt;&lt; i.<span class="keyword">next</span>();</span><br><span class="line"> */</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-189-Rotate-Array"><a href="#Leetcode-189-Rotate-Array" class="headerlink" title="Leetcode[189]-Rotate Array"></a>Leetcode[189]-Rotate Array</h1><p>Link: <a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-array/</a></p>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
<p>[show hint]</p>
<p>Related problem: Reverse Words in a String II</p>
<p>Credits:<br>Special thanks to @Freezen for adding this problem and creating all test cases.</p>
<hr>
<p>分析： (使用三次反转)利用</p>
<p>$$ba=(b^{r})^{r}(a^{r})^{r}=(a^{r}b^{r})^{r}$$</p>
<p>先分别反转a、b，最后再对所有元素进行一次反转。此算法读写内存各约2*n次。</p>
<p>结论：将数组按照k值分成左右两部分，右边k个，左边n-k个，然后先将左右两部分各自翻转，再将整个数组整体翻转，即可得到结果。</p>
<p>Code（c++）：</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution</span><br><span class="line">{</span><br><span class="line"><span class="symbol">	public:</span></span><br><span class="line">		void <span class="keyword">swap(int </span>* <span class="built_in">s1</span>,int * <span class="built_in">s2</span>)</span><br><span class="line">		{</span><br><span class="line">			int temp = *<span class="built_in">s1</span><span class="comment">;</span></span><br><span class="line">			*<span class="built_in">s1</span> = *<span class="built_in">s2</span><span class="comment">;</span></span><br><span class="line">			*<span class="built_in">s2</span> = temp<span class="comment">;</span></span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		void rotate(vector&lt;int&gt; &amp; nums,int k)</span><br><span class="line">		{</span><br><span class="line">			int n = nums.size()<span class="comment">;</span></span><br><span class="line">			int left = n - (k % n)<span class="comment">;</span></span><br><span class="line">			for(int i = <span class="number">0</span>,<span class="keyword">j </span>= left - <span class="number">1</span><span class="comment">;i &lt; j;i++,j--)</span></span><br><span class="line">				<span class="keyword">swap(&amp;nums[i],&amp;nums[j]);</span></span><br><span class="line"><span class="keyword">	</span>		for(int i = left,<span class="keyword">j </span>= n - <span class="number">1</span><span class="comment">;i &lt; j;i++,j--)</span></span><br><span class="line">				<span class="keyword">swap(&amp;nums[i],&amp;nums[j]);</span></span><br><span class="line"><span class="keyword">	</span>		for(int i = <span class="number">0</span>,<span class="keyword">j </span>= n - <span class="number">1</span><span class="comment">;i &lt; j;i++,j--)</span></span><br><span class="line">				<span class="keyword">swap(&amp;nums[i],&amp;nums[j]);</span></span><br><span class="line"><span class="keyword">	</span>	}</span><br><span class="line">}<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-191-Number-of-Bits"><a href="#Leetcode-191-Number-of-Bits" class="headerlink" title="Leetcode[191]-Number of Bits"></a>Leetcode[191]-Number of Bits</h1><p>Link:<a href="https://leetcode.com/problems/number-of-1-bits/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-1-bits/</a></p>
<p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p>
<hr>
<p>分析：<strong>在十进制转换为二进制时，如果n%2=1，则在二进制中有1</strong>.根据这条规则，可以循环判断n，每判断一次，n=n/2，代码如下：</p>
<p>C++:</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> hammingWeight(uint32_t n) {</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>){</span><br><span class="line">                <span class="keyword">count</span>++;</span><br><span class="line">            }</span><br><span class="line">            n=n/<span class="number">2</span>; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Python:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">            n=n/<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-198-House-Robber"><a href="#Leetcode-198-House-Robber" class="headerlink" title="Leetcode[198]-House Robber"></a>Leetcode[198]-House Robber</h1><p>Link: <a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">https://leetcode.com/problems/house-robber/</a></p>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<hr>
<p>题目意思：假如现在你是一个强盗，一个武功超群，足智多谋的江洋大盗，现在你要去一条街上抢劫，这条街全是贪官污吏，一共有N家，每家都有一定数量的金子，如果相邻的两家在同一个晚上都被打劫了，那么就会有一个类似触发器的东西自动调动兵马来街上抓你。</p>
<p>请问，在不触发这个警报器的前提下，你能抢劫到多少money？</p>
<p><strong>动态规划思想解题</strong></p>
<p><strong>分析：</strong>，有N家贪官，假设是从左到右，第i家贪官家里的钱数为m[i]，i从0到N-1，根据题意可知，肯定不能在今晚打劫两个相邻的贪官，也就是假如打劫了第i家，就不能打劫第i-1家和i+1家。</p>
<p>设dp[i]表示我从第1家到达第i家能强盗的最大money数；</p>
<ul>
<li>当你打劫第一家的时候，i = 0，可以得到的钱dp[i] = m[0]；</li>
<li>当你到达第二家的时候，i = 1，此时能得到的钱数为max(m[0],m[1]),因为不能同时打劫第一家和第二家；</li>
<li>当到达第i家的时候，i＞＝２，此时能够得到的钱数应该为max{dp[i-1],dp[i-2]+m[i]},即要么是到达上一家时的最大money数，要么是到达上上家时的最大money+这一家的money数，两者中较大的那个；</li>
</ul>
<p>所以最后我们要得到的就是dp[N-1]，即到达最后一家时的最大money数。</p>
<hr>
<p>Code(c++):</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) dp[i] = max(nums[i],nums[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                dp[i] = max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>] + nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>  dp[n<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-202-Happy-Number"><a href="#Leetcode-202-Happy-Number" class="headerlink" title="Leetcode[202]-Happy Number"></a>Leetcode[202]-Happy Number</h1><p>Link:<a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">https://leetcode.com/problems/happy-number/</a></p>
<p>Write an algorithm to determine if a number is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Example: 19 is a happy number</p>
<p>$1^2 + 9^2 = 82$<br>$8^2 + 2^2 = 68$<br>$6^2 + 8^2 = 100$<br>$1^2 + 0^2 + 0^2 = 1$</p>
<p>Credits:<br>Special thanks to @mithmatt and @ts for adding this problem and creating all test cases.</p>
<hr>
<p><strong>分析</strong>：题目说的是对任意一个正整数，不断各个数位上数字的平方和，若最终收敛为1，则该数字为happy number，否则程序可能从某个数开始陷入循环。</p>
<p>这里我们使用一个哈希map表存储已经出现过的数字，如果下次还出现，则返回false。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">            # 计算一个数各个位的平方和</span><br><span class="line">            <span class="keyword">while</span>(n){</span><br><span class="line">                number += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">                n/=<span class="number">10</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums.find(number)!=nums.end())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = number;</span><br><span class="line">            nums[n] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>另外还有一种简单的算法：</p>
<hr>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">6</span>){  </span><br><span class="line">            <span class="keyword">int</span> next = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">while</span>(n){</span><br><span class="line">                next+=(n%<span class="number">10</span>)*(n%<span class="number">10</span>); </span><br><span class="line">                n/=<span class="number">10</span>;</span><br><span class="line">            }  </span><br><span class="line">            n = next;  </span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;  </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-203-Remove-Linked-List-Elements"><a href="#Leetcode-203-Remove-Linked-List-Elements" class="headerlink" title="Leetcode[203]-Remove Linked List Elements"></a>Leetcode[203]-Remove Linked List Elements</h1><p>Remove all elements from a linked list of integers that have value val.</p>
<p>Example<br>Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6<br>Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5</p>
<p>Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
<hr>
<p><strong>分析：</strong></p>
<ul>
<li><p>如果链表不为空，保证第一个节点不等于val，如果等于，直接跳到下一个节点；</p>
</li>
<li><p>如果此时链表为空，返回该链表；</p>
</li>
<li><p>将头结点赋值给一个临时节点，如果该节点的下一个节点不为空，递归遍历；</p>
<ul>
<li>如果下一个节点的值等于给定值，直接跳到下下个节点；</li>
<li>如果下一个节点的值不等于给定值，则让跳到下个节点再来循环；</li>
</ul>
</li>
<li><p>最后返回链表的头结点即可。</p>
</li>
</ul>
<p>Code（c++）：</p>
<figure class="highlight ocaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Definition</span> <span class="keyword">for</span> singly-linked <span class="built_in">list</span>.</span><br><span class="line"> * <span class="keyword">struct</span> <span class="type">ListNode</span> {</span><br><span class="line"> *     <span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line"> *     <span class="type">ListNode</span> *next;</span><br><span class="line"> *     <span class="type">ListNode</span>(<span class="built_in">int</span> x) : <span class="keyword">val</span>(x), next(<span class="type">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="type">Solution</span> {</span><br><span class="line">public:</span><br><span class="line">    <span class="type">ListNode</span>* removeElements(<span class="type">ListNode</span>* head, <span class="built_in">int</span> <span class="keyword">val</span>) {</span><br><span class="line">        <span class="keyword">while</span>(head !=<span class="type">NULL</span> &amp;&amp; head-&gt;<span class="keyword">val</span> == <span class="keyword">val</span>) {</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="type">NULL</span>) return head;</span><br><span class="line">        <span class="type">ListNode</span>* pre = <span class="type">NULL</span>;</span><br><span class="line">        pre = head;</span><br><span class="line">        <span class="keyword">while</span>(pre-&gt;next!=<span class="type">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;next-&gt;<span class="keyword">val</span> == <span class="keyword">val</span>){</span><br><span class="line">                pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">            } <span class="keyword">else</span>{</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-206-Reverse-Linked-List"><a href="#Leetcode-206-Reverse-Linked-List" class="headerlink" title="Leetcode[206]-Reverse Linked List"></a>Leetcode[206]-Reverse Linked List</h1><p>Link:<a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/reverse-linked-list/</a></p>
<p>Reverse a singly linked list.Reverse a singly linked list.</p>
<p>Hint:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<hr>
<p>分析：<br><img src="http://img.blog.csdn.net/20150610095309420" alt="这里写图片描述"></p>
<figure class="highlight vbscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode {</span><br><span class="line"> *     <span class="built_in">int</span> val;</span><br><span class="line"> *     ListNode *<span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(<span class="built_in">int</span> x) : val(x), <span class="keyword">next</span>(<span class="literal">NULL</span>) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> Solution {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* reverseList(ListNode* head) {</span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;<span class="keyword">next</span>==<span class="literal">NULL</span>) return head;</span><br><span class="line">    </span><br><span class="line">        pre= head-&gt;<span class="keyword">next</span>;</span><br><span class="line">    </span><br><span class="line">        head-&gt;<span class="keyword">next</span> = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>){</span><br><span class="line">            ListNode * nextNode = <span class="literal">NULL</span>;</span><br><span class="line">            nextNode = pre-&gt;<span class="keyword">next</span>;</span><br><span class="line">            pre-&gt;<span class="keyword">next</span> = head;</span><br><span class="line">            head = pre;</span><br><span class="line">            pre = nextNode;</span><br><span class="line">            delete nextNode;</span><br><span class="line">        }</span><br><span class="line">        delete pre;</span><br><span class="line">        return head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-215-Kth-Largest-Element-in-an-Array"><a href="#Leetcode-215-Kth-Largest-Element-in-an-Array" class="headerlink" title="Leetcode[215]-Kth Largest Element in an Array"></a>Leetcode[215]-Kth Largest Element in an Array</h1><p>Link: <a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p>
<p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>For example,<br>Given<code>[3,2,1,5,6,4]</code>and <code>k = 2</code>, return <code>5</code>.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
<hr>
<p>法一：使用STL的sort排序O(NlogN)</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> findKthLargest(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) {</span><br><span class="line">    sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">return</span> nums[nums.<span class="built_in">size</span>()-k];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法二：自己写快速排序O（NlogN）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">   </span><br><span class="line">	quickSort(nums, <span class="number">0</span> ,nums.size());</span><br><span class="line">	<span class="keyword">return</span> nums[nums.size()-k];</span><br><span class="line">   </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; j){</span><br><span class="line">        <span class="keyword">int</span> po = nums[i];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j){</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= po) j--;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) {</span><br><span class="line">                nums[i++] = nums[j];</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt;= po ) i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j){</span><br><span class="line">                nums[j--] = nums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        nums[i] = po;</span><br><span class="line">        quickSort(nums, left, i);</span><br><span class="line">        quickSort(nums, i+<span class="number">1</span>, right);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>法三：使用建堆法  时间复杂度O(klogN)</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> findKthLargest(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k){</span><br><span class="line">    make_heap(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>; i&lt;k<span class="number">-1</span>;i++){</span><br><span class="line">        pop_heap(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        nums.pop_back();</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">return</span> nums.front();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>方法四：此方法是论坛看到的，O（N）</p>
<figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int findKthLargest(vector&lt;int&gt;&amp; nums, int k){</span><br><span class="line">     int i, m, n, pivot, <span class="attr">head</span> =<span class="number">0</span>, <span class="attr">tail</span> = nums.size()-<span class="number">1</span>, maxV;</span><br><span class="line"></span><br><span class="line">    while(<span class="number">1</span>){</span><br><span class="line">        <span class="attr">m</span> = head, <span class="attr">n=</span> tail;</span><br><span class="line">        <span class="attr">pivot</span> = nums[m++];</span><br><span class="line">        while(m &lt;= n) {</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt;= pivot) m++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[n] &lt; pivot) n--;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                swap(nums[m++], nums[n--]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(<span class="attr">m-head</span> == k) </span><br><span class="line">            return pivot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m-head &lt; k) {</span><br><span class="line">            k <span class="attr">-=</span> (m-head); </span><br><span class="line">            <span class="attr">head</span> = m;  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="attr">tail</span> = m-<span class="number">1</span>;</span><br><span class="line">            <span class="attr">head</span> = head+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-217-Contains-Duplicate"><a href="#Leetcode-217-Contains-Duplicate" class="headerlink" title="Leetcode[217]-Contains Duplicate"></a>Leetcode[217]-Contains Duplicate</h1><p>Link：<a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate/</a></p>
<p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<hr>
<p>思路：先将数组排序，然后从第二个开始遍历，如果和前一个值相等，则返回true，终止；此方法时间复杂度为O（nlogn），空间复杂度为O（1）</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(), nums.end());</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n){</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>小记</strong>：自己做的时候，开始使用两个for循环遍历，结果超时了，后来使用自己写的快速排序，也超时了。最后使用了std::sort(nums.begin(), nums.end())自带的sort，结果成功了！不知道是快速排序哪里出了问题。</p>
<p><br><br><br>拓展：快速排序算法</p>
<figure class="highlight mipsasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void quickSort(vector&lt;int&gt; &amp;nums,int low,int high){</span><br><span class="line">    int i=low,<span class="keyword">j=high;</span></span><br><span class="line"><span class="keyword"> </span>   if(i &lt; <span class="keyword">j){</span></span><br><span class="line"><span class="keyword"> </span>       int po = nums[low]<span class="comment">;</span></span><br><span class="line">        while(i &lt; <span class="keyword">j){</span></span><br><span class="line"><span class="keyword"> </span>           while(nums[i]&lt;nums[<span class="keyword">j] </span>&amp;&amp; po &lt; nums[<span class="keyword">j]) </span><span class="keyword">j--;</span></span><br><span class="line"><span class="keyword"> </span>           if(i&lt;<span class="keyword">j){</span></span><br><span class="line"><span class="keyword"> </span>               int temp = nums[i]<span class="comment">;</span></span><br><span class="line">                nums[i] = nums[<span class="keyword">j];</span></span><br><span class="line"><span class="keyword"> </span>               nums[<span class="keyword">j] </span>= temp<span class="comment">;</span></span><br><span class="line">                i++<span class="comment">;</span></span><br><span class="line">            }</span><br><span class="line">            while(nums[i]&lt;nums[<span class="keyword">j] </span>&amp;&amp; nums[i] &lt; po) i++<span class="comment">;</span></span><br><span class="line">            if(i&lt;<span class="keyword">j){</span></span><br><span class="line"><span class="keyword"> </span>               int temp = nums[i]<span class="comment">;</span></span><br><span class="line">                nums[i] = nums[<span class="keyword">j];</span></span><br><span class="line"><span class="keyword"> </span>               nums[<span class="keyword">j] </span>= temp<span class="comment">;</span></span><br><span class="line">                <span class="keyword">j--;</span></span><br><span class="line"><span class="keyword"> </span>           }</span><br><span class="line">        }</span><br><span class="line">        quickSort(nums,low,<span class="keyword">j-1);</span></span><br><span class="line"><span class="keyword"> </span>       quickSort(nums,<span class="keyword">j+1,high);</span></span><br><span class="line"><span class="keyword"> </span>   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>Python代码</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n ==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-219-Contains-Duplicate-II"><a href="#Leetcode-219-Contains-Duplicate-II" class="headerlink" title="Leetcode[219]-Contains Duplicate II"></a>Leetcode[219]-Contains Duplicate II</h1><p>Link:<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/contains-duplicate-ii/</a></p>
<p>Given an array of integers and an integer k, find out whether there there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.</p>
<hr>
<p><strong>分析</strong>：用C++中的map记录num和下标value，key值为数值，value为值在nums数组中的下标。首先遍历数组，如果在map中存在<br>【mapv.find(number) != mapv.end()】并且当前位置和map中找到的位置差小于等于k【i-mapv[number] &lt;= k】，就返回true，不然就将该值加入到map中。依次循环…</p>
<p>Code(c++)</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapv;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">            <span class="keyword">int</span> number = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (mapv.find(number) != mapv.end() &amp;&amp; i-mapv[number] &lt;= k){</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                mapv[number] = i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-222-Count-Complete-Tree-Nodes"><a href="#Leetcode-222-Count-Complete-Tree-Nodes" class="headerlink" title="Leetcode[222]-Count Complete Tree Nodes"></a>Leetcode[222]-Count Complete Tree Nodes</h1><p>Link: <a href="https://leetcode.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">https://leetcode.com/problems/count-complete-tree-nodes/</a></p>
<p>Given a complete binary tree, count the number of nodes.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<hr>
<p>思路：分别计算左右子树，然后返回左右字数节点个数加一</p>
<p>递归法：（超时了）</p>
<figure class="highlight zephir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> countNodes(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lcount=<span class="number">0</span>,rcount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="keyword">NULL</span>){</span><br><span class="line">            lcount = countNodes(root-&gt;left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="keyword">NULL</span>){</span><br><span class="line">            rcount = countNodes(root-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lcount+rcount+<span class="number">1</span>;  </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>方法二：<br>先计算左右的深度是否相等，相等则为满二叉树，满二叉树的节点个数为深度的平方减一,即depth^2-1；如果不相等，则递归以同样的方式计算左子树和右子树，并返回两者个数之和加一。</p>
<p><strong>Code(c++):</strong></p>
<figure class="highlight zephir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> countNodes(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">int</span> ldepth = getLeftDepth(root);</span><br><span class="line">        <span class="keyword">int</span> rdepth = getRightDepth(root);</span><br><span class="line">        <span class="comment">//return the square of leftdepth -1</span></span><br><span class="line">        <span class="keyword">if</span>(ldepth == rdepth) <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; ldepth) - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> countNodes(root-&gt;left)+countNodes(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//compute the depth of left tree</span></span><br><span class="line">    <span class="keyword">int</span> getLeftDepth(TreeNode *root){</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root){</span><br><span class="line">            depth++;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//compute the depth of right tree</span></span><br><span class="line">    <span class="keyword">int</span> getRightDepth(TreeNode *root){</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root){</span><br><span class="line">            depth++;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-226-Invert-Binary-Tree"><a href="#Leetcode-226-Invert-Binary-Tree" class="headerlink" title="Leetcode[226]-Invert Binary Tree"></a>Leetcode[226]-Invert Binary Tree</h1><p>Link: <a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/invert-binary-tree/</a></p>
<p>Invert a binary tree.</p>
<pre><code>     4
   /   \
  2     7
 / \   / \
1   3 6   9</code></pre><p>to</p>
<pre><code>     4
   /   \
  7     2
 / \   / \
9   6 3   1</code></pre><p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:<br>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>
<hr>
<p>C++递归法求解：</p>
<figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    TreeNode* invertTree(TreeNode* root) {</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> NULL;</span><br><span class="line">        </span><br><span class="line">        invertNode(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    void invertNode(TreeNode *root){</span><br><span class="line">        <span class="keyword">if</span>(root == NULL) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; !root-&gt;<span class="built_in">right</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        TreeNode *tempNode=NULL;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>) tempNode = root-&gt;<span class="built_in">right</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>){</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = root-&gt;<span class="built_in">left</span>;</span><br><span class="line">            root-&gt;<span class="built_in">left</span> = tempNode;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            root-&gt;<span class="built_in">left</span> = tempNode;</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = NULL;</span><br><span class="line">        }</span><br><span class="line">        invertNode(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">        invertNode(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-231-Power-of-Two"><a href="#Leetcode-231-Power-of-Two" class="headerlink" title="Leetcode[231]-Power of Two"></a>Leetcode[231]-Power of Two</h1><p>Link:<a href="https://leetcode.com/problems/power-of-two/" target="_blank" rel="noopener">https://leetcode.com/problems/power-of-two/</a></p>
<p>Given an integer, write a function to determine if it is a power of two.</p>
<hr>
<p>分析：</p>
<ul>
<li>如果n小于0，返回false；</li>
<li>如果n等于1或者等于2，返回true；</li>
<li>当n大于2时，根据n大于2的条件进行递归，，如果n%2不为0则直接返回false，否则将n/2赋值给n<ul>
<li>如果循环结束后还没有返回false，则返回true。</li>
</ul>
</li>
</ul>
<p>C++:</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool isPowerOfTwo(int n) {</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">2</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">2</span>){</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-237-Delete-Node-in-a-Linked-List"><a href="#Leetcode-237-Delete-Node-in-a-Linked-List" class="headerlink" title="Leetcode[237]-Delete Node in a Linked List"></a>Leetcode[237]-Delete Node in a Linked List</h1><p>Link:<a href="https://leetcode.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-node-in-a-linked-list/</a></p>
<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.</p>
<p>Subscribe to see which companies asked this question</p>
<hr>
<p>比较简单，直接给出答案</p>
<figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode {</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) {}</span><br><span class="line"> * };</span><br><span class="line"> */</span><br><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* <span class="keyword">node</span><span class="title">) {</span></span><br><span class="line"><span class="title">        if</span>(<span class="keyword">node</span> <span class="title">== NULL</span>) return;</span><br><span class="line">        ListNode *tmp = <span class="keyword">node</span><span class="title">-&gt;next</span>;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;val</span> = tmp-&gt;val;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;next</span> = tmp-&gt;next;</span><br><span class="line">        delete tmp;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-242-Valid-Anagram"><a href="#Leetcode-242-Valid-Anagram" class="headerlink" title="Leetcode[242]-Valid Anagram"></a>Leetcode[242]-Valid Anagram</h1><p>Link:<a href="https://leetcode.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode.com/problems/valid-anagram/</a></p>
<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>
<p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p>
<p>Note:<br>You may assume the string contains only lowercase alphabets.</p>
<hr>
<p>思路：这道题，思路比较简单，将s中字符串的单词个数映射到26个子母中，然后遍历t，出现一个字母，就将该字母数减1，最后判断是否全为0即可。</p>
<p>Python代码比较简单，就给出Python代码吧：</p>
<p>Python：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) != len(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        word = [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            index1 = ord(s[i])<span class="number">-97</span></span><br><span class="line">            index2 = ord(t[i])<span class="number">-97</span></span><br><span class="line">            word[index1] += <span class="number">1</span></span><br><span class="line">            word[index2] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> any(word)</span><br></pre></td></tr></tbody></table></figure>

<p>附加C++:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> word[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">memset</span>(word, <span class="number">0</span>, <span class="keyword">sizeof</span>(word));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++){</span><br><span class="line">            <span class="keyword">int</span> index1 = s[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> index2 = t[i]-<span class="string">'a'</span>;</span><br><span class="line">            word[index1]+=<span class="number">1</span>;</span><br><span class="line">            word[index2]-=<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(c&lt;<span class="number">26</span>){</span><br><span class="line">            <span class="keyword">if</span>(word[c++]!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>学习心得：有关字符串的题目，可以考虑将其映射到字母表中。</p>
<hr>
<h1 id="Leetcode-258-Add-Digits"><a href="#Leetcode-258-Add-Digits" class="headerlink" title="Leetcode[258]-Add Digits"></a>Leetcode[258]-Add Digits</h1><p>Link: <a href="https://leetcode.com/problems/add-digits/" target="_blank" rel="noopener">https://leetcode.com/problems/add-digits/</a></p>
<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>For example:</p>
<p>Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.</p>
<p>Follow up:<br>Could you do it without any loop/recursion in O(1) runtime?</p>
<hr>
<p>思路：此题和202题有点类似，可以参考。主要是在各个位数的想加上，有点技巧。</p>
<p>C++</p>
<figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">publ<span class="symbol">ic:</span></span><br><span class="line">    <span class="built_in">int</span> addDigits(<span class="built_in">int</span> num) {</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">n</span>=num;</span><br><span class="line">        while(<span class="built_in">n</span>&gt;=<span class="number">10</span>){</span><br><span class="line">            <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">            while(<span class="built_in">n</span>&gt;<span class="number">0</span>){</span><br><span class="line">                i += <span class="built_in">n</span>%<span class="number">10</span>;</span><br><span class="line">                <span class="built_in">n</span> = <span class="built_in">n</span>/<span class="number">10</span>;</span><br><span class="line">            };</span><br><span class="line">            <span class="built_in">n</span> = i;</span><br><span class="line">        }</span><br><span class="line">        return <span class="built_in">n</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-260-Single-Number-III"><a href="#Leetcode-260-Single-Number-III" class="headerlink" title="Leetcode[260]-Single Number III"></a>Leetcode[260]-Single Number III</h1><p>Link: <a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">https://leetcode.com/problems/single-number-iii/</a></p>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
<hr>
<p>思路：首先对数组进行排序，然后一对一对的进行比较，如果两个相等，则以步长为2往后移动，如果不相等，则将当前的值加入到返回变量中，然后以步长为1往后移动。</p>
<p>C++:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; singleNumber(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n<span class="number">-1</span>){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]){</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res.push_back(nums[i]);</span><br><span class="line">                i+=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(nums[n<span class="number">-1</span>]!=nums[n<span class="number">-2</span>]){</span><br><span class="line">            res.push_back(nums[n<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-263-Ugly-Number"><a href="#Leetcode-263-Ugly-Number" class="headerlink" title="Leetcode[263]-Ugly Number++"></a>Leetcode[263]-Ugly Number++</h1><p>Link:<a href="https://leetcode.com/problems/ugly-number/" target="_blank" rel="noopener">https://leetcode.com/problems/ugly-number/</a></p>
<p>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.</p>
<p>Note that 1 is typically treated as an ugly number.</p>
<hr>
<figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">bool</span> isUgly(<span class="built_in">int</span> <span class="built_in">num</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">num</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">num</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> pfactor[] = { <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> };</span><br><span class="line">        <span class="keyword">for</span> (auto val : pfactor) {</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">num</span> % val == <span class="number">0</span>) { <span class="built_in">num</span> /= val; }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">num</span> == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-283-Move-Zeroes"><a href="#Leetcode-283-Move-Zeroes" class="headerlink" title="Leetcode[283]-Move Zeroes"></a>Leetcode[283]-Move Zeroes</h1><p>Link:<a href="https://leetcode.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode.com/problems/move-zeroes/</a></p>
<p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p>Note:</p>
<ul>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ul>
<hr>
<p>C++代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n=nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,s = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=s){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;s; j++){</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                }</span><br><span class="line">                nums[s]=<span class="number">0</span>;</span><br><span class="line">                s = s<span class="number">-1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                i=i+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-292-Nim-Game"><a href="#Leetcode-292-Nim-Game" class="headerlink" title="Leetcode[292]-Nim Game"></a>Leetcode[292]-Nim Game</h1><p>Link:<a href="https://leetcode.com/problems/nim-game/" target="_blank" rel="noopener">https://leetcode.com/problems/nim-game/</a></p>
<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>
<hr>
<p>分析：经过分析之后发现，有以下规律：</p>
<ul>
<li>如果n小于4，返回true；</li>
<li>如果n%4==0，返回false；</li>
<li>否则，返回true。</li>
</ul>
<p>C++:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Python：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>;</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">4</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span>;</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Leetcode-300-Longest-Increasing-Subsequence"><a href="#Leetcode-300-Longest-Increasing-Subsequence" class="headerlink" title="Leetcode[300]-Longest Increasing Subsequence"></a>Leetcode[300]-Longest Increasing Subsequence</h1><p>Link：<a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence/</a></p>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>For example,<br>Given <code>[10, 9, 2, 5, 3, 7, 101, 18]</code>,
The longest increasing subsequence is <code>[2, 3, 7, 101]</code>, therefore the length is <code>4</code>. Note that there may be more than one LIS combination, it is only necessary for you to return the length.</p>
<p>Your algorithm should run in O(n2) complexity.</p>
<p>Follow up: Could you improve it to O(n log n) time complexity?</p>
<hr>
<p>这道题和最长连续子序列有些区别，它不限制【连续】这个条件，只要递增即可。</p>
<p>思路：定义一个长度为n的int类型一维数组dp[n]，dp[i]用来表示第i个位置上的最长递增子序列长度。dp[i]的计算过程如下：</p>
<ul>
<li>初始化dp[0]=1；</li>
<li>当i&gt;0时，设置一个变量max_dp，初始值为1,记录的是以当前位置结尾时的最长递增子序列长度。通过循环遍历前面的i-1个数，如果位置i的数大于前面位置j的数，就比较max_dp和dp[j]+1,将大的值赋值给max_dp，最后将max_dp赋值给dp[i]；</li>
<li>最后，遍历dp[n]，找出最大的值，即为最长递增子序列的长度。</li>
</ul>
<p>C++代码：</p>
<figure class="highlight mel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution {</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> lengthOfLIS(<span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="keyword">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++){</span><br><span class="line">            <span class="keyword">int</span> j=i<span class="number">-1</span>,max_dp=<span class="number">1</span>;            </span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]){</span><br><span class="line">                    max_dp=(max_dp&gt;(dp[j]+<span class="number">1</span>)?max_dp:(dp[j]+<span class="number">1</span>));</span><br><span class="line">                }</span><br><span class="line">                --j;</span><br><span class="line">            }</span><br><span class="line">            dp[i]=max_dp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">max</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++){</span><br><span class="line">            <span class="keyword">max</span>=(<span class="keyword">max</span>&gt;dp[k]?<span class="keyword">max</span>:dp[k]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">max</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据结构/" rel="tag">#数据结构</a>
          
            <a href="/tags/LeetCode/" rel="tag">#LeetCode</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/12/25/2015-12-25-25-Java-Machine-Learning-Tools-&-Libraries/" rel="prev">
                <i class="fa fa-chevron-left"></i> 25个Java机器学习工具&库(译)
              </a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/04/2015-12-04-Python-Round/" rel="next">
                Python笔记-几种取整方式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              </div>
            
          </div>
        
      

        
          
  
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
      
      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table Of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview" sidebar-panel>
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="刘帝伟" itemprop="image">
          <p class="site-author-name" itemprop="name">刘帝伟</p>
        </div>
        <p class="site-description motion-element" itemprop="description">中南大学硕士，关注机器学习、深度学习、自然语言处理与人工智能领域.</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">110</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">categories</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">186</span>
              <span class="site-state-item-name">tags</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/csuldw" target="_blank">
                  <i class="fa fa-github"></i> GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/liudiwei210" target="_blank">
                  <i class="fa fa-weibo"></i> WeiBo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/dream_angel_z" target="_blank">
                  <i class="fa fa-csdn"></i> CSDN
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">Leetcode[1]-Two Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-4-Median-of-Two-Sorted-Arrays"><span class="nav-number">2.</span> <span class="nav-text">Leetcode[4]-Median of Two Sorted Arrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-7-Reverse-Integer"><span class="nav-number">3.</span> <span class="nav-text">Leetcode[7]-Reverse Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-9-Palindrome-Number"><span class="nav-number">4.</span> <span class="nav-text">Leetcode[9]-Palindrome Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-12-Integer-to-Roman"><span class="nav-number">5.</span> <span class="nav-text">Leetcode[12]-Integer to Roman+++</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-13-Roman-to-Integer"><span class="nav-number">6.</span> <span class="nav-text">Leetcode[13]-Roman to Integer+++</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-15-3Sum"><span class="nav-number">7.</span> <span class="nav-text">Leetcode[15]-3Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-18-4Sum"><span class="nav-number">8.</span> <span class="nav-text">Leetcode[18]-4Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-19-Remove-Nth-Node-From-End-of-List"><span class="nav-number">9.</span> <span class="nav-text">Leetcode[19]-Remove Nth Node From End of List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-20-Valid-Parentheses"><span class="nav-number">10.</span> <span class="nav-text">Leetcode[20]-Valid Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-21-Merge-Two-Sorted-Lists"><span class="nav-number">11.</span> <span class="nav-text">Leetcode[21]-Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-26-Remove-Duplicates-from-Sorted-Array"><span class="nav-number">12.</span> <span class="nav-text">Leetcode[26]-Remove Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-27-Remove-Element"><span class="nav-number">13.</span> <span class="nav-text">Leetcode[27]-Remove Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-33-Search-in-Rotated-Sorted-Array"><span class="nav-number">14.</span> <span class="nav-text">Leetcode[33]-Search in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-35-Search-Insert-Position"><span class="nav-number">15.</span> <span class="nav-text">Leetcode[35]-Search Insert Position</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-36-Valid-Sudoku"><span class="nav-number">16.</span> <span class="nav-text">Leetcode[36]-Valid Sudoku</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-53-Maximum-Subarray"><span class="nav-number">17.</span> <span class="nav-text">Leetcode[53]-Maximum Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-62-Unique-Paths"><span class="nav-number">18.</span> <span class="nav-text">Leetcode[62]-Unique Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-63-Unique-Paths-II"><span class="nav-number">19.</span> <span class="nav-text">Leetcode[63]-Unique Paths II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-66-Plus-One"><span class="nav-number">20.</span> <span class="nav-text">Leetcode[66]-Plus One</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-70-Climbing-Stairs"><span class="nav-number">21.</span> <span class="nav-text">Leetcode[70]-Climbing Stairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-74-Search-a-2D-Matrix"><span class="nav-number">22.</span> <span class="nav-text">Leetcode[74]-Search a 2D Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-81-Search-for-a-Range"><span class="nav-number">23.</span> <span class="nav-text">Leetcode[81]-Search for a Range</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><span class="nav-number">24.</span> <span class="nav-text">Leetcode[82]-Remove Duplicates from Sorted List II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-83-Remove-Duplicates-from-Sorted-List"><span class="nav-number">25.</span> <span class="nav-text">Leetcode[83]-Remove Duplicates from Sorted List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-86-Partition-List"><span class="nav-number">26.</span> <span class="nav-text">Leetcode[86]-Partition List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-88-Merge-Sorted-Array"><span class="nav-number">27.</span> <span class="nav-text">Leetcode[88]-Merge Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-92-Reverse-Linked-List-II"><span class="nav-number">28.</span> <span class="nav-text">Leetcode[92]-Reverse Linked List II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-94-Binary-Tree-Inorder-Traversal"><span class="nav-number">29.</span> <span class="nav-text">Leetcode[94]-Binary Tree Inorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-96-Unique-Binary-Search-Trees"><span class="nav-number">30.</span> <span class="nav-text">Leetcode[96]-Unique Binary Search Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-98-Validate-Binary-Search-Tree"><span class="nav-number">31.</span> <span class="nav-text">Leetcode[98]-Validate Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-100-Same-Tree"><span class="nav-number">32.</span> <span class="nav-text">Leetcode[100]-Same Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-101-Symmetric-Tree"><span class="nav-number">33.</span> <span class="nav-text">Leetcode[101]-Symmetric Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-102-Binary-Tree-Level-Order-Traversal"><span class="nav-number">34.</span> <span class="nav-text">Leetcode[102]-Binary Tree Level Order Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><span class="nav-number">35.</span> <span class="nav-text">Leetcode[103]-Binary Tree Zigzag Level Order Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-104-Maximum-Depth-of-Binary-Tree"><span class="nav-number">36.</span> <span class="nav-text">Leetcode[104]-Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-107-Binary-Tree-Level-Order-Traversal-II"><span class="nav-number">37.</span> <span class="nav-text">Leetcode[107]-Binary Tree Level Order Traversal II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-110-Balanced-Binary-Tree"><span class="nav-number">38.</span> <span class="nav-text">Leetcode[110]-Balanced Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">39.</span> <span class="nav-text">Leetcode[111]-Minimum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-113-Path-Sum-II"><span class="nav-number">40.</span> <span class="nav-text">Leetcode[113]-Path Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-114-Flatten-Binary-Tree-to-Linked-List"><span class="nav-number">41.</span> <span class="nav-text">Leetcode[114]-Flatten Binary Tree to Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-118-Pascal’s-Triangle"><span class="nav-number">42.</span> <span class="nav-text">Leetcode[118]-Pascal’s Triangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-119-Pascal’s-Triangle-II"><span class="nav-number">43.</span> <span class="nav-text">Leetcode[119]-Pascal’s Triangle II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-125-Valid-Palindrome"><span class="nav-number">44.</span> <span class="nav-text">Leetcode[125]-Valid Palindrome</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-128-Longest-Consecutive-Sequence"><span class="nav-number">45.</span> <span class="nav-text">Leetcode[128]-Longest Consecutive Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-129-Sum-Root-to-Leaf-Numbers"><span class="nav-number">46.</span> <span class="nav-text">Leetcode[129]-Sum Root to Leaf Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-136-Single-Number"><span class="nav-number">47.</span> <span class="nav-text">Leetcode[136]-Single Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-137-Single-Number-II"><span class="nav-number">48.</span> <span class="nav-text">Leetcode[137]-Single Number II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-141-Linked-List-Cycle"><span class="nav-number">49.</span> <span class="nav-text">Leetcode[141]-Linked List Cycle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-143-Reorder-List"><span class="nav-number">50.</span> <span class="nav-text">Leetcode[143]-Reorder List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-144-Binary-Tree-Preorder-Traversal"><span class="nav-number">51.</span> <span class="nav-text">Leetcode[144]-Binary Tree Preorder Traversal</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-递归遍历："><span class="nav-number">51.1.</span> <span class="nav-text">C++递归遍历：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-递归遍历二"><span class="nav-number">51.2.</span> <span class="nav-text">C++递归遍历二:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非递归遍历C-："><span class="nav-number">51.3.</span> <span class="nav-text">非递归遍历C++：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-145-Binary-Tree-Postorder-Traversal"><span class="nav-number">52.</span> <span class="nav-text">Leetcode[145]-Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-147-Insertion-Sort-List"><span class="nav-number">53.</span> <span class="nav-text">Leetcode[147]-Insertion Sort List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-148-Sort-List"><span class="nav-number">54.</span> <span class="nav-text">Leetcode[148]-Sort List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-153-Find-Minimum-in-Rotated-Sorted-Array"><span class="nav-number">55.</span> <span class="nav-text">Leetcode[153]-Find Minimum in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II"><span class="nav-number">56.</span> <span class="nav-text">Leetcode[154]-Find Minimum in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode-155-Min-Stack"><span class="nav-number">57.</span> <span class="nav-text">LeetCode[155]-Min Stack</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-162-Find-Peak-Element"><span class="nav-number">58.</span> <span class="nav-text">Leetcode[162]-Find Peak Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-169-Majority-Element"><span class="nav-number">59.</span> <span class="nav-text">Leetcode[169]-Majority Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-173-Binary-Search-Tree-Iterator"><span class="nav-number">60.</span> <span class="nav-text">Leetcode[173]-Binary Search Tree Iterator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-189-Rotate-Array"><span class="nav-number">61.</span> <span class="nav-text">Leetcode[189]-Rotate Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-191-Number-of-Bits"><span class="nav-number">62.</span> <span class="nav-text">Leetcode[191]-Number of Bits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-198-House-Robber"><span class="nav-number">63.</span> <span class="nav-text">Leetcode[198]-House Robber</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-202-Happy-Number"><span class="nav-number">64.</span> <span class="nav-text">Leetcode[202]-Happy Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-203-Remove-Linked-List-Elements"><span class="nav-number">65.</span> <span class="nav-text">Leetcode[203]-Remove Linked List Elements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-206-Reverse-Linked-List"><span class="nav-number">66.</span> <span class="nav-text">Leetcode[206]-Reverse Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-215-Kth-Largest-Element-in-an-Array"><span class="nav-number">67.</span> <span class="nav-text">Leetcode[215]-Kth Largest Element in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-217-Contains-Duplicate"><span class="nav-number">68.</span> <span class="nav-text">Leetcode[217]-Contains Duplicate</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-219-Contains-Duplicate-II"><span class="nav-number">69.</span> <span class="nav-text">Leetcode[219]-Contains Duplicate II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-222-Count-Complete-Tree-Nodes"><span class="nav-number">70.</span> <span class="nav-text">Leetcode[222]-Count Complete Tree Nodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-226-Invert-Binary-Tree"><span class="nav-number">71.</span> <span class="nav-text">Leetcode[226]-Invert Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-231-Power-of-Two"><span class="nav-number">72.</span> <span class="nav-text">Leetcode[231]-Power of Two</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-237-Delete-Node-in-a-Linked-List"><span class="nav-number">73.</span> <span class="nav-text">Leetcode[237]-Delete Node in a Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-242-Valid-Anagram"><span class="nav-number">74.</span> <span class="nav-text">Leetcode[242]-Valid Anagram</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-258-Add-Digits"><span class="nav-number">75.</span> <span class="nav-text">Leetcode[258]-Add Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-260-Single-Number-III"><span class="nav-number">76.</span> <span class="nav-text">Leetcode[260]-Single Number III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-263-Ugly-Number"><span class="nav-number">77.</span> <span class="nav-text">Leetcode[263]-Ugly Number++</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-283-Move-Zeroes"><span class="nav-number">78.</span> <span class="nav-text">Leetcode[283]-Move Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-292-Nim-Game"><span class="nav-number">79.</span> <span class="nav-text">Leetcode[292]-Nim Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-300-Longest-Increasing-Subsequence"><span class="nav-number">80.</span> <span class="nav-text">Leetcode[300]-Longest Increasing Subsequence</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


        
	  </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright">
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘帝伟</span>
</div>
<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="#">
    FreeSky
  </a>(Reserved)

  
  <span id="busuanzi_container_site_uv">
     &nbsp; | &nbsp;  用户量: <span id="busuanzi_value_site_uv"></span>
  </span>
  <span id="busuanzi_container_site_pv">
    &nbsp; | &nbsp;  总访问量: <span id="busuanzi_value_site_pv"></span>
  </span>

</div>
      <div style="width:800px;margin:0 auto; padding:0px 0; font-size: 1em">
        <span><a href="https://beian.miit.gov.cn" target="_blank">粤ICP备19116962号</a></span>
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030702002575" style="display:inline-block;text-decoration:none;height:18px;line-height:20px;">
        <img src="/images/beian.png" style="float:left;"><p style="float:left;height:17px;line-height:20px;margin: 0px 0px 0px 4px; color:#939393;">粤公网安备 44030702002575号</p></a>
      </div>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/others/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'csuldw';
      var disqus_identifier = '2015/12/12/2015-12-12-LeetCode-ans/';
      var disqus_title = 'LeetCode部分题解';
      var disqus_url = 'https://www.csuldw.com/2015/12/12/2015-12-12-LeetCode-ans/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/others/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/others/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/others/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/others/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    var $aboutContent = $('#posts-about');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0 && $aboutContent.length === 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



  
  

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"3","bdPos":"left","bdTop":"250"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>



  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
  
     <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("VmAcWiBwF1SdavvjD8vkHJLn-gzGzoHsz", "cmuscA82gXyC9N1tgjH1m8bK");</script>
<script>
function showTime(Counter) {
  var query = new AV.Query(Counter);
  $(".leancloud_visitors").each(function() {
    var url = $(this).attr("id").trim();
    query.equalTo("url", url);
    query.find({
      success: function(results) {
        if (results.length == 0) {
          var content = $(document.getElementById(url)).text() + ': 0';
          $(document.getElementById(url)).text(content);
          return;
        }
        for (var i = 0; i < results.length; i++) {
          var object = results[i];
          var content = $(document.getElementById(url)).text() + ': ' + object.get('time');
          $(document.getElementById(url)).text(content);
        }
      },
      error: function(object, error) {
        console.log("Error: " + error.code + " " + error.message);
      }
    });

  });
}

function addCount(Counter) {
  var Counter = AV.Object.extend("Counter");
  url = $(".leancloud_visitors").attr('id').trim();
  title = $(".leancloud_visitors").attr('data-flag-title').trim();
  var query = new AV.Query(Counter);
  query.equalTo("url", url);
  query.find({
    success: function(results) {
      if (results.length > 0) {
        var counter = results[0];
        counter.fetchWhenSave(true);
        counter.increment("time");
        counter.save(null, {
          success: function(counter) {
            var content = $(document.getElementById(url)).text() + ': ' + counter.get('time');
            $(document.getElementById(url)).text(content);
          },
          error: function(counter, error) {
            console.log('Failed to save Visitor num, with error message: ' + error.message);
          }
        });
      } else {
        var newcounter = new Counter();
        newcounter.set("title", title);
        newcounter.set("url", url);
        newcounter.set("time", 1);
        newcounter.save(null, {
          success: function(newcounter) {
              console.log("newcounter.get('time')="+newcounter.get('time'));
            var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time');
            $(document.getElementById(url)).text(content);
          },
          error: function(newcounter, error) {
            console.log('Failed to create');
          }
        });
      }
    },
    error: function(error) {
      console.log('Error:' + error.code + " " + error.message);
    }
  });
}
$(function() {
  var Counter = AV.Object.extend("Counter");
  if ($('.leancloud_visitors').length == 1) {
    addCount(Counter);
  } else if ($('.post-title-link').length > 1) {
    showTime(Counter);
  }
}); 
</script>
  
</body>
</html>
