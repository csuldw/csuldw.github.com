<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>机器学习-组合算法总结 | 刘帝伟-技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="组合模型下面简单的介绍下Bootstraping, Bagging, Boosting, AdaBoost, RandomForest 和Gradient boosting这些组合型算法.
1.BootstrapingBootstraping: 名字来自成语“pull up by your own bootstraps”，意思就是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习-组合算法总结">
<meta property="og:url" content="http://csuldw.github.io/2015/07/22/2015-07-22  assemble/index.html">
<meta property="og:site_name" content="刘帝伟-技术博客">
<meta property="og:description" content="组合模型下面简单的介绍下Bootstraping, Bagging, Boosting, AdaBoost, RandomForest 和Gradient boosting这些组合型算法.
1.BootstrapingBootstraping: 名字来自成语“pull up by your own bootstraps”，意思就是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统">
<meta property="og:updated_time" content="2015-07-24T15:01:18.710Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="机器学习-组合算法总结">
<meta name="twitter:description" content="组合模型下面简单的介绍下Bootstraping, Bagging, Boosting, AdaBoost, RandomForest 和Gradient boosting这些组合型算法.
1.BootstrapingBootstraping: 名字来自成语“pull up by your own bootstraps”，意思就是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统">
  
    <link rel="alternative" href="/atom.xml" title="刘帝伟-技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?0b8e8ee87e4708173f00d9048c309301";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/blogImg/face.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">刘帝伟</a></h1>
		</hgroup>

		
		<p class="header-subtitle">悄悄是别离的笙箫，沉默是今晚的康桥。</p>
		

		
			<div class="switch-btn switch-new">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">存档</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/csuldw" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/liudiwei210" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AI/" style="font-size: 10px;">AI</a> <a href="/tags/BioInfo/" style="font-size: 10px;">BioInfo</a> <a href="/tags/CV/" style="font-size: 10px;">CV</a> <a href="/tags/Machine-Learning/" style="font-size: 20px;">Machine Learning</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/SublimeLinter/" style="font-size: 10px;">SublimeLinter</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">中南大学在读硕士，关注机器学习，数据挖掘和生物信息</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">刘帝伟</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/assets/blogImg/face.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">刘帝伟</h1>
			</hgroup>
			
			<p class="header-subtitle">悄悄是别离的笙箫，沉默是今晚的康桥。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">存档</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/csuldw" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/liudiwei210" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2015-07-22  assemble" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/22/2015-07-22  assemble/" class="article-date">
  	<time datetime="2015-07-21T22:53:00.000Z" itemprop="datePublished">Jul 22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      机器学习-组合算法总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Machine-Learning/">Machine Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="组合模型"><strong>组合模型</strong></h2><p>下面简单的介绍下Bootstraping, Bagging, Boosting, AdaBoost, RandomForest 和Gradient boosting这些组合型算法.</p>
<h3 id="1-Bootstraping"><strong>1.Bootstraping</strong></h3><p><strong>Bootstraping</strong>: 名字来自成语“pull up by your own bootstraps”，意思就是依靠你自己的资源，称为自助法，它是一种有放回的抽样方法，它是非参数统计中一种重要的估计统计量方差进而进行区间估计的统计方法。其核心思想和基本步骤如下：  </p>
<blockquote>
<p>（1）采用重抽样技术从原始样本中抽取一定数量（自己给定）的样本，此过程允许重复抽样。<br>（2）根据抽出的样本计算给定的统计量T。<br>（3）重复上述N次（一般大于1000），得到N个统计量T。<br>（4）计算上述N个统计量T的样本方差，得到统计量的方差。 </p>
</blockquote>
 <a id="more"></a>
<p>应该说Bootstrap是现代统计学较为流行的一种统计方法，在小样本时效果很好。通过方差的估计可以构造置信区间等，其运用范围得到进一步延伸。</p>
<hr>
<h3 id="2-装袋bagging"><strong>2.装袋bagging</strong></h3><p>装袋算法相当于多个专家投票表决，对于多次测试，每个样本返回的是多次预测结果较多的那个。</p>
<p>装袋算法描述</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">模型生成</span><br><span class="line">	令<span class="keyword">n</span>为训练数据的实例数量</span><br><span class="line">	对于t次循环中的每一次</span><br><span class="line">		从训练数据中采样<span class="keyword">n</span>个实例</span><br><span class="line">		将学习应用于所采样本</span><br><span class="line">		保存结果模型</span><br><span class="line">分类</span><br><span class="line">	对于t个模型的每一个</span><br><span class="line">		使用模型对实例进行预测</span><br><span class="line">	返回被预测次数最多的一个</span><br></pre></td></tr></table></figure>
<p>bagging：bootstrap aggregating的缩写。让该学习算法训练多轮，每轮的训练集由从初始的训练集中随机取出的n个训练样本组成，某个初始训练样本在某轮训练集中可以出现多次或根本不出现，训练之后可得到一个预测函数序列</p>
<p>$$h_1，⋯ ⋯h_n$$ </p>
<p>最终的预测函数H对分类问题采用<strong>投票方式</strong>，对回归问题采用<strong>简单平均方法</strong>对新示例进行判别。</p>
<p>$$[训练R个分类器f_i，分类器之间其他相同就是参数不同。其中f_i是通过从训练集合中(N篇文档)随机取(取后放回)N次文档构成的训练集合训练得到的。对于新文档d，用这R个分类器去分类，得到的最多的那个类别作为d的最终类别。]$$</p>
<p>使用scikit-learn测试bagging方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>bagging = BaggingClassifier(KNeighborsClassifier(),</span><br><span class="line"><span class="prompt">... </span>                            max_samples=<span class="number">0.5</span>, max_features=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="3-提升Boosting与Adaboost"><strong>3.提升Boosting与Adaboost</strong></h3><p><strong>提升算法描述</strong></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">模型生成</span><br><span class="line">	赋予每个训练实例相同的权值</span><br><span class="line">	t次循环中的每一次：</span><br><span class="line">		将学习算法应用于加了权的数据集上并保存结果模型</span><br><span class="line">		计算模型在加了权的数据上的误差<span class="keyword">e</span>并保存这个误差</span><br><span class="line">		结果<span class="keyword">e</span>等于0或者大于等于0.5：</span><br><span class="line">			终止模型</span><br><span class="line">		对于数据集中的每个实例：</span><br><span class="line">			如果模型将实例正确分类</span><br><span class="line">				将实例的权值乘以<span class="keyword">e</span>/(1-<span class="keyword">e</span>)</span><br><span class="line">		将所有的实例权重进行正常化</span><br><span class="line">分类</span><br><span class="line">	赋予所有类权重为0</span><br><span class="line">	对于t（或小于t）个模型中的每一个：</span><br><span class="line">		给模型预测的类加权 -<span class="literal">log</span>(<span class="keyword">e</span>/(1-<span class="keyword">e</span>))</span><br><span class="line">	返回权重最高的类</span><br></pre></td></tr></table></figure>
<p>这个模型提供了一种巧妙的方法生成一系列互补型的专家。</p>
<p><strong>boosting</strong>: 其中主要的是<strong>AdaBoost</strong>（Adaptive boosting，自适应boosting）。初始化时对每一个训练例赋相等的权重1／N，然后用该学算法对训练集训练t轮，每次训练后，对训练失败的训练例赋以较大的权重，也就是让学习算法在后续的学习中集中对比较难的训练例进行学习，从而得到一个预测函数序列$h_1,⋯, h_m$ , 其中h_i也有一定的权重，预测效果好的预测函数权重较大，反之较小。最终的预测函数H对分类问题采用有权重的投票方式，对回归问题采用加权平均的方法对新示例进行判别。</p>
<p>提升算法理想状态是这些模型对于其他模型来说是一个补充，每个模型是这个领域的一个专家，而其他模型在这部分却不能表现很好，就像执行官一样要寻觅那些技能和经验互补的顾问，而不是重复的。这与装袋算法有所区分。</p>
<p>Adaboost算法描述</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">模型生成</span><br><span class="line">	训练数据中的每个样本，并赋予一个权重，构成权重向量<span class="keyword">D</span>，初始值为1/<span class="keyword">N</span></span><br><span class="line">	t次循环中的每一次：</span><br><span class="line">		在训练数据上训练弱分类器并计算分类器的错误率<span class="literal">e</span></span><br><span class="line">		如果<span class="keyword">e</span>等于0或者大于等于用户指定的阈值：</span><br><span class="line">			终止模型，<span class="keyword">break</span></span><br><span class="line">		重新调整每个样本的权重，其中<span class="keyword">alpha</span>=0.5*<span class="literal">ln</span>((1-<span class="keyword">e</span>)/<span class="keyword">e</span>)</span><br><span class="line">		对权重向量<span class="keyword">D</span>进行更新，正确分类的样本的权重降低而错误分类的样本权重值升高</span><br><span class="line">		对于数据集中的每个样例：</span><br><span class="line">			如果某个样本正确分类：</span><br><span class="line">				权重改为<span class="keyword">D</span>^(t+1)_i = <span class="keyword">D</span>^(t)_i * <span class="keyword">e</span>^(-a)/<span class="literal">Sum</span>(<span class="keyword">D</span>)</span><br><span class="line">			如果某个样本错误分类：</span><br><span class="line">				权重改为<span class="keyword">D</span>^(t+1)_i = <span class="keyword">D</span>^(t)_i * <span class="keyword">e</span>^(a)/<span class="literal">Sum</span>(<span class="keyword">D</span>)</span><br><span class="line">分类</span><br><span class="line">	赋予所有类权重为0</span><br><span class="line">	对于t（或小于t）个模型（基分类器）中的每一个：</span><br><span class="line">		给模型预测的类加权 -<span class="literal">log</span>(<span class="keyword">e</span>/(1-<span class="keyword">e</span>))</span><br><span class="line">	返回权重最高的类</span><br></pre></td></tr></table></figure>
<p>（类似Bagging方法，但是训练是串行进行的，第k个分类器训练时关注对前k-1分类器中错分的文档，即不是随机取，而是加大取这些文档的概率。)</p>
<p><strong>bagging与boosting的区别</strong>：</p>
<p>二者的主要区别是<strong>取样方式不同</strong>。bagging采用<strong>均匀取样</strong>，而Boosting根据<strong>错误率来取样</strong>，因此boosting的分类精度要优于Bagging。bagging的训练集的选择是随机的，各轮训练集之间相互独立，而boostlng的各轮训练集的选择与前面各轮的学习结果有关；bagging的各个预测函数没有权重，而boosting是有权重的；bagging的各个预测函数可以并行生成，而boosting的各个预测函数只能顺序生成。对于象神经网络这样极为耗时的学习方法。bagging可通过并行训练节省大量时间开销。</p>
<p>bagging和boosting都可以有效地提高分类的准确性。在大多数数据集中，boosting的准确性比bagging高。在有些数据集中，boosting会引起退化—- Overfit。  </p>
<p>Boosting思想的一种改进型AdaBoost方法在邮件过滤、文本分类方面都有很好的性能。 </p>
<p><strong>Gradient boosting（又叫Mart, Treenet)</strong>：Boosting是一种思想，Gradient Boosting是一种实现Boosting的方法，它主要的思想是，每一次建立模型是在之前建立模型<strong>损失函数的梯度下降方向</strong>。<strong>损失函数(loss function)描述的是模型的不靠谱程度，损失函数越大，则说明模型越容易出错。</strong>如果我们的模型能够让损失函数持续的下降，则说明我们的模型在不停的改进，而最好的方式就是<strong>让损失函数在其梯度（Gradient)的方向上下降</strong>。  </p>
<p>使用scikit-learn测试adaboost算法</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.cross_validation</span> import cross_val_score</span><br><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.datasets</span> import load_iris</span><br><span class="line">&gt;&gt;&gt; from sklearn<span class="class">.ensemble</span> import AdaBoostClassifier</span><br><span class="line">&gt;&gt;&gt; iris = <span class="function"><span class="title">load_iris</span><span class="params">()</span></span></span><br><span class="line">&gt;&gt;&gt; clf = <span class="function"><span class="title">AdaBoostClassifier</span><span class="params">(n_estimators=<span class="number">100</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; scores = <span class="function"><span class="title">cross_val_score</span><span class="params">(clf, iris.data, iris.target)</span></span></span><br><span class="line">&gt;&gt;&gt; scores.<span class="function"><span class="title">mean</span><span class="params">()</span></span>                             </span><br><span class="line"><span class="number">0.9</span>...</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="4-Random_Forest"><strong>4.Random Forest</strong></h3><p><strong>Random Forest</strong>： 随机森林，顾名思义，是用随机的方式建立一个森林，森林里面有很多的决策树组成，随机森林的每一棵决策树之间是没有关联的。在得到森林之后，当有一个新的输入样本进入的时候，就让森林中的每一棵决策树分别进行一下判断，看看这个样本应该属于哪一类（对于分类算法），然后看看哪一类被选择最多，就预测这个样本为那一类。 在建立每一棵决策树的过程中，有两点需要注意——<strong>采样</strong>与<strong>完全分裂</strong>。首先是两个随机采样的过程，random forest对输入的数据要进行行和列的采样。对于行采样，采用有放回的方式，也就是在采样得到的样本集合中，可能有重复的样本。假设输入样本为N个，那么采样的样本也为N个。这样使得在训练的时候，每一棵树的输入样本都不是全部的样本，使得相对不容易出现over-fitting。然后进行列采样，从M个feature中，选择m个(m &lt;&lt; M)。之后就是对采样之后的数据使用完全分裂的方式建立出决策树，这样决策树的某一个叶子节点要么是无法继续分裂的，要么里面的所有样本的都是指向的同一个分类。<strong>一般很多的决策树算法都一个重要的步骤——剪枝，但随机森林不这样做，由于之前的两个随机采样的过程保证了随机性，所以就算不剪枝，也不会出现over-fitting。</strong> 按这种算法得到的随机森林中的每一棵都是很弱的，但是大家组合起来就很厉害了。可以这样比喻随机森林算法：每一棵决策树就是一个精通于某一个窄领域的专家（因为我们从M个feature中选择m让每一棵决策树进行学习），这样在随机森林中就有了很多个精通不同领域的专家，对一个新的问题（新的输入数据），可以用不同的角度去看待它，最终由各个专家，投票得到结果。  </p>
<p><strong>Random forest与bagging的区别</strong>：</p>
<p>(1)Random forest是选与输入样本的数目相同多的次数（可能一个样本会被选取多次，同时也会造成一些样本不会被选取到），而bagging一般选取比输入样本的数目少的样本；<br>(2)bagging是用全部特征来得到分类器，而Random forest是需要从全部特征中选取其中的一部分来训练得到分类器； <strong>一般Random forest效果比bagging效果好！</strong></p>
<p>使用scikit-learn测试随机森林算法</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; from sklearn.ensemble import <span class="constant">RandomForestClassifier</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">X</span> = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">Y</span> = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = <span class="constant">RandomForestClassifier</span>(n_estimators=<span class="number">10</span>)</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; clf = clf.fit(<span class="constant">X</span>, <span class="constant">Y</span>)</span><br></pre></td></tr></table></figure>
<h3 id="5-Gradient_boosting"><strong>5.Gradient boosting</strong></h3><p>梯度提升树或者梯度提升回归树(GBRT)是任意一个不同损失函数的泛化。GBRT是一个灵敏的并且高效程序，可以用在回归和分类中。梯度提升树模型在许多领域中都有使用，如web搜索排行榜和社会生态学中。它主要的思想是，每一次建立模型是在之前建立模型损失函数的梯度下降方向。这句话有一点拗口，损失函数(loss function)描述的是模型的不靠谱程度，损失函数越大，则说明模型越容易出错（其实这里有一个方差、偏差均衡的问题，但是这里就假设损失函数越大，模型越容易出错）。如果我们的模型能够让损失函数持续的下降，则说明我们的模型在不停的改进，而最好的方式就是让损失函数在其梯度（Gradient)的方向上下降。</p>
<p>GRBT的优势：</p>
<ul>
<li>混合数据类型的自然处理</li>
<li>预测力强</li>
<li>健壮的输出空间</li>
</ul>
<p>Boosting主要是一种思想，表示“知错就改”。而Gradient Boosting是在这个思想下的一种函数（也可以说是模型）的优化的方法，首先将函数分解为可加的形式（其实所有的函数都是可加的，只是是否好放在这个框架中，以及最终的效果如何）。然后进行m次迭代，通过使得损失函数在梯度方向上减少，最终得到一个优秀的模型。值得一提的是，每次模型在梯度方向上的减少的部分，可以认为是一个“小”的或者“弱”的模型，最终我们会通过加权(也就是每次在梯度方向上下降的距离）的方式将这些“弱”的模型合并起来，形成一个更好的模型。</p>
<hr>
<p><br></p>
<p><center><strong>本栏目Machine Learning持续更新中，欢迎关注：<a href="http://blog.csdn.net/dream_angel_z" target="_blank" rel="external">Dream_Angel_Z博客</a></strong></center><br><br></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/07/23/2015-07-23 machine learning tips/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          机器学习-学习小记
        
      </div>
    </a>
  
  
    <a href="/2015/07/21/2015-07-21 An introduction to machine learning with scikit-learn /" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">机器学习scikit-learn入门教程（译）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<ul class="ds-recent-visitors" data-num-items="20" data-avatar-size="44.5" ></ul>
	<div class="ds-thread" data-thread-key="2015-07-22  assemble" data-title="机器学习-组合算法总结" data-url="http://csuldw.github.io/2015/07/22/2015-07-22  assemble/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"csuldw"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 刘帝伟
    	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>